var __index = Promise.resolve({"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+","tags":false},"docs":[{"location":"build/","text":"<p>Ceramic provides a decentralized network for building Web3 applications with composable data. Ceramic's APIs enable applications to store, modify, and retrieve data from a scalable decentralized data network, while maintaining composability of data across applications.</p>","title":"Build applications"},{"location":"build/#get-started-with-frameworks","text":"<p>Frameworks make it easy to build applications on Ceramic by abstracting away much of the complexity and configuration of the underlying Ceramic stack, providing developers with a simple entrypoint into Ceramic development. If you're new to Ceramic, or even if you're experienced, this is the place to start.</p>","title":"Get started with frameworks"},{"location":"build/#selfid-sdk","text":"<p>Self.ID is a framework for building Ceramic applications with composable, user-centric data. In addition to including a full Ceramic setup for a variety of development environments, Self.ID allows users to authenticate with their existing blockchain wallets and also includes some of the most popular data models giving you out of the box composability with a rich set of data on the network to bootstrap your application.</p>","title":"Self.ID SDK \u2192"},{"location":"build/#go-deeper-with-clients","text":"<p>Clients are a lower-level way to connect your application to the Ceramic network. They come without much pre-configuration, so you'll need to put at least a few different pieces together yourself.</p>","title":"Go deeper with clients"},{"location":"build/#javascript-http-client","text":"<p>The Ceramic JS HTTP client is a Ceramic client that can be used in browsers and Node.js environments to connect your application to a Ceramic node. This is the recommended Ceramic client to build with for most applications, if you're not using a framework.</p>","title":"JavaScript HTTP client \u2192"},{"location":"build/share/","text":"<p>Congratulations on making it this far! We're excited to see what you've built with Ceramic. To help the community discover your work:</p> <ul> <li>Add the <code>ceramic</code> topic to your project on Github</li> <li>Add your project to the Awesome Ceramic page on Github</li> </ul>","title":"Share your project"},{"location":"build/the-ceramic-stack/","text":"<p>The Ceramic application development stack consists of a few key components which are listed below, in order from highest-level frameworks to lowest-level network APIs.</p>","title":"The Ceramic stack"},{"location":"build/the-ceramic-stack/#1-frameworks","text":"<p>Frameworks abstract away much of the complexity and configuration of the underlying stack, providing developers with a simple entrypoint into Ceramic development. In order to achieve simplicity, frameworks tend to be opinionated about how and what you build on the network.</p>  <p>The most popular framework for Ceramic is the Self.ID SDK, a bundle that includes everything you need to build applications with composable, user-centric Web3 data.</p>","title":"1. Frameworks"},{"location":"build/the-ceramic-stack/#2-middleware","text":"<p>Middleware is a generic name for all kinds of development tools that are not a part of the core Ceramic protocol, but provide developers with additional functionality and convenience.</p>  <p>The most popular middleware for Ceramic is Glaze suite, which provides a set of libraries that developers can use alongside a Ceramic client when building applications.</p>","title":"2. Middleware"},{"location":"build/the-ceramic-stack/#3-data-models","text":"<p>Data models are collections of one or more streams, specified by their schemas and relationships, that define a single data structure on Ceramic. Data models form the basis of composability on Ceramic. When multiple applications reuse the same data model, they can reuse the same data. Typically, data models are used to represent an application feature such as a social graph or a user profile.</p>  <p>The most popular data models for Ceramic can be found in the Data Models Registry \u2192, an open registry of Ceramic data models created by the community.</p>","title":"3. Data models"},{"location":"build/the-ceramic-stack/#4-streams","text":"<p>Streams are individual instances of state on the Ceramic network. Every stream that is created on Ceramic must specify its streamcode, which is a script that contains the processing logic used to transform a stream's current state into the next state upon receipt of a new transaction. In general, you can think of streamcode as reusable state processing logic and streams as the individual states it generates.</p>  <p>Today Ceramic supports two types of streams: tile documents which store mutable JSON documents with schema validation, and CAIP-10 links which store a link between a Web3 wallet account and a Ceramic account.</p>","title":"4. Streams"},{"location":"build/the-ceramic-stack/#5-accounts","text":"<p>Accounts are user entities on Ceramic that can own streams and submit transactions to those streams. Ceramic accounts conform to the standard decentralized identifier (DID) specification, as outlined by the Decentralized Identity Foundation (DIF). DIDs are useful as they serve to unbundle Ceramic accounts from any single Web3 wallet address or public key, allowing users to control the same Ceramic account from one or more Web3 wallet accounts, and in the process providing an abstraction to enable truly cross-chain accounts.</p>  <p>The most popular account client is the DID JSON-RPC client, which provides a standard account API and must be used alongside a Ceramic client in order to enable authenticated accounts to perform transactions on the network. The DID client currently supports two different account types: 3ID DID, which allows controlling a Ceramic account from multiple Web3 wallet addresses, and Key DID, which can only be controlled by a single Web3 wallet address.</p>","title":"5. Accounts"},{"location":"build/the-ceramic-stack/#6-clients","text":"<p>Clients libraries allow your application to connect to a Ceramic node. Different clients may choose to implement different high-level, language-specific developer APIs. Before submitting requests to a Ceramic node, clients translate those API calls into the standard Ceramic HTTP API, which it uses to actually communicate with a Ceramic node.</p>  <p>The most popular client on Ceramic is the JS HTTP client, allowing developers to connect their application to Ceramic using JavaScript.</p>","title":"6. Clients"},{"location":"build/the-ceramic-stack/#7-network-apis","text":"<p>The Ceramic HTTP API is the lowest-level interface for Ceramic. It is used under the hood by every client and node to communicate. Unless application developers have a specific need to use HTTP, most never need to interact with this API directly, instead accessing it via more developer-friendly client APIs. Protocol developers wishing to write a client in a new language, however, would need to use this specification.</p>  <p>Learn more about the Ceramic HTTP API.</p>","title":"7. Network APIs"},{"location":"build/troubleshooting/","text":"","title":"Troubleshooting"},{"location":"build/troubleshooting/#known-issues","text":"<p>If you encounter an issue, see if it's already known with a recommended work around or currently under investigation in this document. Leave feedback or notes in the comment if something is unclear or out of date.</p>","title":"Known Issues"},{"location":"build/troubleshooting/#developer-chat","text":"<p>For developer questions, chat, and support, join us on the Ceramic Discord .</p>","title":"Developer Chat"},{"location":"build/troubleshooting/#github-issues","text":"<p>For specific bugs, issues, and feature requests, create a Github issue  on the appropriate repository. Before creating a new issue, please search existing issues to ensure your issue has not already been reported. If it has, just add a new comment to that issue explaining that you are encourering the same problem.</p>","title":"Github Issues"},{"location":"build/troubleshooting/#twitter","text":"<p>For updates and news from the Ceramic ecosystem, follow Ceramic on Twitter .</p>","title":"Twitter"},{"location":"build/cli/api/","text":"<p>This page describes CLI commands for interacting with Ceramic.</p>","title":"CLI API"},{"location":"build/cli/api/#requirements","text":"<p>You should have already installed the CLI.</p>","title":"Requirements"},{"location":"build/cli/api/#write-apis","text":"","title":"Write APIs"},{"location":"build/cli/api/#create-a-stream","text":"<p>Use the <code>create</code> command to create a new stream. In the example below we create a stream that uses the TileDocument StreamType. Note that TileDocument is the only StreamType that can currently be created by the Ceramic CLI.</p> <pre><code>ceramic create tile --content '{ \"Foo\": \"Bar\" }'\n</code></pre> <p>The first line of your output will be the StreamID of your stream. Below the StreamID, you will see it's content.</p> <p>Create options:</p> <p>Run <code>ceramic create -h</code> to see all available create options. Some common options:</p> <ul> <li><code>--content</code>: set the content of the stream</li> <li><code>--controllers</code>: set the controller of the stream</li> <li><code>--schema</code>: set the schema of the TileDocument</li> </ul>","title":"Create a stream"},{"location":"build/cli/api/#update-a-stream","text":"<p>Use the <code>update</code> command to update a stream. You will need to provide a StreamID. Your DID must be the controller of the stream in order to update it. Note that TileDocument is the only StreamType that can currently be updated by the CLI.</p> <pre><code>ceramic update kjzl6cwe1jw147ww5d8pswh1hjh686mut8v1br10dar8l9a3n1wf8z38l0bg8qa --content '{\n    \"Foo\": \"Baz\"\n  }'\n</code></pre> <p>Update options:</p> <p>Run <code>ceramic update -h</code> to see all available update options. Some common options:</p> <ul> <li><code>--content</code>: update the content of the stream</li> <li><code>--controllers</code>: update the controller of the stream</li> <li><code>--schema</code>: update the schema of the TileDocument</li> </ul>","title":"Update a stream"},{"location":"build/cli/api/#query-apis","text":"","title":"Query APIs"},{"location":"build/cli/api/#query-a-streams-current-state","text":"<p>Use the <code>show</code> command to query the current state of a stream. You will need to provide a StreamID.</p> <pre><code>ceramic show kjzl6cwe1jw147ww5d8pswh1hjh686mut8v1br10dar8l9a3n1wf8z38l0bg8qa\n</code></pre>","title":"Query a stream's current state"},{"location":"build/cli/api/#query-a-streams-entire-state","text":"<p>Use the <code>state</code> command to query the entire state of a stream. You will need to provide a StreamID.</p> <pre><code>ceramic state kjzl6cwe1jw147ww5d8pswh1hjh686mut8v1br10dar8l9a3n1wf8z38l0bg8qa\n</code></pre>","title":"Query a stream's entire state"},{"location":"build/cli/api/#next-steps","text":"<p>If you haven't already, try putting these CLI commands to use in the Quick Start guide.</p>","title":"Next steps"},{"location":"build/cli/installation/","text":"<p>The Ceramic command line interface provides an easy way to start a JS Ceramic node in a local Node.js environment. This is a great way to get started developing with Ceramic before moving to a cloud-hosted node for production use cases.</p>","title":"Launch a local Ceramic node"},{"location":"build/cli/installation/#prerequisites","text":"<p>Installing the CLI requires a console, Node.js v14, and npm v6. Make sure to have these installed on your machine.</p>  <p>While npm v7 is not officially supported, you may still be able to get it to work. You will need to install the <code>node-pre-gyp</code> package globally. This is required until <code>node-webrtc</code> which IPFS depends on is upgraded.</p> <pre><code>npm install -g node-pre-gyp\n</code></pre>","title":"Prerequisites"},{"location":"build/cli/installation/#installation-and-usage","text":"","title":"Installation and usage"},{"location":"build/cli/installation/#install-the-ceramic-cli","text":"<p>Open your console and install the CLI using npm:</p> <pre><code>npm install -g @ceramicnetwork/cli\n</code></pre>","title":"Install the Ceramic CLI"},{"location":"build/cli/installation/#launch-the-ceramic-node","text":"<p>Use the <code>ceramic daemon</code> command to start a local JS Ceramic node connected to the Clay Testnet at <code>https://localhost:7007</code>.</p> <pre><code>ceramic daemon\n</code></pre> <p>The <code>localhost</code> setup allows you to load streams from other nodes connected to the same network. However, writes to your local node will only be available on your node and other nodes found on the <code>peerlist</code>. They will not be available to every node on the network. For greater connectivity, you might want to connect your CLI to a remote long-lived Ceramic node.</p>","title":"Launch the Ceramic node"},{"location":"build/cli/installation/#configure-your-network","text":"<p>(Optional) By default, the JS CLI starts a node on the Clay Testnet. If you would like to use a different network, you can specify this using the <code>--network</code> option. View available networks. Note, the CLI can not be used with Mainnet.</p>","title":"Configure your network"},{"location":"build/cli/installation/#configure-a-node-url","text":"<p>(Optional) It is possible to use the CLI with a remote Ceramic node over HTTP, instead of a local node. To do this, use the <code>config set</code> command to set the <code>ceramicHost</code> variable to the URL of the node you wish to use.</p> <pre><code>ceramic config set ceramicHost 'https://yourceramicnode.com'\n</code></pre>","title":"Configure a node URL"},{"location":"build/cli/quick-start/","text":"<p>Learn the basics by setting up and interacting with the Ceramic CLI. This tutorial serves as a simple introduction to Ceramic concepts.</p>  <p>Want an even faster way to try Ceramic? Visit the Playground demo app to test the full stack of Ceramic components in the browser.</p>","title":"Quickstart"},{"location":"build/cli/quick-start/#1-install-the-cli","text":"<p>Visit the Ceramic CLI page for instructions on how to quickly install the CLI.</p>","title":"1. Install the CLI"},{"location":"build/cli/quick-start/#2-create-a-stream","text":"<p>Use the <code>create</code> command to create a new stream. In the example below we create a stream that uses the TileDocument StreamType. Note that TileDocument is the only StreamType that can currently be created by the Ceramic CLI.</p> CommandOutput   <pre><code>ceramic create tile --content '{ \"Foo\": \"Bar\" }'\n</code></pre>   <pre><code>StreamID(kjzl6cwe1jw147ww5d8pswh1hjh686mut8v1br10dar8l9a3n1wf8z38l0bg8qa)\n{\n    \"Foo\": \"Bar\"\n}\n</code></pre>  <p>The first line of the output is the StreamID, which is the persistent identifier of our newly created stream. This StreamID will be different for you, since you created it with your DID. Below the StreamID is the current content of the stream.</p>      More options <ul> <li><code>--controllers</code>: set the controller of the stream</li> <li><code>--schema</code>: set the schema of the TileDocument</li> <li>Run <code>ceramic create -h</code> to see all available options</li> </ul>","title":"2. Create a stream"},{"location":"build/cli/quick-start/#3-query-a-stream","text":"<p>Use the <code>show</code> command to query the current state of a stream. You will need to provide its StreamID.</p> CommandOutput   <pre><code>ceramic show kjzl6cwe1jw147ww5d8pswh1hjh686mut8v1br10dar8l9a3n1wf8z38l0bg8qa\n</code></pre>  <p>You should use your StreamID instead of the StreamID included here.</p>    <pre><code>{\n    \"Foo\": \"Bar\"\n}\n</code></pre>    <p>Use the <code>state</code> command to query the entire state of a stream.</p> CommandOutput before anchorOutput after anchor   <pre><code>ceramic state kjzl6cwe1jw147ww5d8pswh1hjh686mut8v1br10dar8l9a3n1wf8z38l0bg8qa\n</code></pre>  <p>You should use your StreamID instead of the StreamID included here.</p>    <pre><code>{\n  \"type\": 0,\n  \"content\": {\n    \"Foo\": \"Bar\"\n  },\n  \"metadata\": {\n    \"unique\": \"E4qPslUd0qo98TZX\",\n    \"schema\": null,\n    \"controllers\": [\n      \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\"\n    ]\n  },\n  \"signature\": 2,\n  \"anchorStatus\": \"PENDING\",\n  \"log\": [\n    {\n      \"cid\": \"bagcqceranhr345kxf5gb3kwjvvnnefn2krqvhkpnurphqrn3lj773mfszmza\",\n      \"type\": 0\n    }\n  ],\n  \"anchorScheduledFor\": \"1/24/2021, 11:45:00 AM\"\n}\n</code></pre>  <p>Here we can see various information about the stream such as content, controllers, and schema. In your output you should see your local DID as the controller, instead of the DID we show here. You will also see a different randomly-generated \"unique\" string for any TileDocument that was created without the <code>--deterministic</code> flag.  We can also see the current anchorStatus of our stream, and that it has been scheduled to be anchored at 11:45 on the 24th of January 2021. Once this anchor is finalized, the state of the stream will automatically be updated with a new entry in the log and anchorStatus will be set to <code>ANCHORED</code>.</p>    <pre><code>{\n  \"type\": 0,\n  \"content\": {\n    \"Foo\": \"Bar\"\n  },\n  \"metadata\": {\n    \"unique\": \"E4qPslUd0qo98TZX\",\n    \"schema\": null,\n    \"controllers\": [\n      \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\"\n    ]\n  },\n  \"signature\": 2,\n  \"anchorStatus\": \"ANCHORED\",\n  \"log\": [\n    {\n      \"cid\": \"bagcqceranhr345kxf5gb3kwjvvnnefn2krqvhkpnurphqrn3lj773mfszmza\",\n      \"type\": 0\n    },\n    {\n      \"cid\": \"bafyreig6hostufw42cmz2cnn7hpvb6pau67a2n2syhzej7orqxfymdayyq\",\n      \"type\": 2\n    }\n  ],\n  \"anchorScheduledFor\": null,\n  \"anchorProof\": {\n    \"root\": \"bagcqceranhr345kxf5gb3kwjvvnnefn2krqvhkpnurphqrn3lj773mfszmza\",\n    \"txHash\": \"bagjqcgza4xgkpjodtqtgyu2fx6rdr6fb6mhevd5hy4253tl6pjlssidpwaha\",\n    \"chainId\": \"eip155:3\",\n    \"blockNumber\": 9527752,\n    \"blockTimestamp\": 1611485094\n  }\n}\n</code></pre>  <p>This output was seen after the anchor has been created. The stream state has now shifted anchorStatus to <code>ANCHORED</code>. You can also see that the log contains one more entry.</p>","title":"3. Query a stream"},{"location":"build/cli/quick-start/#4-update-a-stream","text":"<p>Use the <code>update</code> command to update a stream. Your DID must be the controller of the stream in order to update it. Note that TileDocument is the only StreamType that can currently be updated by the CLI.</p> CommandOutput   <pre><code>ceramic update kjzl6cwe1jw147ww5d8pswh1hjh686mut8v1br10dar8l9a3n1wf8z38l0bg8qa --content '{\n    \"Foo\": \"Baz\"\n  }'\n</code></pre>  <p>You should use your StreamID instead of the StreamID included here.</p>    <pre><code>{\n  \"Foo\": \"Baz\"\n}\n</code></pre>     More options <p>Currently you can change content, controllers, and schema using the CLI. Run <code>ceramic update -h</code> for more information.</p>","title":"4. Update a stream"},{"location":"build/cli/quick-start/#5-create-a-schema","text":"<p>TileDocuments can enforce that their contents adhere to a specified schema. The schemas themselves are TileDocuments where the content is a json-schema. For example we can create a schema that requires a TileDocument to have a title and message.</p> CommandOutput   <pre><code>ceramic create tile --content ' {\n   \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n   \"title\": \"Reward\",\n   \"type\": \"object\",\n   \"properties\": {\n     \"title\": { \"type\": \"string\" },\n     \"message\": { \"type\": \"string\" }\n   },\n   \"required\": [\n     \"message\",\n     \"title\"\n   ]\n }'\n</code></pre>   <pre><code>StreamID(kjzl6cwe1jw1472as4pj3b3ahqmkokbmwc7jchqcob6pcixcoo4kxq6ls8uuxgb)\n{\n  \"type\": \"object\",\n  \"title\": \"Reward\",\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"required\": [\n    \"message\",\n    \"title\"\n  ],\n  \"properties\": {\n    \"title\": {\n      \"type\": \"string\"\n    },\n    \"message\": {\n      \"type\": \"string\"\n    }\n  }\n}\n</code></pre>","title":"5. Create a schema"},{"location":"build/cli/quick-start/#6-create-a-tiledocument-stream-that-uses-a-schema","text":"<p>First, use the <code>commits</code> command to list the commitIDs contained in the schema stream. When creating a TileDocument that uses this schema, we need to use a commitID instead of the StreamID to enforce that we are using a specific version of the schema since the schema stream is mutable and can be updated.</p> CommandOutput   <pre><code>ceramic commits kjzl6cwe1jw1472as4pj3b3ahqmkokbmwc7jchqcob6pcixcoo4kxq6ls8uuxgb\n</code></pre>  <p>You should use your StreamID for the stream containing the json-schema you want to enforce, instead of the StreamID included here.</p>    <pre><code>[\n  \"k3y52l7qbv1frxu8co1hjrivem5cj2oiqtytlku3e4vjo92l67fkkvu6ywuzfxvy8\"\n]\n</code></pre>    <p>If a stream contains multiple commits and you're not sure which one you want, use the <code>show</code> command to show the content of the stream at the given commit.</p> <p>Once you retrieve the desired commit, you can now create a TileDocument that is enforced to conform to this version of the schema. Use the <code>create</code> command and pass the <code>--schema</code> option along with your commitID.</p> CommandOutput   <pre><code>ceramic create tile --content '{\n    \"title\": \"My first document with schema\",\n    \"message\": \"Hello World\"\n  }' --schema k3y52l7qbv1frxu8co1hjrivem5cj2oiqtytlku3e4vjo92l67fkkvu6ywuzfxvy8\n</code></pre>  <p>You should use your commitID instead of the commitID included here.</p>    <pre><code>StreamID(kjzl6cwe1jw149tvfh6otqfzd2hfknkifb1z2lakozkicvau0xldzzdzwfbsztj)\n{\n  \"title\": \"My first document with schema\",\n  \"message\": \"Hello World\"\n}\n</code></pre>","title":"6. Create a TileDocument stream that uses a schema"},{"location":"build/cli/quick-start/#7-query-the-stream-you-created","text":"<p>Use the <code>state</code> command to query the state of the TileDocument we just created. We can see that the schema is set to the correct commitID.</p> CommandOutput   <pre><code>ceramic state kjzl6cwe1jw14b5sr79heovz7fziz4dxcn8upx3bcesriloqcui137k6rq6g2mn\n</code></pre>  <p>You should use your StreamID instead of the StreamID included here.</p>    <pre><code>{\n  \"type\": 0,\n  \"content\": {\n    \"title\": \"My first document with schema\",\n    \"message\": \"Hello World\"\n  },\n  \"metadata\": {\n    \"unique\": \"GR5tBtHdaw608esV\",\n    \"schema\": \"k3y52l7qbv1frxu8co1hjrivem5cj2oiqtytlku3e4vjo92l67fkkvu6ywuzfxvy8\",\n    \"controllers\": [\n      \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\"\n    ]\n  },\n  \"signature\": 2,\n  \"anchorStatus\": \"PENDING\",\n  \"log\": [\n    {\n      \"cid\": \"bagcqcera5qxg5zabjjvwpcbia6c3t6vebgo4brgmsagxezdjgk4vxnzwb5hq\",\n      \"type\": 0\n    }\n  ],\n  \"anchorScheduledFor\": \"1/13/2021, 1:45:00 PM\"\n}\n</code></pre>","title":"7. Query the stream you created"},{"location":"build/cli/quick-start/#thats-it","text":"<p>Congratulations on completing this tutorial! You're well on your way to becoming a Ceramic developer. Now let's install Ceramic in your project \u2192</p>","title":"That's it!"},{"location":"build/clients/","text":"","title":"Clients"},{"location":"build/clients/#types-of-clients","text":"","title":"Types of clients"},{"location":"build/clients/#ceramic-clients","text":"<p>Ceramic clients are libraries that allow your application to communicate with a Ceramic node. Different clients may choose to implement different high-level, language-specific developer APIs. Before submitting requests to a Ceramic node, clients translate those API calls into the standard Ceramic HTTP API, which it uses to actually communicate with a Ceramic node.</p>","title":"Ceramic clients"},{"location":"build/clients/#account-clients","text":"<p>Account clients are libraries that allow your application to recognize users, authenticate, and perform other account-related functionality such as signing transactions and encrypting data.</p>","title":"Account clients"},{"location":"build/clients/#available-clients","text":"<p>When building with Ceramic clients instead of using a framework, be sure to install both a Ceramic client and an account client.</p>","title":"Available clients"},{"location":"build/clients/#js-ceramic-http-client","text":"<p>The Ceramic JS HTTP client is a Ceramic client that can be used in browsers and Node.js environments to connect your application to a Ceramic node. It is actively maintained by 3Box Labs and supports the latest Ceramic features. This is the recommended Ceramic client to build with for most applications.</p>","title":"JS Ceramic HTTP Client \u2192"},{"location":"build/clients/#did-json-rpc-client","text":"<p>The DID JSON-RPC Client is an account client that provides a simple JS API for interacting with Ceramic accounts. It is actively maintained by 3Box Labs and supports all account types.</p>","title":"DID JSON-RPC Client \u2192"},{"location":"build/frameworks/","text":"<p>Frameworks make it easy to build applications on Ceramic by abstracting away much of the complexity and configuration of the underlying Ceramic stack, providing developers with a simple entrypoint into Ceramic development. If you're new to Ceramic, or even if you're experienced, this is the place to start.</p>","title":"Frameworks"},{"location":"build/frameworks/#available-frameworks","text":"","title":"Available frameworks"},{"location":"build/frameworks/#selfid-sdk","text":"<p>Self.ID is a framework for building Ceramic applications with composable, user-centric data. In addition to including a full Ceramic setup for a variety of development environments, Self.ID allows users to authenticate with their existing blockchain wallets and also includes some of the most popular data models giving you out of the box composability with data on the network to bootstrap your application.</p>","title":"Self.ID SDK \u2192"},{"location":"build/http/api/","text":"<p>The Ceramic HTTP API is the standard lowest-level communication protocol between clients and nodes on the Ceramic network. It allows client applications to manually make REST HTTP requests to a remote Ceramic node to send transactons, retrieve data, and \"pin\" data to make it available.</p> <p>If you are building an application, you will usually interact with Ceramic using a client API, such as the JS HTTP Client, or a framework such as the Self.ID SDK, which includes the JS HTTP client by default.</p>","title":"Ceramic HTTP API"},{"location":"build/http/api/#when-to-use-the-http-api","text":"<p>The HTTP API is useful if you have a special use case where you directly want to make manual HTTP requests, or you want to implement an HTTP client in a new language.</p>  <p>Gateway mode</p> <p>Some HTTP API methods will not be available if the Ceramic node you are using runs in gateway mode. This option disables writes, which is useful when exposing your node to the internet. API methods that are disabled when running in gateway mode will be clearly marked.</p>","title":"When to use the HTTP API"},{"location":"build/http/api/#streams-api","text":"<p>The <code>stream</code> endpoint is used to create new streams and load streams from the node using a StreamID or genesis content.</p>","title":"Streams API"},{"location":"build/http/api/#loading-a-stream","text":"<p>Load the state of a stream given its StreamID.</p> RequestResponse   <pre><code>GET /api/v0/streams/:streamid\n</code></pre> <p>Here, <code>:streamid</code> should be replaced by the StreamID of the stream that is being requested.</p>     <p>The response body contains the following fields:</p> <pre><code>- `streamId` - the StreamID of the requested stream as string\n- `state` - the state of the requested stream as [StreamState](https://developers.ceramic.network/reference/typescript/interfaces/_ceramicnetwork_common.streamstate-1.html){:target=\"_blank\"}\n</code></pre>","title":"Loading a stream"},{"location":"build/http/api/#example","text":"RequestResponse   <pre><code>curl http://localhost:7007/api/v0/streams/kjzl6cwe1jw147r7878h32yazawcll6bxe5v92348cxitif6cota91qp68grbhm\n</code></pre>   <pre><code>{\n  \"streamId\": \"kjzl6cwe1jw147r7878h32yazawcll6bxe5v92348cxitif6cota91qp68grbhm\",\n  \"state\": {\n    \"type\": 0,\n    \"content\": {\n      \"Ceramic\": \"pottery\"\n    },\n    \"metadata\": {\n      \"schema\": null,\n      \"controllers\": [\n        \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\"\n      ]\n    },\n    \"signature\": 2,\n    \"anchorStatus\": \"PENDING\",\n    \"log\": [{\n      \"cid\": \"bagcqceramof2xi7kh6qblirzkbc7yulcjcticlcob6uvdrx3bexgks37ilva\",\n      \"type\": 0\n    }],\n    \"anchorScheduledFor\": \"12/15/2020, 2:45:00 PM\"\n  }\n}\n</code></pre>","title":"Example"},{"location":"build/http/api/#creating-stream","text":"<p> Disabled in gateway mode</p> <p>Create a new stream, or load a stream from its genesis content. The genesis content may be signed (e.g. DagJWS for the TileDocument StreamType), or unsigned in some cases.</p> RequestResponse   <pre><code>POST /api/v0/streams\n</code></pre>","title":"Creating stream"},{"location":"build/http/api/#request-body-fields","text":"<ul> <li><code>type</code> - the type code of the StreamType to use (e.g. <code>0</code> for TileDocuments). Type codes for the supported stream types can be found in this table.</li> <li><code>genesis</code> - the genesis content of the stream (will differ per StreamType)</li> <li><code>opts</code> - options for the stream creation, CreateOpts (optional)</li> </ul>   <p>The response body contains the following fields:</p> <ul> <li><code>streamId</code> - the StreamID of the requested stream as string</li> <li><code>state</code> - the state of the requested stream as StreamState</li> </ul>","title":"Request body fields:"},{"location":"build/http/api/#example_1","text":"<p>This example creates a <code>TileDocument</code> from an unsigned genesis commit. Note that if the content is defined for a <code>TileDocument</code> genesis commit, it needs to be signed.</p> RequestResponse   <pre><code>curl http://localhost:7007/api/v0/streams -X POST -d '{\n    \"type\": 0,\n    \"genesis\": {\n      \"header\": {\n        \"family\": \"test\",\n        \"controllers\": [\"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\"]\n      }\n    }\n  }' -H \"Content-Type: application/json\"\n</code></pre>   <pre><code>{\n  \"streamId\": \"k2t6wyfsu4pg2qvoorchoj23e8hf3eiis4w7bucllxkmlk91sjgluuag5syphl\",\n  \"state\": {\n    \"type\": 0,\n    \"content\": {},\n    \"metadata\": {\n      \"family\": \"test\",\n      \"controllers\": [\n        \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\"\n      ]\n    },\n    \"signature\": 0,\n    \"anchorStatus\": \"PENDING\",\n    \"log\": [\n      {\n        \"cid\": \"bafyreihtdxfb6cpcvomm2c2elm3re2onqaix6frq4nbg45eaqszh5mifre\",\n        \"type\": 0\n      }\n    ],\n    \"anchorScheduledFor\": \"12/15/2020, 3:00:00 PM\"\n  }\n}\n</code></pre>","title":"Example"},{"location":"build/http/api/#multiqueries-api","text":"<p>The <code>multiqueries</code> endpoint enables querying multiple streams at once, as well as querying streams which are linked.</p>","title":"Multiqueries API"},{"location":"build/http/api/#querying-multiple-streams","text":"<p>This endpoint allows you to query multiple StreamIDs. Along with each StreamID an array of paths can be passed. If any of the paths within the stream structure contains a Ceramic StreamID url (<code>ceramic://&lt;StreamID&gt;</code>), this linked stream will also be returned as part of the response.</p> RequestResponse   <pre><code>POST /api/v0/multiqueries\n</code></pre>","title":"Querying multiple streams"},{"location":"build/http/api/#request-body-fields_1","text":"<ul> <li><code>queries</code> - an array of MultiQuery objects</li> </ul>   <p>The response body contains a map from StreamID strings to StreamState objects.</p>","title":"Request body fields:"},{"location":"build/http/api/#example_2","text":"<p>First let's create three streams to query using the ceramic cli:</p> Request1Response1Request2Response2Request3Response3   <pre><code>ceramic create tile --content '{ \"Document\": \"A\" }'\n</code></pre>   <pre><code>StreamID(kjzl6cwe1jw149rledowj0zi0icd7epi9y1m5tx4pardt1w6dzcxvr6bohi8ejc)\n{\n  \"Document\": \"A\"\n}\n</code></pre>   <pre><code>ceramic create tile --content '{ \"Document\": \"B\" }'\n</code></pre>   <pre><code>StreamID(kjzl6cwe1jw147w3xz3xrcd37chh2rz4dfra3imtnsni385rfyqa3hbx42qwal0)\n{\n  \"Document\": \"B\"\n}\n</code></pre>   <pre><code>ceramic create tile --content '{\n    \"Document\": \"C\",\n    \"link\": \"ceramic://kjzl6cwe1jw149rledowj0zi0icd7epi9y1m5tx4pardt1w6dzcxvr6bohi8ejc\"\n}'\n</code></pre>   <pre><code>StreamID(kjzl6cwe1jw14b54pb10voc4bqh73qyu8o6cfu66hoi3feidbbj81i5rohh7kgl)\n{\n  \"link\": \"ceramic://kjzl6cwe1jw149rledowj0zi0icd7epi9y1m5tx4pardt1w6dzcxvr6bohi8ejc\",\n  \"Document\": \"C\"\n}\n</code></pre>    <p>Now let's query them though the multiqueries endpoint:</p> RequestResponse   <pre><code>curl http://localhost:7007/api/v0/multiqueries -X POST -d '{\n  \"queries\": [{\n    \"streamId\": \"kjzl6cwe1jw14b54pb10voc4bqh73qyu8o6cfu66hoi3feidbbj81i5rohh7kgl\",\n    \"paths\": [\"link\"]\n  }, {\n    \"streamId\": \"kjzl6cwe1jw147w3xz3xrcd37chh2rz4dfra3imtnsni385rfyqa3hbx42qwal0\",\n    \"paths\": []\n  }]\n}' -H \"Content-Type: application/json\"\n</code></pre>   <pre><code>{\n  \"kjzl6cwe1jw14b54pb10voc4bqh73qyu8o6cfu66hoi3feidbbj81i5rohh7kgl\": {\n    \"type\": 0,\n    \"content\": {\n      \"link\": \"ceramic://kjzl6cwe1jw149rledowj0zi0icd7epi9y1m5tx4pardt1w6dzcxvr6bohi8ejc\",\n      \"Document\": \"C\"\n    },\n    \"metadata\": {\n      \"schema\": null,\n      \"controllers\": [\n        \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\"\n      ]\n    },\n    \"signature\": 2,\n    \"anchorStatus\": \"PENDING\",\n    \"log\": [\n      {\n        \"cid\": \"bagcqcera5nx45nccxvjjyxsq3so5po77kpqzbfsydy6yflnkt6p5tnjvhbkq\",\n        \"type\": 0\n      }\n    ],\n    \"anchorScheduledFor\": \"12/30/2020, 1:45:00 PM\"\n  },\n  \"kjzl6cwe1jw149rledowj0zi0icd7epi9y1m5tx4pardt1w6dzcxvr6bohi8ejc\": {\n    \"type\": 0,\n    \"content\": {\n      \"Document\": \"A\"\n    },\n    \"metadata\": {\n      \"schema\": null,\n      \"controllers\": [\n        \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\"\n      ]\n    },\n    \"signature\": 2,\n    \"anchorStatus\": \"PENDING\",\n    \"log\": [\n      {\n        \"cid\": \"bagcqcerawq5h7otlkdwuai7vhogqhs2aeaauwbu2aqclrh4iyu5h54qqogma\",\n        \"type\": 0\n      }\n    ],\n    \"anchorScheduledFor\": \"12/30/2020, 1:45:00 PM\"\n  },\n  \"kjzl6cwe1jw147w3xz3xrcd37chh2rz4dfra3imtnsni385rfyqa3hbx42qwal0\": {\n    \"type\": 0,\n    \"content\": {\n      \"Document\": \"B\"\n    },\n    \"metadata\": {\n      \"schema\": null,\n      \"controllers\": [\n        \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\"\n      ]\n    },\n    \"signature\": 2,\n    \"anchorStatus\": \"PENDING\",\n    \"log\": [\n      {\n        \"cid\": \"bagcqceranecdjzw4xheudgkr2amjkntpktci2xv44d7v4hbft3ndpptid6ka\",\n        \"type\": 0\n      }\n    ],\n    \"anchorScheduledFor\": \"12/30/2020, 1:45:00 PM\"\n  }\n}\n</code></pre>","title":"Example"},{"location":"build/http/api/#commits-api","text":"<p>The <code>commits</code> endpoint provides lower level access to the data structure of a Ceramic stream. It is also the enpoint that is used in order to update a stream, by adding a new commit.</p>","title":"Commits API"},{"location":"build/http/api/#getting-all-commits-in-a-stream","text":"<p>By calling GET on the commits endpoint along with a StreamID gives you access to all of the commits of the given stream. This is useful if you want to inspect the stream history, or apply all of the commits to a Ceramic node that is not connected to the network.</p> RequestResponse   <pre><code>GET /api/v0/commits/:streamid\n</code></pre> <p>Here, <code>:streamid</code> should be replaced by the string representation of the StreamID of the stream that is being requested.</p>   <ul> <li><code>streamId</code> - the StreamID of the requested stream, string</li> <li><code>commits</code> - an array of commit objects</li> </ul>","title":"Getting all commits in a stream"},{"location":"build/http/api/#example_3","text":"RequestResponse   <pre><code>curl http://localhost:7007/api/v0/commits/kjzl6cwe1jw14ahmwunhk9yjwawac12tb52j1uj3b9a57eohmhycec8778p3syv\n</code></pre>   <pre><code>{\n  \"streamId\": \"kjzl6cwe1jw14ahmwunhk9yjwawac12tb52j1uj3b9a57eohmhycec8778p3syv\",\n  \"commits\": [\n    {\n      \"cid\": \"bagcqcera2faj5vik2giftqxftbngfndkci7x4z5vp3psrf4flcptgkz5xztq\",\n      \"value\": {\n        \"jws\": {\n          \"payload\": \"AXESIAsUBpZMnue1yQ0BgXsjOFyN0cHq6AgspXnI7qGB54ux\",\n          \"signatures\": [\n            {\n              \"signature\": \"16tBnfkXQU0yo-RZvfjWhm7pP-hIxJ5m-FIMHlCrRkpjbleoEcaC80Xt7qs_WZOlOCexznjow9aX4aZe51cYCQ\",\n              \"protected\": \"eyJhbGciOiJFZERTQSIsImtpZCI6ImRpZDprZXk6ejZNa2ZaNlM0TlZWVEV1dHM4bzV4RnpSTVI4ZUM2WTFibmdvQlFOblhpQ3ZoSDhII3o2TWtmWjZTNE5WVlRFdXRzOG81eEZ6Uk1SOGVDNlkxYm5nb0JRTm5YaUN2aEg4SCJ9\"\n            }\n          ],\n          \"link\": \"bafyreialcqdjmte64624sdibqf5sgoc4rxi4d2xibawkk6oi52qydz4lwe\"\n        },\n        \"linkedBlock\": \"o2RkYXRhoWV0aXRsZXFNeSBmaXJzdCBEb2N1bWVudGZoZWFkZXKiZnNjaGVtYfZrY29udHJvbGxlcnOBeDhkaWQ6a2V5Ono2TWtmWjZTNE5WVlRFdXRzOG81eEZ6Uk1SOGVDNlkxYm5nb0JRTm5YaUN2aEg4SGZ1bmlxdWVwenh0b1A5blphdVgxcEE0OQ\"\n      }\n    },\n    {\n      \"cid\": \"bagcqcera3fkje7je4lvctkam4fvi675avtcuqgrv7dn6aoqljd5lebpl7rfq\",\n      \"value\": {\n        \"jws\": {\n          \"payload\": \"AXESINm6lI30m3j5H2ausx-ulXj-L9CmFlOTZBZvJ2O734Zt\",\n          \"signatures\": [\n            {\n              \"signature\": \"zsLJbBSU5xZTQkYlXwEH9xj_t_8frvSFCYs0SlVMPXOnw8zOJOsKnJDQlUOvPJxjt8Bdc_7xoBdmcRG1J1tpCw\",\n              \"protected\": \"eyJhbGciOiJFZERTQSIsImtpZCI6ImRpZDprZXk6ejZNa2ZaNlM0TlZWVEV1dHM4bzV4RnpSTVI4ZUM2WTFibmdvQlFOblhpQ3ZoSDhII3o2TWtmWjZTNE5WVlRFdXRzOG81eEZ6Uk1SOGVDNlkxYm5nb0JRTm5YaUN2aEg4SCJ9\"\n            }\n          ],\n          \"link\": \"bafyreigzxkki35e3pd4r6zvowmp25fly7yx5bjqwkojwiftpe5r3xx4gnu\"\n        },\n        \"linkedBlock\": \"pGJpZNgqWCYAAYUBEiDRQJ7VCtGQWcLlmFpitGoSP35ntX7fKJeFWJ8zKz2+Z2RkYXRhgaNib3BjYWRkZHBhdGhlL21vcmVldmFsdWUY6mRwcmV22CpYJgABhQESINFAntUK0ZBZwuWYWmK0ahI/fme1ft8ol4VYnzMrPb5nZmhlYWRlcqFrY29udHJvbGxlcnOA\"\n      }\n    }\n  ]\n}\n</code></pre>","title":"Example"},{"location":"build/http/api/#applying-a-new-commit-to-stream","text":"<p> Disabled in gateway mode</p> <p>In order to modify a stream we apply a commit to its log. This commit usually contains a signature over a json-patch diff describing a modification to the stream contents. The commit also needs to contain pointers to the previous commit and other metadata. You can read more about this in the Ceramic Specification. Different stream types may have different formats for their commits. If you want to see an example implementation for how to construct a commit you can have a look at the implementation of the TileDocument.</p> RequestResponse   <pre><code>POST /api/v0/commits\n</code></pre>","title":"Applying a new commit to stream"},{"location":"build/http/api/#request-body-fields_2","text":"<ul> <li><code>streamId</code> - the StreamID of the stream to apply the commit to, string</li> <li><code>commit</code> - the content of the commit to apply (will differ per streamtype)</li> <li><code>opts</code> - options for the stream update UpdateOpts (optional)</li> </ul>   <ul> <li><code>streamId</code> - the StreamID of the stream that was modified</li> <li><code>state</code> - the new state of the stream that was modified, StreamState</li> </ul>","title":"Request body fields:"},{"location":"build/http/api/#example_4","text":"RequestResponse   <pre><code>curl http://localhost:7007/api/v0/commits -X POST -d '{\n  \"streamId\": \"kjzl6cwe1jw14ahmwunhk9yjwawac12tb52j1uj3b9a57eohmhycec8778p3syv\",\n  \"commit\": {\n    \"jws\": {\n      \"payload\": \"AXESINm6lI30m3j5H2ausx-ulXj-L9CmFlOTZBZvJ2O734Zt\",\n      \"signatures\": [\n        {\n          \"signature\": \"zsLJbBSU5xZTQkYlXwEH9xj_t_8frvSFCYs0SlVMPXOnw8zOJOsKnJDQlUOvPJxjt8Bdc_7xoBdmcRG1J1tpCw\",\n          \"protected\": \"eyJhbGciOiJFZERTQSIsImtpZCI6ImRpZDprZXk6ejZNa2ZaNlM0TlZWVEV1dHM4bzV4RnpSTVI4ZUM2WTFibmdvQlFOblhpQ3ZoSDhII3o2TWtmWjZTNE5WVlRFdXRzOG81eEZ6Uk1SOGVDNlkxYm5nb0JRTm5YaUN2aEg4SCJ9\"\n        }\n      ],\n      \"link\": \"bafyreigzxkki35e3pd4r6zvowmp25fly7yx5bjqwkojwiftpe5r3xx4gnu\"\n    },\n    \"linkedBlock\": \"pGJpZNgqWCYAAYUBEiDRQJ7VCtGQWcLlmFpitGoSP35ntX7fKJeFWJ8zKz2+Z2RkYXRhgaNib3BjYWRkZHBhdGhlL21vcmVldmFsdWUY6mRwcmV22CpYJgABhQESINFAntUK0ZBZwuWYWmK0ahI/fme1ft8ol4VYnzMrPb5nZmhlYWRlcqFrY29udHJvbGxlcnOA\"\n  }\n}' -H \"Content-Type: application/json\"\n</code></pre>   <pre><code>{\n  \"streamId\": \"kjzl6cwe1jw14ahmwunhk9yjwawac12tb52j1uj3b9a57eohmhycec8778p3syv\",\n  \"state\": {\n    \"type\": 0,\n    \"content\": {\n      \"title\": \"My first Document\"\n    },\n    \"metadata\": {\n      \"schema\": null,\n      \"controllers\": [\n        \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\"\n      ]\n    },\n    \"signature\": 2,\n    \"anchorStatus\": \"PENDING\",\n    \"log\": [\n      {\n        \"cid\": \"bagcqcera2faj5vik2giftqxftbngfndkci7x4z5vp3psrf4flcptgkz5xztq\",\n        \"type\": 0\n      },\n      {\n        \"cid\": \"bagcqcera3fkje7je4lvctkam4fvi675avtcuqgrv7dn6aoqljd5lebpl7rfq\",\n        \"type\": 1\n      }\n    ],\n    \"anchorScheduledFor\": \"12/30/2020, 1:15:00 PM\",\n    \"next\": {\n      \"content\": {\n        \"title\": \"My first Document\",\n        \"more\": 234\n      },\n      \"metadata\": {\n        \"schema\": null,\n        \"controllers\": []\n      }\n    }\n  }\n}\n</code></pre>","title":"Example"},{"location":"build/http/api/#pins-api","text":"<p>The <code>pins</code> api endpoint can be used to manipulate the pinset. The pinset is all of the streams that a node maintains the state of. Any stream opened by the node that is not pinned will eventually be garbage collected from the node.</p>","title":"Pins API"},{"location":"build/http/api/#adding-to-pinset","text":"<p> Disabled in gateway mode</p> <p>This method adds the stream with the given StreamID to the pinset.</p> RequestResponse   <pre><code>POST /api/v0/pins/:streamid\n</code></pre> <p>Here, <code>:streamid</code> should be replaced by the string representation of the StreamID of the stream that is being requested.</p>   <p>If the operation was sucessful the response will be a 200 OK.</p> <ul> <li><code>streamId</code> - the StreamID of the stream which was pinned, string</li> </ul>","title":"Adding to pinset"},{"location":"build/http/api/#example_5","text":"RequestResponse   <pre><code>curl http://localhost:7007/api/v0/pins/k2t6wyfsu4pg2qvoorchoj23e8hf3eiis4w7bucllxkmlk91sjgluuag5syphl -X POST\n</code></pre>   <pre><code>{\n  \"streamId\": \"k2t6wyfsu4pg2qvoorchoj23e8hf3eiis4w7bucllxkmlk91sjgluuag5syphl\"\n}\n</code></pre>","title":"Example"},{"location":"build/http/api/#removing-from-pinset","text":"<p> Disabled in gateway mode</p> <p>This method removes the stream with the given StreamID from the pinset.</p> RequestResponse   <pre><code>DELETE /api/v0/pins/:streamid\n</code></pre> <p>Here, <code>:streamid</code> should be replaced by the string representation of the StreamID of the stream that is being requested.</p>   <p>If the operation was sucessful the response will be a 200 OK.</p> <ul> <li><code>streamId</code> - the StreamID of the stream which was unpinned, string</li> </ul>","title":"Removing from pinset"},{"location":"build/http/api/#example_6","text":"RequestResponse   <pre><code>curl http://localhost:7007/api/v0/pins/k2t6wyfsu4pg2qvoorchoj23e8hf3eiis4w7bucllxkmlk91sjgluuag5syphl -X DELETE\n</code></pre>   <pre><code>{\n  \"streamId\": \"k2t6wyfsu4pg2qvoorchoj23e8hf3eiis4w7bucllxkmlk91sjgluuag5syphl\"\n}\n</code></pre>","title":"Example"},{"location":"build/http/api/#listing-streams-in-pinset","text":"<p>Calling this method allows you to list all of the streams that are in the pinset on this node.</p> RequestResponse   <pre><code>GET /api/v0/pins\n</code></pre>   <ul> <li><code>pinnedStreamIds</code> - an array of StreamID strings that are in the pinset</li> </ul>","title":"Listing streams in pinset"},{"location":"build/http/api/#example_7","text":"RequestResponse   <pre><code>curl http://localhost:7007/api/v0/pins\n</code></pre>   <pre><code>{\n  \"pinnedStreamIds\": [\n    \"k2t6wyfsu4pfwqaju0w9nmi53zo6f5bcier7vc951x4b9rydv6t8q4pvzd5w3l\",\n    \"k2t6wyfsu4pfxon8reod8xcyka9bujeg7acpz8hgh0jsyc7p2b334izdyzsdp7\",\n    \"k2t6wyfsu4pfxqseec01fnqywmn8l93p4g2chzyx3sod3hpyovurye9hskcegs\",\n    \"k2t6wyfsu4pfya9y0ega1vnokf0g5qaus69basy52oxg50y3l35vm9rqbb88t3\"\n  ]\n}\n</code></pre>","title":"Example"},{"location":"build/http/api/#checking-inclusion-in-pinset","text":"<p>This method is used to check if a particular stream is in the pinset.</p> RequestResponse   <pre><code>GET /api/v0/pins/:streamid\n</code></pre> <p>Here, <code>:streamid</code> should be replaced by the string representation of the StreamID of the stream that is being requested.</p>   <ul> <li><code>pinnedStreamIds</code> - an array containing the specified StreamID string if that stream is pinned, or an empty array if that stream is not pinned</li> </ul>","title":"Checking inclusion in pinset"},{"location":"build/http/api/#example_8","text":"RequestResponse   <pre><code>curl http://localhost:7007/api/v0/pins/k2t6wyfsu4pg2qvoorchoj23e8hf3eiis4w7bucllxkmlk91sjgluuag5syphl\n</code></pre>   <pre><code>{\n  \"pinnedStreamIds\": [\"k2t6wyfsu4pg2qvoorchoj23e8hf3eiis4w7bucllxkmlk91sjgluuag5syphl\"]\n}\n</code></pre>","title":"Example"},{"location":"build/http/api/#node-info-apis","text":"<p>The methods under the <code>/node</code> path provides more information about this particular node.</p>","title":"Node Info APIs"},{"location":"build/http/api/#supported-blockchains-for-anchoring","text":"<p>Get all of the CAIP-2 chainIds supported by this node.</p> RequestResponse   <pre><code>GET /api/v0/node/chains\n</code></pre>   <p>The response body contains the following fields:</p> <ul> <li><code>supportedChains</code> - and array with CAIP-2 formatted chainIds</li> </ul>","title":"Supported blockchains for anchoring"},{"location":"build/http/api/#example_9","text":"RequestResponse   <pre><code>curl http://localhost:7007/api/v0/node/chains\n</code></pre>   <pre><code>{\n  \"supportedChains\": [\"eip155:3\"]\n}\n</code></pre>","title":"Example"},{"location":"build/http/api/#health-check","text":"<p>Check the health of the node and the machine it's running on. Run <code>ceramic daemon -h</code> for more details on how this can be configured.</p> RequestResponse   <pre><code>GET /api/v0/node/healthcheck\n</code></pre>   <p>Either a <code>200</code> response with the text <code>Alive!</code>, or a <code>503</code> with the text <code>Insufficient resources</code>.</p>","title":"Health check"},{"location":"build/http/api/#example_10","text":"RequestResponse   <pre><code>curl http://localhost:7007/api/v0/node/healthcheck\n</code></pre>   <pre><code>Alive!\n</code></pre>","title":"Example"},{"location":"build/javascript/authentication/","text":"<p>This guide will help you set up authentication so your users can perform writes. Authentication is not needed if you are only querying streams.</p>","title":"Authentication"},{"location":"build/javascript/authentication/#requirements","text":"<p>Authentication requires having installed a Ceramic client. Your client should include the DID Resolver(s) for the DID method(s) you will use for authentication.</p>","title":"Requirements"},{"location":"build/javascript/authentication/#1-choose-a-did-method","text":"<p>The first step in adding authentication to your project is choosing which DID method to use for authentication.</p> <p>3ID DID Method: A powerful DID method that supports multiple keys, key rotations, and revocations</p> <p>Key DID Method: A lightweight DID method that only supports one key and cannot handle rotations</p> <p>NFT DID Method: A lightweight DID method with permissions that change based on on-chain NFT asset ownership</p> <p>Safe DID Method coming soon: A lightweight DID method with permissions that change based on on-chain Gnosis Safe contract permissions</p>  <p>It is recommended that most applications use the 3ID DID Method.</p>","title":"1. Choose a DID method"},{"location":"build/javascript/authentication/#2-install-a-did-provider","text":"<p>After choosing a DID method, install a DID provider for that method.</p>","title":"2. Install a DID Provider"},{"location":"build/javascript/authentication/#3id-did-providers","text":"","title":"3ID DID Providers"},{"location":"build/javascript/authentication/#3id-connect","text":"<p>3ID Connect is the most popular 3ID DID Provider for Ceramic web apps. The 3ID Connect SDK allows users to authenticate a 3ID DID using their existing blockchain wallets without needing to install any additional software. Developers do not need to worry about DID key management for their users.</p> <p> Installation</p>  <p>Recommended for most browser applications.</p>","title":"3ID Connect"},{"location":"build/javascript/authentication/#3id-did-provider","text":"<p>3ID DID Provider is a low-level JavaScript 3ID DID Provider. Your application is responsible for key management, and users need to authenticate with a DID seed or an auth secret.</p> <p> Installation</p>","title":"3ID DID Provider"},{"location":"build/javascript/authentication/#key-did-providers","text":"","title":"Key DID Providers"},{"location":"build/javascript/authentication/#key-did-provider-ed25519","text":"<p>Key DID Provider Ed25519 is a low-level JavaScript Key DID Provider for use with <code>Ed25519</code> key pairs. Your application is responsible for key managemet, and users need to authenticate with a DID seed.</p> <p> Installation</p>","title":"Key DID Provider Ed25519"},{"location":"build/javascript/core/","text":"<p>This guide describes how to install the JS Core Client in your JavaScript project.</p>","title":"Installing the JS Core Client"},{"location":"build/javascript/core/#requirements","text":"<p>Installing the JS Core Client requires a console, Node.js v14, and npm v6. Make sure to have these installed on your machine.</p>  <p>While npm v7 is not officially supported, you may still be able to get it to work. Try installing the <code>node-pre-gyp</code> package globally. This is required until <code>node-webrtc</code>, which IPFS depends on, is upgraded.</p> <pre><code>npm install -g node-pre-gyp\n</code></pre>","title":"Requirements"},{"location":"build/javascript/core/#1-install-the-core-client","text":"<p>Open your console and install the JS Core Client using npm.</p> <pre><code>npm install @ceramicnetwork/core\n</code></pre>","title":"1. Install the Core client"},{"location":"build/javascript/core/#2-import-the-core-client","text":"<pre><code>import Ceramic from '@ceramicnetwork/core'\n</code></pre>","title":"2. Import the Core client"},{"location":"build/javascript/core/#3-import-ipfs-with-dag-jose","text":"<p>Ceramic utilizes the dag-jose IPLD codec to format and store data in IPFS.</p> <pre><code>import Ipfs from 'ipfs-core'\nimport dagJose from 'dag-jose'\nimport { convert } from 'blockcodec-to-ipld-format'\n\nconst dagJoseFormat = convert(dagJose)\n</code></pre>","title":"3. Import IPFS with dag-jose"},{"location":"build/javascript/core/#4-create-an-ipfs-instance","text":"<p>Create an instance of <code>js-ipfs</code> with <code>dag-jose</code> enabled.</p> <pre><code>const ipfs = await Ipfs.create({ ipld: { formats: [dagJoseFormat] } })\n</code></pre>","title":"4. Create an IPFS instance"},{"location":"build/javascript/core/#5-create-a-ceramic-instance","text":"<p>Create an instance of Ceramic by passing ipfs and an optional configuration object.</p> <pre><code>const ceramic = await Ceramic.create(ipfs, config)\n</code></pre>","title":"5. Create a Ceramic instance"},{"location":"build/javascript/core/#6-import-did-resolvers","text":"<p>Import resolvers for all DID methods that this Core Client will support. This should be inclusive of the DID Method that you will use for authentication, but should also include all other DID Methods for which your node could possibly need to verify signatures. Therefore, it is recommended that all Core Clients be able to resolve at least the <code>did:3</code> and <code>did:key</code> DID methods.</p> <pre><code>import KeyDidResolver from 'key-did-resolver'\nimport ThreeIdResolver from '@ceramicnetwork/3id-did-resolver'\n</code></pre>","title":"6. Import DID resolvers"},{"location":"build/javascript/core/#7-create-a-did-instance","text":"<p>Create a DID instance which wraps an instance of a DID resolver that includes all individual DID resolvers from the previous step. Optionally, it also includes a DID Provider if you intend to authenticate DIDs to allow writes to the network during runtime.</p> <pre><code>import { DID } from 'dids'\nconst resolver = {\n  ...KeyDidResolver.getResolver(),\n  ...ThreeIdResolver.getResolver(ceramic),\n}\nconst did = new DID({ resolver })\n</code></pre>","title":"7. Create a DID instance"},{"location":"build/javascript/core/#8-set-did-instance-on-core-client","text":"<pre><code>ceramic.did = did\n</code></pre>","title":"8. Set DID instance on Core client"},{"location":"build/javascript/core/#example","text":"<p>Once you have completed installing and configuring the Core Client, your project's setup should look something like this.</p> <pre><code>import Ceramic from '@ceramicnetwork/core'\nimport IPFS from 'ipfs-core'\nimport dagJose from 'dag-jose'\nimport { convert } from 'blockcodec-to-ipld-format'\nimport KeyDidResolver from 'key-did-resolver'\nimport ThreeIdResolver from '@ceramicnetwork/3id-did-resolver'\nimport { DID } from 'dids'\nconst dagJoseFormat = convert(dagJose)\nconst ipfs = await Ipfs.create({ ipld: { formats: [dagJoseFormat] } })\nconst resolver = { ...KeyDidResolver.getResolver(),\n                   ...ThreeIdResolver.getResolver(ceramic) }\nconst did = new DID({ resolver })\nceramic.did = did\n</code></pre>","title":"Example"},{"location":"build/javascript/core/#next-steps","text":"<p>After setting the DID instance on the Core client, your application will now be able to perform queries. If you need to perform writes, proceed to setting up authentication.</p>","title":"Next steps"},{"location":"build/javascript/http/","text":"<p>This guide descibes how to install the JS HTTP Client so your JavaScript application can perform writes, queries, or pins on a remote Ceramic node during runtime.</p>","title":"Installing the JS HTTP Client"},{"location":"build/javascript/http/#requirements","text":"<p>Installing the JS HTTP Client requires a console, Node.js v14, and npm v6. Make sure to have these installed on your machine.</p>  <p>While npm v7 is not officially supported, you may still be able to get it to work. However you will need to install the <code>node-pre-gyp</code> package globally. This is required until <code>node-webrtc</code>, which IPFS depends on, is upgraded.</p> <pre><code>npm install -g node-pre-gyp\n</code></pre>","title":"Requirements"},{"location":"build/javascript/http/#1-install-the-http-client","text":"<p>Open your console and install the JS HTTP Client using npm.</p> <pre><code>npm install @ceramicnetwork/http-client\n</code></pre>","title":"1. Install the HTTP client"},{"location":"build/javascript/http/#2-import-the-http-client","text":"<pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\n</code></pre>","title":"2. Import the HTTP client"},{"location":"build/javascript/http/#3-configure-your-node-url","text":"<pre><code>const API_URL = 'https://yourceramicnode.com'\n</code></pre> <p>Available options for your node setup:</p> <ul> <li>Free community nodes: Discover free HTTP endpoints</li> <li>Commercial node providers: Discover paid node providers</li> <li>Host your own node: Learn how to setup and host your own node</li> <li>localhost: You may want to use the JS HTTP Client with a Ceramic node running on your local machine for development and testing. To achieve this, first start a local daemon by installing the CLI. Once the CLI is installed, you can pass <code>https://localhost:7007</code> to the HTTP client. This setup will allow you to read streams from other nodes connected on the Ceramic network, but writes to your local node will only be available on nodes found on the <code>peerlist</code>. For now, these streams will not be available to other nodes on the network due to a limitation in <code>js-ipfs</code> which will be fixed in the future.</li> </ul>","title":"3. Configure your node URL"},{"location":"build/javascript/http/#4-create-a-ceramic-instance","text":"<pre><code>const ceramic = new CeramicClient(API_URL)\n</code></pre>","title":"4. Create a Ceramic instance"},{"location":"build/javascript/http/#5-import-did-resolvers","text":"<p>Import the DID resolvers for all DID methods that will need to authenticate to perform writes using this HTTP Client. If your HTTP Client will only perform queries, then jump ahead to the queries page.</p> <pre><code>import KeyDidResolver from 'key-did-resolver'\nimport ThreeIdResolver from '@ceramicnetwork/3id-did-resolver'\n</code></pre>","title":"5. Import DID resolvers"},{"location":"build/javascript/http/#6-create-a-did-instance","text":"<p>Create a DID instance which wraps an instance of a DID resolver that includes all individual DID resolvers from the previous step. It should also include a DID Provider for the DID Method you are using for authentication.</p> <pre><code>import { DID } from 'dids'\nconst resolver = {\n  ...KeyDidResolver.getResolver(),\n  ...ThreeIdResolver.getResolver(ceramic),\n}\nconst did = new DID({ resolver })\n</code></pre>","title":"6. Create a DID instance"},{"location":"build/javascript/http/#7-set-did-instance-on-http-client","text":"<pre><code>ceramic.did = did\n</code></pre>","title":"7. Set DID instance on HTTP client"},{"location":"build/javascript/http/#examples","text":"<p>Once you have completed installing and configuring the HTTP Client, your project's setup should look something like this.</p>","title":"Examples"},{"location":"build/javascript/http/#write-and-read","text":"<pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport KeyDidResolver from 'key-did-resolver'\nimport ThreeIdResolver from '@ceramicnetwork/3id-did-resolver'\nimport { DID } from 'dids'\nconst API_URL = 'https://yourceramicnode.com'\nconst ceramic = new CeramicClient(API_URL)\nconst resolver = {\n  ...KeyDidResolver.getResolver(),\n  ...ThreeIdResolver.getResolver(ceramic),\n}\nconst did = new DID({ resolver })\nceramic.did = did\n</code></pre>","title":"Write and read"},{"location":"build/javascript/http/#read-only","text":"<pre><code>import CeramicClient from '@ceramicnetwork/http-client'\nconst API_URL = 'https://yourceramicnode.com'\nconst ceramic = new CeramicClient(API_URL)\n</code></pre>","title":"Read-only"},{"location":"build/javascript/http/#next-steps","text":"<p>If your application needs to perform writes, proceed to setting up authentication. If your app only needs to perform queries, then jump ahead to queries.</p>","title":"Next steps"},{"location":"build/javascript/installation/","text":"<p>This page describes the Ceramic clients available to use in your JavaScript project. After choosing either the JS HTTP Client or the JS Core Client, follow its installation instructions.  </p>","title":"Choose a JS client"},{"location":"build/javascript/installation/#js-http-client","text":"<p>The JS HTTP Client is a lightweight way of interacting with Ceramic. It allows your JavaScript application to connect to a remote Ceramic node over HTTP to read, write, and pin streams. The main decision to make when using the JS HTTP Client is which remote Ceramic node to use.</p> <p> Installation</p>  <p>The JS HTTP client is recommended when building most applications.</p>","title":"JS HTTP Client"},{"location":"build/javascript/installation/#considerations","text":"<p>Improved performance: When using the JS HTTP Client, stream processing and validation happens on a remote Ceramic node running on a server, which usually results in improved performance compared to running the full protocol in-browser with the JS Core Client.</p> <p>Predictable data availability: Streams created using the JS HTTP Client can be pinned and made available on a remote Ceramic node which has more uptime and predictable data availability guarantees than, say, running the JS Core Client directly in-browser where users can open and close tabs causing their streams to come on and offline at unpredictable intervals.</p> <p>Some trust in a remote node: Stream processing and state validation happens on a remote node which the JS HTTP Client trusts. However, it is important to note that user's keys always live client-side and all updates are signed on the JS HTTP Client and then sent to the HTTP endpoint for processing.</p> <p>Swap for the JS Core Client at anytime: The JS HTTP Client and the JS Core Client implement the same CeramicApi TypeScript interface, so swapping between clients is seamless and doesn't require changing your application logic; it only requires changing your setup.</p>","title":"Considerations"},{"location":"build/javascript/installation/#js-core-client","text":"<p>The JS Core Client allows you to run the full Ceramic protocol (client and node) directly in any JavaScript environment, such as in your tests, in fully client-side browser applications, or in node.js. Most applications instead use the JS HTTP Client.</p> <p> Installation</p>","title":"JS Core Client"},{"location":"build/javascript/installation/#considerations_1","text":"<p>Maximal security and decentralization: The Ceramic Core client does not have trusted relationships with any external nodes. With Ceramic Core, streams that are written, queried, or pinned are verified in the local environment which is great if you need maximal security and decentralization in your application.</p> <p>Transitory data availability: Streams created with Ceramic Core will only be available on the network as long as this node remains online. For example for setups that use the Core Client directly in-browser, when your user closes the tab any stream created by that user will become unavailable on the network until the user opens the application again. For more resilient data availability you can always replicate and pin streams on secondary long-running nodes, or instead use the JS HTTP Client which relies on a remote node more likely to always be online.</p> <p>Setup complexity: You will need to configure an IPFS node which supports the dag-jose data format and ensure connectivity to the rest of the Ceramic network.</p> <p>Swap for JS HTTP Client at any time: The JS Core Client and the JS HTTP Client implement the same CeramicApi TypeScript interface, so swapping between clients is seamless and doesn't require changing your application logic; it only requires changing your setup.</p>","title":"Considerations"},{"location":"build/javascript/pinning/","text":"<p>Pinning allows you to persist and make streams available on a Ceramic node beyond a single session. This guide demonstrates how to add and remove streams from your node's pinset, and how to list the streams currently in the pinset. In order to interact with a pinset, you must have installed a Ceramic client.</p>","title":"Pinning"},{"location":"build/javascript/pinning/#overview","text":"<p>By default Ceramic will garbage collect any stream that has been written or queried on your node after some period of time. In order to prevent the loss of streams due to garbage collection, you need to explicitly pin the streams that you wish to persist. Pinning instructs the node to keep them around in persistent storage until they are explicitly unpinned. To learn more about Ceramic's data persistence and availability model, see Data Availability.</p>","title":"Overview"},{"location":"build/javascript/pinning/#pin-a-stream-while-creating-it","text":"<p>Most StreamTypes will allow you to request that a Stream be pinned at the same time that you create the Stream. An example using the TileDocument Streamtype is below:</p> <p><pre><code>await TileDocument.create(ceramic, content, null, { pin: true })\n</code></pre>  API reference</p>","title":"Pin a stream while creating it"},{"location":"build/javascript/pinning/#add-to-pinset","text":"<p>Use the <code>pin.add()</code> method to add an existing stream to your permanent pinset.</p> <pre><code>const streamId = 'kjzl6cwe1jw14...'\nawait ceramic.pin.add(streamId)\n</code></pre> <p> API reference</p>","title":"Add to pinset"},{"location":"build/javascript/pinning/#remove-from-pinset","text":"<p>Use the <code>pin.rm()</code> method to remove a stream from your permanent pinset.</p> <pre><code>const streamId = 'kjzl6cwe1jw14...'\nawait ceramic.pin.rm(streamId)\n</code></pre> <p> API reference</p>","title":"Remove from pinset"},{"location":"build/javascript/pinning/#list-streams-in-pinset","text":"<p>Use the <code>pin.ls()</code> method to list streams currently in your permanent pinset.</p> <pre><code>const streamIds = await ceramic.pin.ls()\n</code></pre> <p> API reference</p>","title":"List streams in pinset"},{"location":"build/javascript/queries/","text":"<p>This guide demonstrates how to query streams during runtime using the JS HTTP and JS Core clients.</p>","title":"Queries"},{"location":"build/javascript/queries/#requirements","text":"<p>You need to have an installed client to perform queries during runtime.</p>","title":"Requirements"},{"location":"build/javascript/queries/#query-a-stream","text":"<p>Use the <code>loadStream()</code> method to load a single stream using its StreamID.</p> <pre><code>const streamId = 'kjzl6cwe1jw14...'\nconst stream = await ceramic.loadStream(streamId)\n</code></pre>  <p>Loading the proper stream type</p> <p>When using the Typescript APIs, <code>loadStream</code> by default returns an object of type <code>Stream</code>, which will not have any methods available to perform updates, or any other streamtype-specific methods or accessors.  To be able to perform updates, as well as to access streamtype-specific data or functionality, you need to specialize the <code>loadStream</code> method on the StreamType of the Stream being loaded. For example, to load a <code>TileDocument</code>, you would say <code>await ceramic.loadStream&lt;TileDocument&gt;(streamId)</code></p>  <p> API reference</p>","title":"Query a stream"},{"location":"build/javascript/queries/#query-a-stream-at-a-specific-commit","text":"<p>If you want to see the contents of a stream as of a specific point in time, it's possible to pass a CommitID instead of a StreamID to the <code>loadStream()</code> method described above. This will cause the Stream to be loaded at the specified commit, rather than the current commit as loaded from the network. When loading with a CommitID, the returned Stream object will be marked as readonly and cannot be used to perform updates. If you wish to perform updates, load a new instance of the Stream using its StreamID.</p>","title":"Query a stream at a specific commit"},{"location":"build/javascript/queries/#query-multiple-streams","text":"<p>Use the <code>multiQuery()</code> method to load multiple streams at once. The returned object is a map from StreamIDs to stream instances.</p> <pre><code>const queries = [\n  {\n    streamId: 'kjzl6cwe1jw...14',\n  },\n  {\n    streamId: 'kjzl6cwe1jw...15',\n  },\n]\nconst streamMap = await ceramic.multiQuery(queries)\n</code></pre> <p> API reference</p>","title":"Query multiple streams"},{"location":"build/javascript/queries/#query-a-stream-using-paths","text":"<p>Use the <code>multiQuery()</code> method to load one or more streams using known paths from a root stream to its linked streams.</p> <p>Imagine a stream <code>kjzl6cwe1jw...14</code> whose content contains the StreamIDs of two other streams. These StreamIDs exist at various levels within a nested JSON structure.</p> <pre><code>{\n  a: 'kjzl6cwe1jw...15',\n  b: {\n    c: 'kjzl6cwe1jw...16'\n  }\n}\n</code></pre> <p>In the stream above, the path from root stream <code>kjzl6cwe1jw...14</code> to linked stream <code>kjzl6cwe1jw...15</code> is <code>/a</code> and the path to linked stream <code>kjzl6cwe1jw...16</code> is <code>/b/c</code>. Using the StreamID of the root stream and the paths outlined here, we use <code>multiQuery()</code> to query all three streams at once without needing to explicitly know the StreamIDs of the two linked streams.</p> <p>The <code>multiQuery()</code> below will return a map with all three streams.</p> <pre><code>const queries = [{\n  streamId: 'kjzl6cwe1jw...14'\n  paths: ['/a', '/b/c']\n}]\nconst streamMap = await ceramic.multiQuery(queries)\n</code></pre> <p> API reference</p>","title":"Query a stream using paths"},{"location":"build/javascript/queries/#helper-methods","text":"<p>To get specific information about the stream that you created or loaded you can use the accessors on the <code>Stream</code> class. Below are some examples.</p> <p> API reference</p>","title":"Helper methods"},{"location":"build/javascript/queries/#get-streamid","text":"<p>Use the <code>stream.id</code> property to get the unique <code>StreamID</code> for this stream.</p> <pre><code>const streamId = stream.id\n</code></pre> <p> API reference</p>","title":"Get StreamID"},{"location":"build/javascript/queries/#get-latest-commit","text":"<p>Use the <code>stream.commitId</code> property to get latest CommitID of a stream.</p> <pre><code>const commitId = stream.commitId\n</code></pre> <p> API reference</p>","title":"Get latest commit"},{"location":"build/javascript/queries/#get-all-anchor-commits","text":"<p>Use the <code>stream.anchorCommitIds</code> property to get all CommitIDs which are anchor commits for this stream.</p> <pre><code>const anchorCommits = stream.anchorCommitIds\n</code></pre> <p> API reference</p>","title":"Get all anchor commits"},{"location":"build/javascript/quick-start/","text":"<p>Learn the basics by setting up and interacting with the Ceramic Javascript Client.</p>  <p>Want an even faster way to try Ceramic? Visit the Playground Demo App to test the full stack of Ceramic components in the browser.</p>","title":"Quickstart"},{"location":"build/javascript/quick-start/#1-install-the-client","text":"<p>Authentication</p>  <p> If you're using this quickstart anywhere but the Ceramic Playground you'll need to authenticate your Ceramic instance. This is a process that's dependent on your setup so we recommend taking a look at our authentication section to ensure you don't have any issues following along.</p> <p>Visit the Ceramic Client page for instructions on how to quickly install the Client.</p>","title":"1. Install the Client"},{"location":"build/javascript/quick-start/#2-create-a-stream","text":"<p>Creating streams is dependent on the StreamType. More details can be found in our StreamTypes Overview. A basic sample using the TileDocument StreamType can be found below.</p> CommandOutput   <pre><code>import { TileDocument } from '@ceramicnetwork/stream-tile'\n\nconst doc = await TileDocument.create(ceramic, {hello: 'world'})\n\nconsole.log(doc.content)\n\nconst streamId = doc.id.toString()\n</code></pre>   <pre><code>{\n  hello: 'world'\n}\n</code></pre>","title":"2. Create a stream"},{"location":"build/javascript/quick-start/#3-query-a-stream","text":"<p>Use the <code>load()</code> function to query the current state of a stream. You will need to provide it's StreamID.</p> CommandOutput   <pre><code>const streamId = \"kjzl...g8qa\"\nconst doc = await TileDocument.load(ceramic, streamId)\n\nconsole.log(doc.content)\n</code></pre>   <pre><code>\n</code></pre>","title":"3. Query a stream"},{"location":"build/javascript/quick-start/#4-update-a-stream","text":"<p>Use the <code>update</code> command to update a stream. your DID must be in the controller of the stream in order to update it.</p> Command   <pre><code>const streamId = \"kjzl...g8qa\"\nconst doc = await TileDocument.load(ceramic, streamId)\n\nawait doc.update(newContent, newMeta)\n</code></pre>    <p>In the following example we update a TileDocuments' content while also giving it a tag.</p> Command   <pre><code>const streamId = \"kjzl...g8qa\"\nconst doc = await TileDocument.load(ceramic, streamId)\n\nawait doc.update({foo: 'baz'}, {tags: ['baz']})\n</code></pre>","title":"4. Update a stream"},{"location":"build/javascript/quick-start/#5-create-a-schema","text":"<p>TileDocuments can enforce that their contents adhere to a specified schema. The schemas themselves are TileDocuments where the content is a json-schema. For example we can create a schema that requires a TileDocument to have a title and a message.</p> Command   <pre><code>const schema = {\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Reward\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"title\": { \"type\": \"string\" },\n    \"message\": { \"type\": \"string\" }\n  },\n  \"required\": [\n    \"message\",\n    \"title\"\n  ]\n}\nconst metadata = {\n  controllers: [ceramic.did.id] // this will set yourself as the controller of the schema\n}\nconst rewardSchema = await TileDocument.create(ceramic, schema, metadata)\n</code></pre>","title":"5. Create a schema"},{"location":"build/javascript/quick-start/#6-create-a-tiledocument-stream-that-uses-a-schema","text":"<p>First, use the <code>rewardSchema.commitId.toString()</code> to get the current CommitID of the schema stream. When creating a TileDocument that uses this schema you need to use a CommitID instead of the StreamID. This is to enforce that we are using a specific version of the schema since the schema stream is mutable and can be updated.</p> Command   <pre><code>  const reward = await TileDocument.create(ceramic, {\n    title: 'Hello',\n    message: 'world!'\n  }, {\n    controllers: [ceramic.did.id],\n    family: 'Rewards',\n    schema: rewardSchema.commitId.toString(),\n  })\n</code></pre>","title":"6. Create a TileDocument stream that uses a schema"},{"location":"build/javascript/quick-start/#7-inspect-the-state-of-the-stream-you-created","text":"<p>Use <code>reward.state</code> to query the state of the TileDocument we just created. We can see that the schema is set to the correct CommitID.</p> CommandOutput   <pre><code>  console.log(reward.state)\n</code></pre>   <pre><code>{\n  anchorStatus: 1,\n  content: {\n    message: \"world!\",\n    title: \"Hello\"\n  },\n  metadata:{\n    controllers: [\n      \"did:3:kjzl...mr5y\",\n    ]\n    family: \"Rewards\"\n    schema: \"k3y5...50jk\"\n    unique: \"/mNCNLFt+1a0nqgL\"\n  }\n}\n</code></pre>","title":"7. Inspect the state of the stream you created"},{"location":"build/javascript/quick-start/#thats-it","text":"<p>Congratulations on completing this tutorial! You're well on your way to becoming a Ceramic developer. Now let's install Ceramic in your project or take a look at Self.ID, a framework for interacting with Streams.</p>","title":"That's it!"},{"location":"build/javascript/writes/","text":"<p>Writes are interactions that write to streams, such as creating new streams or updating existing streams. You need an installed client and an authenticated user to perform writes.</p>","title":"Writes"},{"location":"build/javascript/writes/#usage","text":"<p>Write operations are StreamType specific. The APIs for performing writes are contained within the various Stream implementations. See StreamTypes for information on how to perform writes for each of the supported StreamTypes.</p>","title":"Usage"},{"location":"build/middleware/","text":"<p>Middleware is a generic name for all kinds of development tools that are not a part of the core Ceramic clients, but provide developers with additional functionality and convenience. Middleware requires separately installing a Ceramic client, so they are lower-level than frameworks.</p>","title":"Middleware"},{"location":"build/middleware/#available-middleware","text":"","title":"Available middleware"},{"location":"build/middleware/#glaze-suite","text":"<p>Glaze suite includes a collection of data model management tools, runtime tools for account-based storage and retrieval, and client-side tools for caching data from the network.</p>","title":"Glaze suite \u2192"},{"location":"docs/advanced/indexing/","text":"<pre><code>- Indexes:\n  - Indexing Patterns: index.md\n  - Indexing Strategies: index.md\n  - Account-centric indexing:\n  - Application-Centric Indexing: index.md\n  - Network-Wide Indexing: index.md\n</code></pre>","title":"Indexing Ceramic"},{"location":"docs/advanced/privacy-and-access-control/","text":"","title":"Privacy and Access Control"},{"location":"docs/advanced/storage-and-backup/","text":"<ul> <li>Caching: index.md</li> <li>Hosting: index.md</li> <li>Archiving: index.md</li> <li>FAQ Ceramic Storage: index.md</li> </ul>","title":"Storage and Backup"},{"location":"docs/advanced/standards/","text":"","title":"Ceramic Development Standards"},{"location":"docs/advanced/standards/#standards-overview","text":"<p>The Ethereum community has adopted many standards that help keep projects (such as Ethereum clients and wallets) interoperable across implementations, and ensure smart contracts and dapps remain composable.</p> <p>Typically standards are introduced as Ethereum Improvement Proposals (EIPs), which are discussed by community members through a standard process.</p> <ul> <li>Introduction to EIPs</li> <li>List of EIPs</li> <li>EIP github repo</li> <li>EIP discussion board</li> <li>Ethereum Governance Overview March 31, 2019 - Boris Mann</li> <li>Ethereum Protocol Development Governance and Network Upgrade Coordination March 23, 2020 - Hudson Jameson</li> <li>Playlist of all Ethereum Core Dev Meetings (YouTube Playlist)</li> </ul>","title":"Standards Overview"},{"location":"docs/advanced/standards/#types-of-standards","text":"<p>Certain EIPs relate to application-level standards (e.g. a standard smart-contract format), which are introduced as Ethereum Requests for Comment (ERC). Many ERCs are critical standards used widely across the Ethereum ecosystem.</p> <ul> <li>List of ERCs</li> </ul>","title":"Types of standards"},{"location":"docs/advanced/standards/#stream-program-standards","text":"<ul> <li>ERC-20 - A standard interface for fungible (interchangeable) tokens, like voting tokens, staking tokens or virtual currencies.</li> <li>ERC-721 - A standard interface for non-fungible tokens, like a deed for artwork or a song.</li> <li>ERC-777 - A token standard improving over ERC-20.</li> <li>ERC-1155 - A token standard which can contain both fungible and non-fungible assets.</li> </ul> <p>Learn more about token standards.</p>","title":"Stream program standards"},{"location":"docs/advanced/standards/#application-standards","text":"<ul> <li>ERC-20 - A standard interface for fungible (interchangeable) tokens, like voting tokens, staking tokens or virtual currencies.</li> <li>ERC-721 - A standard interface for non-fungible tokens, like a deed for artwork or a song.</li> <li>ERC-777 - A token standard improving over ERC-20.</li> <li>ERC-1155 - A token standard which can contain both fungible and non-fungible assets.</li> </ul> <p>Learn more about token standards.</p>","title":"Application standards"},{"location":"docs/advanced/standards/#data-model-standards","text":"<ul> <li>ERC-20 - A standard interface for fungible (interchangeable) tokens, like voting tokens, staking tokens or virtual currencies.</li> <li>ERC-721 - A standard interface for non-fungible tokens, like a deed for artwork or a song.</li> <li>ERC-777 - A token standard improving over ERC-20.</li> <li>ERC-1155 - A token standard which can contain both fungible and non-fungible assets.</li> </ul> <p>Learn more about token standards.</p>","title":"Data model standards"},{"location":"docs/advanced/standards/#account-standards","text":"<ul> <li>3ID DID - A standard interface for fungible (interchangeable) tokens, like voting tokens, staking tokens or virtual currencies.</li> <li>PKH DID - A standard interface for non-fungible tokens, like a deed for artwork or a song.</li> <li>KEY DID - A token standard improving over ERC-20.</li> <li>NFT DID - A token standard which can contain both fungible and non-fungible assets.</li> <li>Safe DID - A token standard which can contain both fungible and non-fungible assets.</li> </ul> <p>Learn more about token standards.</p>","title":"Account standards"},{"location":"docs/advanced/standards/#further-reading","text":"<p>Know of a community resource that helped you? Edit this page and add it!</p>","title":"Further reading"},{"location":"docs/advanced/standards/accounts/","text":"<p>Ceramic uses the Decentralized Identifier (DID) standard for user accounts. Decentralized identifiers provide an abstraction from individual cryptographic accounts, such as blockchain accounts, enabling cross-chain interoperability and multi-account to identity support.</p>","title":"Ceramic Accounts"},{"location":"docs/advanced/standards/accounts/#supported-account-types","text":"<p>Below find the decentralized identifier (DID) standards currently supported as user accounts on Ceramic:</p>    NAME DESCRIPTION Status     3ID DID (CIP-79) A Ceramic-native account that supports mutations in the DID Document, enabling the association of multiple wallets to the account \u2705 Production   Key DID A Ceramic account that can only be associated with one wallet, which can never be changed \u2705 Production   NFT DID (CIP-94) A Ceramic account that can be controlled by the current owner of a given NFT (non-fungible token) \u26a0\ufe0f Experimental   Safe DID (CIP-101) A Ceramic account that can be controlled by the current members of a Gnosis Safe smart contract \u26a0\ufe0f Experimental","title":"Supported account types"},{"location":"docs/advanced/standards/accounts/#building-with-accounts","text":"<p>In order for users to perform transactions on Ceramic they need an account. Your application can control which accounts it supports.</p> <ul> <li>When building with a Ceramic client, you should install and configure the DID JSON-RPC client, which will instruct you how to add support for various account types.</li> <li>When building with a framework such as the Self.ID SDK, you don't need to worry about accounts, it will use 3ID DID.</li> </ul>","title":"Building with accounts"},{"location":"docs/advanced/standards/accounts/3id-did/","text":"<p>The 3ID DID Method (CIP-79) is a Ceramic-native account which can be used to authenticate to Ceramic to perform transactions on streams. </p>","title":"3ID DID Accounts"},{"location":"docs/advanced/standards/accounts/3id-did/#what-is-a-3id-account","text":"<p>3ID DID is a powerful DID method that supports multiple keys, key rotations, and revocations. The 3ID DID Method is on the W3C's official DID method registry and is fully compliant with decentralized identity standards.</p> <ul> <li>Multiple keys, secure rotations: The DID Document for the 3ID DID Method is implemented using a Ceramic Tile Document, making it fully mutable and able to support the secure addition and removal (rotation) of keys. This enables 3ID DIDs to handle multiple keys simultaneously and to remove keys when needed.</li> <li>Support for blockchain wallets: When 3ID DIDs are used in conjunction with the Identity Index protocol (CIP-11) (using the 3ID Keychain definition (CIP-20)), a 3ID DID can be controlled from a user's existing blockchain wallets. This functionality is implemented by 3ID Connect.</li> <li>Aggregated identities: 3ID DIDs can serve as a cross-chain identifier which can be controlled by all of a user's blockchain and Web3 accounts from any L1 or L2 protocol. This provides a way to unify a user's identity across all other platforms.</li> <li>Great for end users: Due to all of the reasons above.</li> </ul>","title":"What is a 3ID account?"},{"location":"docs/advanced/standards/accounts/3id-did/#specification","text":"<p>3ID DIDs are fully implemented on top of Ceramic. For the full specification, see 3ID DID Method (CIP-79).</p>","title":"Specification"},{"location":"docs/advanced/standards/accounts/3id-did/#account-identifier","text":"<pre><code>did:3:&lt;StreamID of the TileDocument storing the DID Document&gt;\n</code></pre>","title":"Account identifier"},{"location":"docs/advanced/standards/accounts/3id-did/#did-document","text":"<p>3ID offers a mutable DID document which can be used to securely set, remove, and rotate keys. This DID document is stored as a stream on Ceramic using the TileDocument StreamType.</p>","title":"DID Document"},{"location":"docs/advanced/standards/accounts/3id-did/#building-with-3id-did","text":"<p>To use 3ID DIDs for user accounts in your project, install one of the 3ID DID Providers below:</p>","title":"Building with 3ID DID"},{"location":"docs/advanced/standards/accounts/3id-did/#install-3id-connect","text":"<p>Recommended. 3ID Connect is the most popular 3ID DID Provider for Ceramic web apps. The 3ID Connect SDK allows users to control their 3ID DID from their existing blockchain wallets without needing to install any additional wallet software. Developers do not need to worry about DID key management for their users. If you're using the Self.ID SDK, you don't need to worry about installing 3ID Connect, it already includes it.</p>","title":"Install 3ID Connect \u2192"},{"location":"docs/advanced/standards/accounts/3id-did/#install-3id-did-provider","text":"<p>A low-level JavaScript 3ID DID Provider. Your application is responsible for key management, and users need to authenticate with a DID seed or an auth secret.</p>","title":"Install 3ID DID Provider \u2192"},{"location":"docs/advanced/standards/accounts/3id-did/#install-did-resolver","text":"<p>3ID DID Resolver is a JavaScript DID resolver for the 3ID DID Method. It uses Ceramic to resolve DID documents.</p>","title":"Install DID Resolver \u2192"},{"location":"docs/advanced/standards/accounts/3id-did/#additional-reading","text":"<ul> <li>3ID DID Method specification</li> <li>W3C DID specification</li> <li>TileDocument StreamType</li> </ul>","title":"Additional reading"},{"location":"docs/advanced/standards/accounts/key-did/","text":"<p>The Key DID Method is an account which can be used to authenticate to Ceramic to perform transactions on streams. </p>","title":"Key DID Accounts"},{"location":"docs/advanced/standards/accounts/key-did/#what-is-a-key-account","text":"<p>The Key DID Method is the most simple DID method. It simply encodes a public key in the DID string, and when resolved converts this public key into a DID Document. Key DID is on the W3C's official DID method registry and is fully compliant with decentralized identity standards. Carefully read the considerations below before deciding to use the Key DID Method in your project.</p> <ul> <li>One key only: The DID Document for a Key DID is explicitly tied to a single crypto key. It can not support multiple keys in the DID document nor can it support key rotation, which means only one key can ever control the DID and it can never be changed in case it is compromised.</li> <li>For advanced users: For the reasons above, the Key DID Method is only suitable for advanced users who will only want to ever use one keypair to control their DID, and who have strong key security practices - such as a developer - and so generally will not be appropriate for identities for non-technical end users.</li> </ul>","title":"What is a Key account?"},{"location":"docs/advanced/standards/accounts/key-did/#specification","text":"<p>For the full specification, see Key DID Method specification \u2192.</p>","title":"Specification"},{"location":"docs/advanced/standards/accounts/key-did/#account-identifier","text":"<p>The DID string for the Key DID Method simply encodes the public key. Example Key DID identifier:</p> <pre><code>did:key:&lt;public-key&gt;\n</code></pre>","title":"Account identifier"},{"location":"docs/advanced/standards/accounts/key-did/#did-document","text":"<p>Key DID offers an immutable DID document that is statically generated from any cryptographic key pair. The DID document is not actually stored anywhere since it can always be regenerated from the key pair.</p>","title":"DID Document"},{"location":"docs/advanced/standards/accounts/key-did/#building-with-key-did","text":"<p>To use Key DIDs for user accounts in your project, install one of the Key DID Providers below:</p>","title":"Building with Key DID"},{"location":"docs/advanced/standards/accounts/key-did/#install-key-did-provider-ed25519","text":"<p>A low-level JavaScript Key DID Provider for use with Ed25519 key pairs. Your application is responsible for key managemet, and users need to authenticate with a DID seed.</p>","title":"Install Key DID Provider Ed25519 \u2192"},{"location":"docs/advanced/standards/accounts/key-did/#install-key-did-resolver","text":"<p>The Key DID Resolver is a JavaScript DID resolver for the Key DID Method.</p>","title":"Install Key DID Resolver \u2192"},{"location":"docs/advanced/standards/accounts/key-did/#additional-reading","text":"<ul> <li>W3C DID specification</li> <li>did:key specification</li> </ul>","title":"Additional reading"},{"location":"docs/advanced/standards/accounts/nft-did/","text":"<p>\u26a0\ufe0f NFT DID is experimental. Please reach out in Discord to provide feedback or get help.</p>  <p>The NFT DID Method (CIP-94) is an account that can perform transactions on streams. NFT DID accounts are controlled by the current owner of an NFT (non-fungible token). NFT DIDs are still very experimental, so use at your own risk.</p>","title":"NFT DID Accounts"},{"location":"docs/advanced/standards/accounts/nft-did/#what-is-an-nft-account","text":"<p>The NFT DID Method turns every NFT into an account capable of controlling streams on Ceramic. Write permissions for streams whose controller is set to an NFT DID are restricted to the DID account of the blockchain account that currently owns the NFT. When the NFT changes ownership on-chain, so do the Ceramic write permissions. NFT DID is on the W3C's official DID method registry and is fully compliant with decentralized identity standards.</p>","title":"What is an NFT account?"},{"location":"docs/advanced/standards/accounts/nft-did/#example-use-cases-for-nft-accounts","text":"<ul> <li>Extensible, mutable NFT metadata \u2013 NFTs currently have fixed metadata that is created when the token is minted. But what if we want an NFT to be able to collect data over time? With NFT DID, an NFT owner can annotate an NFT with additional information that is modified over time, such as a social graph for the NFT, a story behind the artefact, owner-restricted content, or, for example, carbon offsetting certificate.</li> </ul>","title":"Example use cases for NFT accounts"},{"location":"docs/advanced/standards/accounts/nft-did/#how-to-use-nft-accounts","text":"","title":"How to use NFT accounts"},{"location":"docs/advanced/standards/accounts/nft-did/#installation","text":"<p>To use an NFT for dynamic stream access control, include the nft-did-resolver in your Ceramic node. </p>","title":"Installation"},{"location":"docs/advanced/standards/accounts/nft-did/#usage","text":"<p>To create an NFT-controlled stream, set your stream controller to <code>did:nft:...</code> when creating it. Here's an example that creates a Tile Document controlled by an NFT:</p> <pre><code>const didNFT =\n    \"did:nft:eip155:4_erc721:0xe2a6a2da2408e1c944c045162852ef2056e235ab_1\";\nconst tile = await TileDocument.create(ceramic, {foo: \"blah\"}, {controllers: [didNFT]})\n</code></pre> <ul> <li>The address of the NFT must be lowercase</li> <li>The <code>didNFT</code> string is a DID URI that references ERC721 token <code>1</code> on contract <code>0xe2a6a2da2408e1c944c045162852ef2056e235ab</code> deployed to Rinkeby (<code>eip155:4</code>). This should reference your NFT.</li> <li>We provide a helper function <code>createNftDidUrl</code> to create such a string:</li> </ul> <pre><code>import { createNftDidUrl } from 'nft-did-resolver'\n// \"did:nft:eip155:4_erc721:0xe2a6a2da2408e1c944c045162852ef2056e235ab_1\"\nconst didNFT = createNftDidUrl({\n  chainId: 'eip155:1',\n  namespace: 'erc721',\n  contract: '0x1234567891234567891234567891234596351156',\n  tokenId: '1',\n})\n</code></pre> <p>Now the Tile Document we have just created can only be controlled by the NFT's current owner.</p>","title":"Usage"},{"location":"docs/advanced/standards/accounts/nft-did/#how-it-works","text":"<p>When resolving an NFT DID account, Ceramic and the did-nft-resolver perform the following steps:</p> <ol> <li>Query a blockchain for the NFT's owner(s) using a subgraph on The Graph protocol. </li> <li>For each owner, find a corresponding CAIP-10 Link (CIP-7), which provides a link from blockchain account to Ceramic account. This determines who can write to the stream.</li> <li>When a transaction is sent to the stream owned by the NFT,  verify the Ceramic account that signed the message is linked to the blockchain account that is a current owner.</li> </ol> <p></p> <p>Note: If you wish to build with NFT accounts, you need to ensure your users can generate CAIP-10 Links to connect their blockchain account(s) to their Ceramic account. If you're using 3ID Connect, this is handled automatically by the wallet when signing in.</p>  <p>Ensure 3ID Connect is on the same Ceramic network as your application. If those networks are different it will create a mismatch in Ceramic acounts that are linked to the same blockchain account (on testnet <code>0xethereum</code>\u2192DID-A, on devnet for the same account <code>0xethereum</code>\u2192DID-B).  Please make sure that the DID from a CAIP-10 Link  from your app corresponds to the DID you get from 3ID Connect.</p>","title":"How it works"},{"location":"docs/advanced/standards/accounts/nft-did/#current-limitations","text":"<ul> <li>Only ERC-21 and ERC-1155 tokens are supported at this time.</li> <li>Only Ethereum Rinkeby, Etherem mainnet, and Polygon networks are supported by default. If you need other networks, see the nft-did-resolver README, and update network parameters and configuration of your Ceramic node. Notable, this config needs three additional subgraphs: for blocks, for ERC-721 and ERC-1155 tokens, and a \"skew\", which is a typical block time.</li> </ul>  <p>Data from a subgraph might lag behing the current state found on the blockchain network. For example, if Etherscan reports the latest block number as 1000, a subgraph might still index block number 995. This could result in an error like <code>\"invalid_jws: not a valid verificationMethod for issuer\"</code>. If this occurs, make sure to repeat the transaction after some time, enough for the subgraph to catch up with the blockchain. In general, it is best practice to accommodate for this delay in your application.</p>","title":"Current limitations"},{"location":"docs/advanced/standards/accounts/nft-did/#specification","text":"<p>Read the NFT DID Method (CIP-94) Specification for the full specificatoin.</p>","title":"Specification"},{"location":"docs/advanced/standards/accounts/pkh-did/","text":"","title":"PKH DID"},{"location":"docs/advanced/standards/accounts/safe-did/","text":"<p>This page is a stub. We're working on adding more content to help you build with Safe DIDs.</p>   <p>\u26a0\ufe0f Safe DID is experimental. Please reach out in Discord to provide feedback or get help.</p>  <p>The Gnosis Safe DID Method (CIP-101) is an account that can perform transactions on streams. Safe DID accounts are controlled by the current members of a Gnosis Safe smart contract. Safe DID is on the W3C's official DID method registry and is fully compliant with decentralized identity standards, however they are still highly experimental, so use at your own risk.</p>","title":"Gnosis Safe DID Accounts"},{"location":"docs/advanced/standards/accounts/safe-did/#what-is-a-safe-account","text":"<p>The Safe DID Method turns every Gnosis Safe contract into a Ceramic account capable of sending transactions to streams on Ceramic. It is similar in design and usage to the NFT DID account method. </p> <p>Write permissions for streams whose controller is set to a Safe DID are restricted to the DIDs of the blockchain accounts that control the Gnosis Safe contract. When Gnosis Safe controller permissions change on-chain, so do the write permissions to streams owned by the Safe. </p>","title":"What is a Safe account?"},{"location":"docs/advanced/standards/accounts/safe-did/#specification","text":"<p>Read the Safe DID Method (CIP-101) Specification for the full specification.</p>","title":"Specification"},{"location":"docs/advanced/standards/application-protocols/","text":"","title":"Application protocol standards"},{"location":"docs/advanced/standards/application-protocols/identity-index/","text":"<p>CIP-11 \"Identity Index\" (commonly called \"IDX\") is a decentralized identity protocol which make it easy for developers to build applications with user-controlled streams for storing data, as well as to discover and make use of user data created on third-party applications. Building with IDX allows users to control their identities and data in a manner independent from any single application, while allowing developers to build data-rich applications without the liability of custodying user data on a centralized server or the poor user experience of forcing users to recreate the same data on every application.</p>  <p>This page mentions that IDX is intended for storing \"user\" data as that is its primary use case. However IDX can be used for storing data for other types of subjects represented by DIDs such as businesses, organizations, applications, assets (NFTs), or devices (IoT).</p>","title":"Account-Based Stream Index"},{"location":"docs/advanced/standards/application-protocols/identity-index/#overview","text":"<p>DID-compatibility: IDX does not provide DIDs, but relies on them for decentralized, platform-agnostic identifiers. IDX can work with any DID method that is supported in Ceramic. Various DID methods, such as 3ID, support linking to and authenticating with many different blockchain accounts (see 3ID Keychain (CIP-20)). This allows DIDs to serve as a universal, cross-chain and platform-agnostic identifier for users.</p> <p>Stream-based storage: Store data for your users or your application in user-controlled streams on Ceramic. Data in streams can be stored in cleartext or encrypted. IDX-created streams enjoy all the benefits of mutability, persistence, replication, and availability provided by the Ceramic network.</p> <p>Identity hubs: Whenever a user stores data in a new stream via IDX, its streamID is automatically registered in their index, which is a separate stream that serves as a single catalog of references to all their data. The index enables all data associations for the user to exist in one place, which in turn enables any application to discover all data about the user by simply querying their index.</p> <p>Public, semantic data descriptions: All data stored via IDX is semantically described and organized in the user's index, allowing multiple applications to make use of the same data based on schemas and metadata instead of which application the user was using when they first created the data.</p> <p>Cross-application data portability: The combination of DIDs, streams, hubs, and semantic data descriptions allows user data to be stored in an application-agnostic manner and can be used across different applications or interfaces. No application maintains \"special permissions\" since users are in full control.</p> <p>Standard interfaces: IDX provides standardized read/write APIs for interacting with all data so applications aren't ever forced to integrate one-off APIs.</p> <p>Built on open standards: IDX builds on open standards for decentralized identity shepherded by the Ceramic community via CIPs, and other related identity communities such as W3C and the Decentralized Identity Foundation (DIF).</p>","title":"Overview"},{"location":"docs/advanced/standards/application-protocols/identity-index/#protocol-design","text":"<p>Dive into the design and architecture of the IDX protocol, which is implemented by DID DataStore.</p> <p></p>","title":"Protocol design"},{"location":"docs/advanced/standards/application-protocols/identity-index/#index","text":"<p>The index is a stream controlled by the user's DID which stores entries consisting of definition (represented by a streamID) to record (represented by a streamID) mappings. Every DID has only one global index and its entries represent the entire catalog of data that belongs to the user. An index is similar to a row in a user table, and enables the decentralized association and discovery of streams that belong to a user.</p> <p>Example:</p> <pre><code>{\n  \"kyz123...456\": \"ceramic://kyz789...012\",\n  \"kyz345...678\": \"ceramic://kyz901...234\",\n  \"kyz567...890\": \"ceramic://kyz123...456\",\n  \"kyz789...012\": \"ceramic://kyz345...678\"\n}\n</code></pre>","title":"Index"},{"location":"docs/advanced/standards/application-protocols/identity-index/#definitions","text":"<p>Definitions are streams created by application developers that store metadata which describes the stream used for data storage. Definitions allow records to be semantically described and queried using their metadata or schema and are similar to a column in a user table. The streamID of the definition is a key in the index.</p> <p>Example:</p> <pre><code>{\n  name: 'Basic Profile',\n  description: 'A simple basic profile.',\n  schema: 'ceramic://kyz123...456'\n}\n</code></pre>","title":"Definitions"},{"location":"docs/advanced/standards/application-protocols/identity-index/#schemas","text":"<p>Schemas are streams created by application developers that store a JSON schema. They specify the data schema of a record. Schemas are identified by the streamID of the stream that stores the schema, which is included in the definition as seen above.</p>","title":"Schemas"},{"location":"docs/advanced/standards/application-protocols/identity-index/#records","text":"<p>Records are streams that store information for a DID. They can directly store content, or they can store foreign key references to external datastores outside of Ceramic. A record is similar to a cell in a user table. The streamID of the record is a value in the index.</p> <p>Example:</p> <pre><code>{\n  name: 'Alan Turing',\n  description: 'I make computers beep good.',\n  emoji: '\ud83d\udcbb'\n}\n</code></pre>","title":"Records"},{"location":"docs/advanced/standards/application-protocols/identity-index/#how-it-works","text":"","title":"How it works"},{"location":"docs/advanced/standards/application-protocols/identity-index/#storing-data-with-idx","text":"<ol> <li>Application developer creates stream that contains a JSON schema.</li> <li>Application developer creates a stream that contains a definition and includes the StreamID of the stream containing the schema.</li> <li>User creates a record (a stream) that conforms to the definition as they interact with an application.</li> <li>IDX automatically adds the definition streamID and the record streamID as an entry in the user's index.</li> </ol>","title":"Storing data with IDX"},{"location":"docs/advanced/standards/application-protocols/identity-index/#reading-data-from-idx","text":"<ol> <li>Application queries a user's index by passing the user's DID and the streamID of a definition. Before performing this action, an application can query the user's entire index to see which definitions they have.</li> <li>Application gets back the record that corresponds to the definition.</li> </ol>","title":"Reading data from IDX"},{"location":"docs/advanced/standards/application-protocols/identity-index/#use-cases","text":"<p>Authentication secrets: 3ID Connect uses IDX to create a DID-controlled stream which stores encrypted authentication secrets that allows a 3ID DID to be authenticated with various blockchain wallets. To achieve this, the 3ID Connect team has created the 3ID Keychain definition (CIP-20).</p> <p>Profile information: DNS.xyz uses IDX to create a DID-controlled stream which stores basic profile information for the DID. To achieve this, the DNS.xyz team uses the Basic Profile definition (CIP-19).</p> <p>Web2 social account links: Self.ID uses IDX to create a DID-controlled stream which stores a list of Web2 accounts controlled by the same user that owns the DID, along with verifiable claims which prove this ownership. To achieve this, the Self.ID team has created the Also Known As (AKA) definition (CIP-23).</p> <p>Web3 Crypto account links: 3ID Connect uses IDX to create a DID-controlled stream which stores a list of streamIDs for CAIP10Links that publicly prove the owner of this DID also owns various accounts on Web3/blockchain platforms. To achieve this, the 3ID Connect team has created the Crypto Accounts definition (CIP-21).</p>","title":"Use-cases"},{"location":"docs/advanced/standards/application-protocols/identity-index/#implementations","text":"<ul> <li>The DID DataStore library is a low-level implementation of the IDX protocol for runtime interactions.</li> <li>The Self.ID SDK uses the DID DataStore library to provide runtime support for the IDX protocol, with additional features.</li> </ul>","title":"Implementations"},{"location":"docs/advanced/standards/application-protocols/identity-index/#learn-more","text":"<ul> <li>Full Identity Index (IDX) protocol specification (CIP-11)</li> </ul>","title":"Learn more"},{"location":"docs/advanced/standards/data-models/","text":"<p>Data models are collections of one or more streams, specified by their schemas and definitions, that comprise a single higher-order data structure on Ceramic. Typically, data models are used to represent an application feature such as blog posts, a social graph, or a user profile. Most Ceramic applications are built with more than one data model.</p> <p>Data models are open standards created by the community that form the basis of data composability on Ceramic. When multiple applications reuse the same data model, they get access to the same data.</p>","title":"Data models"},{"location":"docs/advanced/standards/data-models/#building-with-data-models","text":"","title":"Building with data models"},{"location":"docs/advanced/standards/data-models/#data-models-registry","text":"<p>The Data Models Registry is home to the data models that developers wish to make available for reuse. We recommend starting there to discover which data models are available to use when building. Using data models from the registry promotes data composability by giving your application access to existing data on the network and helps avoid unnecessarily creating new data models.</p>","title":"Data Models Registry \u2192"},{"location":"docs/advanced/standards/data-models/#creating-new-data-models","text":"<p>If none of the data models in the Data Models Registry suit your needs, you can create new data models using one of the methods below. After creating your data models, we recommend submitting them to the registry to enable reuse by others.</p> <ul> <li>Manually create data models using the Glaze CLI</li> <li>Programmatically create data models using Glaze DevTools</li> </ul>","title":"Creating new data models"},{"location":"docs/advanced/standards/data-models/cip-19/","text":"","title":"CIP-19 Basic Profile"},{"location":"docs/advanced/standards/data-models/data-model-universe/","text":"<p>The Data Models Registry \u2192 is home to all of the data models that have been created by other developers in the Ceramic community which you can reuse when building your application. Using data models from the registry promotes data composability by giving your application access to existing data on the network and helps avoid unnecessarily creating new data models.</p>","title":"Data Models Registry"},{"location":"docs/advanced/standards/data-models/data-model-universe/#available-data-models","text":"<p>Visit the Data Models Registry \u2192 for a full list of available data models. Although we cannot list every data model in the registry, here is a sampling of what can be found there:</p>    Data model Description Maintainer     <code>identity-profile-basic</code> Stores a user's profile 3Box Labs   <code>identity-accounts-web</code> Stores verifiable credentials that link a user's Web2 accounts to their Ceramic account 3Box Labs   <code>identity-accounts-crypto</code> Stores a list of CAIP-10 Links that link a user's Web3 accounts to their Ceramic account 3Box Labs   <code>social-connections</code> Stores a user's social graph CyberConnect","title":"Available data models"},{"location":"docs/advanced/standards/data-models/data-model-universe/#adding-your-models-to-the-registry","text":"<p>If none of the data models in the Data Models Registry suit your needs, you can create new data models using the Glaze CLI or the Glaze DevTools library. After creating your data models, you can submit them to the registry!</p>","title":"Adding your models to the registry"},{"location":"docs/advanced/standards/stream-programs/","text":"<p>Streams are individual instances of state on the Ceramic network. Every stream is mutable and can only be modified when it receives a transaction signed by the account that owns it.</p>","title":"Streams"},{"location":"docs/advanced/standards/stream-programs/#how-streams-work","text":"","title":"How streams work"},{"location":"docs/advanced/standards/stream-programs/#stream-identifiers","text":"<p>Every stream is identified by its <code>streamID</code>, which is its unique address on the Ceramic network. When applications load a stream from the network using its streamID, its current state is returned. Alternative, applications can load a previous version of a stream's state by using the <code>commitID</code> of the specific version wanted.</p>","title":"Stream identifiers"},{"location":"docs/advanced/standards/stream-programs/#streamcode","text":"<p>Every stream that is created on Ceramic must reference a <code>streamcode</code> in its metadata, which is a script that contains the processing logic used to transform a stream's current state into the next state upon receipt of a new transaction. In general, you can think of streamcode as reusable state processing logic and streams as the individual states it generates.</p> <p>Today Ceramic supports two types of streams: tile documents which store mutable JSON documents with schema validation, and CAIP-10 links which store a link between a Web3 wallet account and a Ceramic account.</p>","title":"Streamcode"},{"location":"docs/advanced/standards/stream-programs/#metadata","text":"<p>Every stream can specify a few metadata properties:</p>    Metadata property Required? Description     <code>streamtype</code> Yes The streamcode used by the stream   <code>controller</code> Yes The Ceramic account (DID) that can modify the stream   <code>schema</code> No The schema for the stream   <code>family</code> No Used to associate collections of streams   <code>tags</code> No Used to create subgroupings of streams","title":"Metadata"},{"location":"docs/advanced/standards/stream-programs/#content","text":"<p>The type of content that a stream can store is determined by its streamcode.</p>","title":"Content"},{"location":"docs/advanced/standards/stream-programs/#building-with-streams","text":"","title":"Building with streams"},{"location":"docs/advanced/standards/stream-programs/#store-json-content","text":"<p>Tile Document (CIP-8) is streamcode that stores a mutable JSON document with schema validation, providing similar functionality as a NoSQL document.</p>","title":"Store JSON content \u2192"},{"location":"docs/advanced/standards/stream-programs/#store-blockchain-account-links","text":"<p>CAIP-10 Link (CIP-7) is streamcode that stores a link between a Web3 wallet account and a Ceramic account.</p>","title":"Store blockchain account links \u2192"},{"location":"docs/advanced/standards/stream-programs/#new-streamcode","text":"<p>Ceramic does not yet suport the arbitrary creation of new streamcode. If you'd like to create new streamcode to support additional use cases for streams, reach out on the Ceramic Discord.</p>","title":"New streamcode"},{"location":"docs/advanced/standards/stream-programs/caip10-link/","text":"<p>CAIP-10 Link (CIP-7) is streamcode that stores a link between a Web3 wallet account and a Ceramic account.</p>","title":"CAIP-10 Link (CIP-7)"},{"location":"docs/advanced/standards/stream-programs/caip10-link/#about-caip-10-link","text":"","title":"About CAIP-10 Link"},{"location":"docs/advanced/standards/stream-programs/caip10-link/#features","text":"<ul> <li>Chain-agnostic \u2013 CAIP-10 Link leverages the Chain Agnostic Improvement Proposal (CAIP) 10 standard to represent blockchain accounts from a variety of blockchain networks</li> <li>One-way links \u2013 Links are one way only: from a blockchain account to a Ceramic account (DID). It is not possible to go from a Ceramic account to a blockchain account using only CAIP-10 Links. However, this can be achieved by using the <code>identity-accounts-crypto</code> data model which stores a list of CAIP-10 links owned by a Ceramic account.</li> <li>Multi-account \u2013 A Ceramic account (DID) can have an unlimited number of CAIP-10 Links that publicly bind it to many different addresses on many different L1 and L2 blockchain networks.</li> </ul>","title":"Features"},{"location":"docs/advanced/standards/stream-programs/caip10-link/#structure","text":"<ul> <li>Content \u2013 The content of a CAIP-10 Link can only store the <code>string</code> value of a Ceramic account (DID) or <code>null</code> if no DID is linked. Internally, the commits in the CAIP-10 Link contain a signed link proof.</li> <li>Metadata \u2013 The metadata of a CAIP-10 Link is defined by the standard and is not editable by consumers. It contains the blockchain account (CAIP-10 string) as the only entry in <code>controllers</code> and adds the chainID as in <code>family</code>.</li> </ul>","title":"Structure"},{"location":"docs/advanced/standards/stream-programs/caip10-link/#getting-started-with-caip-10-links","text":"","title":"Getting started with CAIP-10 Links"},{"location":"docs/advanced/standards/stream-programs/caip10-link/#available-implementations","text":"<p>Visit the JavaScript CAIP-10 Link implementation to create and load CAIP-10 Links within your application. Alternatively if you use 3ID Connect for authentication, which comes standard in most Ceramic frameworks such as Self.ID SDK, then it will take care of creating CAIP-10 links for users for you.</p>","title":"Available implementations"},{"location":"docs/advanced/standards/stream-programs/caip10-link/#further-reading","text":"<p>Read the CAIP-10 Link (CIP-7) standard for more information about the standard.</p>","title":"Further reading"},{"location":"docs/advanced/standards/stream-programs/tile-document/","text":"<p>Tile Document (CIP-8) is streamcode that stores a mutable JSON document with schema validation, providing similar functionality as a NoSQL document.</p>","title":"Tile Document (CIP-8)"},{"location":"docs/advanced/standards/stream-programs/tile-document/#about-tile-documents","text":"","title":"About Tile Documents"},{"location":"docs/advanced/standards/stream-programs/tile-document/#features","text":"<ul> <li>Mutable JSON Storage \u2013 TileDocuments are used for storing JSON data. Every TileDocument stream is structured as a single log of commits, where each commit only contains the diff from the previous version. </li> <li>JSON Schema \u2013 Optionally, TileDocuments may specify a JSON schema in metadata and all commits must adhere to the schema.</li> <li>Blockchain-based timestamps \u2013 TileDocuments rely on anchor commits for providing immutable timestamps for the genesis commit and subsequent signed commits in the stream. </li> <li>Conflict resolution \u2013 In the case of conflicting versions, the branch with the earliest recorded anchor commit will be respected as the canonical branch.</li> <li>Authentication \u2013 TileDocuments rely on DIDs for authentication. Only the DID assigned as the controller of the stream are allowed to perform writes.</li> <li>Performance \u2013 As more updates are made to a single tile, the underlying DAG grows linearly, and so does sync times when fetching the stream over the network. However, when loading a tile from a node that already has it present, responses are very quick.</li> </ul>","title":"Features"},{"location":"docs/advanced/standards/stream-programs/tile-document/#current-limitations","text":"<ul> <li>Only allows single controller</li> <li>No indexing, but metadata will be used, follow conventions</li> <li>Growing log, not adapted to frequent updates</li> </ul>","title":"Current limitations"},{"location":"docs/advanced/standards/stream-programs/tile-document/#getting-started-with-tile-documents","text":"","title":"Getting started with Tile Documents"},{"location":"docs/advanced/standards/stream-programs/tile-document/#available-implementations","text":"<p>Visit the JavaScript TileDocument implementation to create and load TileDocuments within your application.</p>","title":"Available implementations"},{"location":"docs/advanced/standards/stream-programs/tile-document/#tutorials","text":"<p>This guide describes how to create, update, and query TileDocuments using the Ceramic JS HTTP Client and the Core Client. </p>","title":"Tutorials"},{"location":"docs/advanced/standards/stream-programs/tile-document/#further-reading","text":"<p>Read the Tile Document (CIP-8) standard for more information about the standard.</p>","title":"Further reading"},{"location":"explore/explorers/","text":"<p>Discover various explorers for the Ceramic Network.</p>","title":"Explorers"},{"location":"explore/explorers/#tiles","text":"<p>Tiles is a browser-based explorer where you can see a feed of all streams created on mainnet, and dive into the details of any particular stream.</p> <p></p>  <p>Learn more about Tiles and their vision for enabling a world of open, shared data models in the Tiles Spotlight.</p>","title":"Tiles"},{"location":"explore/projects/","text":"<p>This page contains a list of community projects built on Ceramic.</p>","title":"Community projects"},{"location":"explore/projects/#featured-projects","text":"","title":"Featured projects"},{"location":"explore/projects/#boardroom-coming-soon","text":"<p>Governance forums: BoardRoom uses Ceramic, account-based stream indexing, and 3ID Connect to store proposals, comments, votes, and other user-generated content for their decentralized governance application.</p>","title":"Boardroom (coming soon)"},{"location":"explore/projects/#geoweb","text":"<p>Mutable files for NFTs: GeoWeb is creating a fair and open augmented reality (AR) metaverse where digital land is represented by NFTs and content for the land is represented by one or more streams on Ceramic.</p>  <p>Learn more about GeoWeb and how they're using Ceramic in the GeoWeb Spotlight.</p>","title":"GeoWeb"},{"location":"explore/projects/#metagame-coming-soon","text":"<p>Multi-app user profiles: MetaGame uses Ceramic, account-based stream indexing, and 3ID Connect to store profile data for Ethereum users that can be consumed, added to, or extended by any app in the Web3 metaverse.</p>","title":"MetaGame (coming soon)"},{"location":"explore/projects/#arcx-coming-soon","text":"<p>Decentralized document database: ArcX uses Ceramic to store mutable JSON documents, similar to a NoSQL document store.</p>","title":"ArcX (coming soon)"},{"location":"explore/projects/#daemonland-coming-soon","text":"<p>Multi-app data: Developers on the Daemon.Land platform use Ceramic and account-based stream indexing to store user data, which makes it easy for users and their data to freely travel between different apps built with Daemon.Land.</p>","title":"Daemon.Land (coming soon)"},{"location":"explore/projects/#rabbithole-coming-soon","text":"<p>Cross-chain identity and reputation: RabbitHole uses Ceramic, account-based stream indexing, and 3ID Connect to link multiple Web3 wallets and Web2 accounts to a unified, cross-chain DID. After calculating an aggregate reputation score for this DID, they issue and store a verifiable credential in the user's account-based index so it's usable on any other Web3 application.</p>","title":"RabbitHole (coming soon)"},{"location":"explore/projects/#the-convo-space-coming-soon","text":"","title":"The Convo Space (coming soon)"},{"location":"explore/projects/#dnsxyz-coming-soon","text":"<p>Web3 profiles: DNS.XYZ uses Ceramic and account-based stream indexing to allow users to create and manage a universal multi-account profile for the Web3 metaverse.</p>","title":"DNS.XYZ (coming soon)"},{"location":"explore/projects/#fungyproof-coming-soon","text":"<p>NFT grading and enrichments: FungyProof uses Ceramic to store a cross-chain, aggregate view of NFTs and their associated data including: grade/quality, digital cases, events/press, achievements, and more. NFT Owners can improve their NFTs by adding enrichments and modify the NFTs public profile to highlight the characteristics they choose.</p>","title":"FungyProof (coming soon)"},{"location":"explore/projects/#more-projects","text":"<p>See Awesome Ceramic for a list of community projects built on Ceramic.</p>","title":"More projects"},{"location":"explore/sample-apps/","text":"<p>This page contains links to simple applications that give you a sense of what's possible with Ceramic.</p>","title":"Sample Apps"},{"location":"explore/sample-apps/#playground","text":"<p>Playground is a minimal browser application that integrates the JS HTTP Client, 3ID Connect, and Glaze libraries.</p>","title":"Playground"},{"location":"guides/","text":"<p>A collection of helpful development guides created by the community. Want to add your guide? Submit a pull request.</p>","title":"Ceramic Development Guides"},{"location":"guides/#the-ceramic-blog","text":"<p>The Ceramic blog contains many useful resources that can help when building applications with Ceramic. To check out those resources, head over to the Ceramic blog \u2192.</p>","title":"The Ceramic blog"},{"location":"guides/#application-development-guides","text":"<ul> <li>Getting started with the Ceramic CLI</li> <li>Using the Ceramic HTTP Client</li> <li>Retrieving data from Ceramic</li> <li>Build a note-taking application with Glaze suite</li> </ul>","title":"Application development guides"},{"location":"guides/#protocol-development-guides","text":"<ul> <li>How to authenticate with an unsupported blockchain account type</li> </ul>","title":"Protocol development guides"},{"location":"learn/blog/","text":"<p>The Ceramic Blog contains news, announcements, videos, as well as helpful tutorials and resources for building with Ceramic. Check it out to get inspired for your next project.</p>","title":"Ceramic Blog"},{"location":"learn/blog/#featured-posts","text":"<p>The next architecture for building Web3 data apps: We're replacing the popular IDX runtime with a more powerful set of tools for building applications on Ceramic including DID DataStore, DataModels, and Self.ID. </p> <p>What is Ceramic: Ceramic is a decentralized content computation network for a world of open source information.</p> <p>Ceramic Mainnet Early Launch Program: Sign up today to deploy your project on the Ceramic Mainnet before it's open to the general public.</p> <p>How to build a simple notes app with IDX: Learn how to build a simple note taking application where users own their data with IDX and React.</p> <p>How to store signed and encrypted data on IPFS: Learn how to store signed and encrypted data directly in IPFS using two new standards: dag-jose and EIP-2844.</p> <p>Trust minimized off-chain conviction voting: How to implement a conviction voting system using verifiable, off-chain data on Ceramic.</p>","title":"Featured posts"},{"location":"learn/blog/#featured-videos","text":"<p>Learn how to manage user data in a Web3 app with IDX: Learn how to manage user data for your Web3 application with IDX. This talk is a workshop from tthe ETHDenver 2021 hackathon.</p> <p>Standards for encrypted and mutable data on IPFS: Joel talks about new standards for signed, encrypted, mutable data on IPFS. This is a talk from the ETHDenver 2021 hackathon.</p> <p>The evolution of digital identity: Michael talks about the evolution of digital identity from servers, to key pairs, to DIDs and IDX. A presentation from the ETHDever 2021 hackathon.</p>","title":"Featured videos"},{"location":"learn/features/","text":"<p>Ceramic's decentralized data network provides Web3 developers with a collection of features that make it possible to build scalable Web3 applications with composable data that can be reused and shared across applications.</p>","title":"Why Ceramic?"},{"location":"learn/features/#mutable-data-storage","text":"<p>Ceramic provides developers with a set of standard, open APIs for storing, updating, and retrieving data from the network. This helps to break down data silos, enabling all data to be openly accessible. Additionally, all data mutations on Ceramic are cryptographically verifiable and can provide auditability throughout all historical versions of a piece of data that has changed over time.</p>","title":"Mutable data storage"},{"location":"learn/features/#data-composability","text":"<p>Data on Ceramic is structured and stored in data models, which can be easily reused by different applications to share data between them. Data models are created by developers in the community, and the ecosystem of data models is constantly expanding. Data models typically represent a single, logical application feature such as a user profile, a social graph, or a blog and developers typically combine multiple data models to create their application.</p>","title":"Data composability"},{"location":"learn/features/#developer-experience","text":"<p>Building composable applications with Web3 data on Ceramic is simple. Install Ceramic, browse the marketplace of data models, plug these models into your app, and automatically get access to all data stored on the network that conforms to those data models. The community is constantly creating new tooling that make it easier to build, and expand what's possible with composable data.</p>","title":"Developer experience"},{"location":"learn/features/#sign-in-with-web3","text":"<p>Ceramic uses the decentralized identifier (DID) standard for user accounts, which are compatible with all blockchain wallets. When using Ceramic in your application, users can authenticate with the Web3 wallets they already have, and can even control the same Ceramic account from multiple different blockchain wallets (cross-chain) if they'd like. Data models are typically account-centric, meaning that every user is in control of their own data.</p>","title":"Sign in with Web3"},{"location":"learn/features/#decentralization","text":"<p>The Ceramic network is decentralized and permissionless, allowing anyone in the world to spin up a node to provide storage, compute, and bandwidth resources to users and applications built on the network. Today there are no tokenized incentives for running Ceramic, but the community is exploring options.</p>","title":"Decentralization"},{"location":"learn/features/#scalability","text":"<p>Ceramic's data network infrastructure is highly-scalable and can service use cases where high amounts of data throughput is needed. On Ceramic, every data object maintains its own state and nodes independently process stream transactions, allowing unbounded parallelization. This enables Ceramic to operate at worldwide data scale, which is orders of magnitude greater than the scale needed for decentralized finance.</p>","title":"Scalability"},{"location":"learn/glossary/","text":"<p>This page contains a glossary of terms for Ceramic. Consider this list a work-in-progress; we will continue to update it until it's complete.</p>","title":"Glossary of terms"},{"location":"learn/glossary/#core-concepts","text":"","title":"Core concepts"},{"location":"learn/glossary/#streams","text":"<p>Streams are DAG-based data structures for storing continuous, mutable streams of content on IPFS and tracking state in a completely decentralized, peer-to-peer way. When syncing or loading a stream from the network, you will always get back the current state.</p>","title":"Streams"},{"location":"learn/glossary/#streamid","text":"<p>A StreamID is an immutable identifier for a stream. StreamIDs enable continuous streams of data to be referenced by a persistent identifier instead of by constantly-changing IPFS CIDs.</p>","title":"StreamID"},{"location":"learn/glossary/#streamtypes","text":"<p>StreamTypes are functions used for processing updates to streams. StreamTypes handle everything from defining the data structure of the stream, to what can be stored in its commits, its state transitition function, authentication requirements, and conflict resolution strategy. Every stream must specify a StreamType; and StreamTypes run on Ceramic nodes. Ceramic comes pre-installed with various StreamTypes, or you can code your own.</p>","title":"StreamTypes"},{"location":"learn/glossary/#commits","text":"<p>Commits are individual IPFS records that make up a stream. Streams may contain one or more commits.</p>","title":"Commits"},{"location":"learn/glossary/#genesis-commit","text":"<p>A genesis commit is the first commit in a stream. Genesis commits may be signed by a public key, or unsigned.</p>","title":"Genesis commit"},{"location":"learn/glossary/#signed-commit","text":"<p>Signed commits are commits that update the state of a stream. All signed commits need to be cryptographically signed by a public key.</p>","title":"Signed commit"},{"location":"learn/glossary/#anchor-commit","text":"<p>Anchor commits are commits that contain a blockchain timestamp, providing an immutable record of time and ordering to other commits in the stream, sometimes known as a proof-of-publication. Anchor commits are needed since vanilla merkle DAGs have no notion of absolute time needed to build consensus.</p>","title":"Anchor commit"},{"location":"learn/glossary/#commitid","text":"<p>A commitID is an immutable identifier for a specific commit in a stream.</p>","title":"CommitID"},{"location":"learn/glossary/#state","text":"<p>State represents the state of a stream at various points in time. When a stream is loaded or queried from the network, the current state is returned.</p>","title":"State"},{"location":"learn/glossary/#tip","text":"<p>A tip is the CID for the most recent commit(s) of a stream.</p>","title":"Tip"},{"location":"learn/glossary/#conflict-resolution-strategy","text":"<p>A conflict resolution strategy is logic defined by a StreamType that describes how the protocol should handle conflicting updates to a stream that uses this StreamType.</p>","title":"Conflict resolution strategy"},{"location":"learn/glossary/#controllers","text":"<p>Controllers are entities allowed to perform updates to a stream, by creating new signed commits. A given stream may have one or more controllers.</p>","title":"Controllers"},{"location":"learn/glossary/#stream-authentication","text":"","title":"Stream authentication"},{"location":"learn/glossary/#authentication","text":"<p>Authentication allows a user to perform protected operations on a stream, such as creating genesis commits, signed commits, or decrypting data. Each StreamType implementation is able to specify its own authentication mechanism as long as the signatures can be resolved/validated by Ceramic, but most StreamTypes use DIDs.</p>","title":"Authentication"},{"location":"learn/glossary/#dids","text":"<p>DIDs is the W3C standard for decentralized identifiers. The DID specification outlines a standard URI scheme for creating a persistent decentralized identifier (DID) for a given subject as well as resolving metadata about that identifier via a DID document. DIDs are used as an authentication mechanism by most StreamTypes.</p>","title":"DIDs"},{"location":"learn/glossary/#did-methods","text":"<p>DID methods are implementations of the DID specification. DID methods must specify a name for the method in the form of a string (see below), a description of where the DID document is stored (or how it is statically generated), and a DID resolver which can return a DID document given a URI that conforms to that particular DID method. There are over 40 DID methods on the W3C's official DID registry. Ceramic can support any DID method if needed, and currently supports the 3ID DID method and the Key DID method. DID URIs look like this:</p> <pre><code>did:&lt;method-name&gt;:&lt;method-specific-identifier&gt;\n</code></pre>","title":"DID methods"},{"location":"learn/glossary/#did-document","text":"<p>DID documents are documents which contain metadata about a given DID. At a minimum they should contain cryptographic key material used for signature verification and encryption/decryption. They may be mutable where their keys and content can be changed/rotated (i.e. 3ID DID method) or statically generated where their contents cannot be manually changed (i.e. Key DID method).</p>","title":"DID document"},{"location":"learn/glossary/#did-resolver","text":"<p>DID resolvers are software libraries responsible for returning a DID document given a DID string. Each DID method has at least one resolver implementation. For all DID methods supported by Ceramic, the corresponding DID resolver must be included in a Ceramic node. Ceramic uses DID resolvers to verify stream transactions by comparing the signature on the transaction to the controller of the stream. For the transaction to be successfully processed, a public key corresponding to the transaction signature must be present in the DID Document of the DID listed as a controller.</p>","title":"DID resolver"},{"location":"learn/glossary/#did-providers","text":"<p>DID providers are software libraries that expose a json-rpc interface which allows for the creation and usage of a DID that conforms to a particular DID method. Usually a DID provider is constructed using a seed that the user controls. When using Ceramic with streams that require DIDs for authentication, applications either need to integrate a DID provider library, which leaves the responsibility of key management up to the application, or a DID wallet, which is a more user-friendly experience.</p>","title":"DID providers"},{"location":"learn/glossary/#did-wallets","text":"<p>DID wallets are software libraries or end-user applications that wrap DID providers with additional capabilities. 3ID Connect is the most popular DID wallet SDK that allows users create, manage, and use a 3ID DID method with their existing blockchain wallets, and without needing to install any additional software.</p>","title":"DID wallets"},{"location":"learn/glossary/#network","text":"","title":"Network"},{"location":"learn/glossary/#clients","text":"<p>Clients are software libraries that provide developer interfaces to a Ceramic node. Clients are responsible for authenticating users, providing StreamType-specific interfaces for generating genesis commits and signed commits, and providing generic, streamtype-agnostic interfaces for loading or querying streams. A list of Ceramic clients can be found here.</p>","title":"Clients"},{"location":"learn/glossary/#nodes","text":"<p>Nodes are software libraries that provide core protocol functionality for the Ceramic network. Nodes are responsible for processing stream updates (in the form of signed commits from clients), storing state for the streams that it cares about, responding to queries, networking with other nodes, replicating streams across the network, and sending valid signed commits to an external anchor service for generating anchor commits.</p>","title":"Nodes"},{"location":"learn/glossary/#anchor-service","text":"<p>A Ceramic Anchor Service (CAS) is a hosted \"layer-2\" solution for generating anchor commits for many different stream transactions in a scalable, low cost manner. Ceramic nodes are responsible for sending anchor requests containing a StreamID and a CommitID to a CAS, which then batches these transactions into a merkle tree, and includes the merkle root into a blockchain platform in a single transaction (currently Ethereum). After the transaction makes its way onto a blockchain, a Ceramic node creates an anchor commit which includes a reference to the blockchain transaction for every anchored stream. A CAS eliminates the need for each stream transaction to have its own corresponding blockchain transaction, which would be slower and more expensive.</p>","title":"Anchor service"},{"location":"learn/glossary/#networks","text":"<p>Networks are collections of Ceramic nodes that share specific configurations and communicate over a dedicated libp2p topic. Networks are discrete from one another. Streams that exist on one network are not discoverable on or portable to another. Currently, Ceramic has three primary networks: mainnet, Clay Testnet, and dev unstable.</p>","title":"Networks"},{"location":"learn/glossary/#mainnet","text":"<p>Mainnet is the Ceramic network used for production deployments. For more information on mainnet, see the Networks page.</p>","title":"Mainnet"},{"location":"learn/glossary/#clay-testnet","text":"<p>Clay Testnet is a Ceramic network used by the community for application prototyping, development, and testing purposes. Ceramic core devs also use Clay for testing official protocol release candidates. For more information on Clay Testnet, see the Networks page.</p>","title":"Clay Testnet"},{"location":"learn/glossary/#dev-unstable","text":"<p>Dev Unstable is a Ceramic network used by Ceramic core protocol developers for testing new protocol features and the most recent commits on the <code>develop</code> branch of js-ceramic. It should be considered unstable and highly experimental.</p>","title":"Dev Unstable"},{"location":"learn/glossary/#underlying-technologies","text":"","title":"Underlying technologies"},{"location":"learn/glossary/#ipfs","text":"<p>IPFS is the Interplanetary File System. Simply put, IPFS is a way to address static content using CIDs and to discover this content over a peer-to-peer network of nodes. Ceramic relies on IPFS for storing the commits that make up streams and discovering this data over the network.</p>","title":"IPFS"},{"location":"learn/glossary/#cid","text":"<p>A CID (content identifier) is an immutable identifier for a discrete piece of static content stored on IPFS. CIDs are essentially a hash of the content along with metadata that describes how the content is encoded. Ceramic streams consist of multiple CIDs, encoded using dag-jose (and other formats such as dag-cbor), and linked together using IPLD.</p>","title":"CID"},{"location":"learn/glossary/#ipld","text":"<p>IPLD (Interplanetary Linked Data) is the data structures layer of IPFS. It is used to link multiple CIDs together into higher-level linked-data structures. Ceramic uses IPLD to create the data structures for streams.</p>","title":"IPLD"},{"location":"learn/glossary/#dagjose","text":"<p>DagJOSE is a codec for IPLD which stores content in IPFS using IETF's JOSE (JSON object signing and encryption) format. With DagJOSE, each data object actually consists of two separate but linked CIDs. It supports both signed and encrypted objects. JWS is used for signed objects and it encodes the payload as a CID, which means that the actual payload is a separate IPLD object. JWE is used for encrypted objects, and it requires the ciphertext to be a CID in order to not leak the full cleartext. A separate inline CID is used to encode the entire cleartext. For more information refer to the DagJOSE spec.</p>","title":"DagJOSE"},{"location":"learn/glossary/#libp2p","text":"<p>Libp2p is the peer-to-peer networking protocol that is used by Ceramic. It is included as part of the IPFS stack. Ceramic relies on libp2p for discovering data over the network and communicating between nodes. Libp2p is also used by other major decentralized platforms such as Ethereum (Eth2) and Polkadot.</p>","title":"Libp2p"},{"location":"learn/glossary/#ethereum","text":"<p>Ethereum is the world's leading public, permissionless smart contract blockchain platform. Ceramic uses Ethereum for generating the timestamps contained within anchor commits.</p>","title":"Ethereum"},{"location":"learn/how-it-works/","text":"<p>Ceramic decentralizes application databases, making data universally composable and reusable across applications. The network consists of three core parts: a highly-scalable, decentralized infrastructure for data availability and consensus, a marketplace of community-created data models, and a suite of standard APIs for storing, updating, and retrieving data from those models.</p>","title":"How it works"},{"location":"learn/how-it-works/#core-components","text":"<p>The Ceramic network consists of three core components:</p> <ol> <li>Scalable, decentralized data infrastructure</li> <li>Data models marketplace</li> <li>Open APIs for data storage, update, and retrieval</li> </ol>","title":"Core components"},{"location":"learn/how-it-works/#scalable-decentralized-data-infrastructure","text":"<p>The most foundational layer of Ceramic is its scalable, decentralized data network. The Ceramic network consists of a collection of permissionless nodes that work together to provide data availability for all states stored on the network, and work to come to consensus about those states every time there is a new transaction.</p> <p>However, unlike Layer 1 blockchains designed to keep track of state for financial applications such as tokens, Ceramic is specifically designed to keep track of state for high-throughput data applications such as decentralized social networks, decentralized identity, crypto gaming, reputation systems, etc. In this way, Ceramic acts as a global, highly-scalable decentralized database that every application in the world can build on.</p> <p>To achieve scale, Ceramic makes a few opinionated decisions on the data structure of its network. The most important is that in Ceramic, there is no notion of state that can be shared between accounts. Every piece of state is owned only by the account that created it, and no account can modify anyone else\u2019s states, though any account can link to a piece of state owned by another account.</p> <p>On Ceramic, every account has a collection of mutable data objects, called streams, that only they as the owner of those streams, can write to. The content stored in each stream is arbitrary, and can reference content in anyone else\u2019s stream. Note that this does not preclude compute. Developers can write functions, called streamcode, that define how these streams can be updated and what actions they perform upon each new update.</p> <p>This architecture untangles state between users, allowing the system to scale horizontally very cleanly. You can imagine that accounts 1 - 1,000,000 are replicated on one set of Ceramic nodes, and accounts 1,000,001 - 2,000,000 are replicated on another. Theoretically, the network can be sharded all the way down to each individual user if needed without breaking composability. In order to ensure state verifiability and composability between user shards, Ceramic relies on a merkle tree data structure that aggregates transactions across all users, allowing any any account to verify the integrity of anyone else\u2019s streams at any time.</p>","title":"Scalable, decentralized data infrastructure"},{"location":"learn/how-it-works/#data-models-marketplace","text":"<p>The second core component of Ceramic is its vibrant ecosystem of open source data models created by the community, which serve to unlock cross-application data composability. Data models are a novel abstraction that unify how similar types of applications store and retrieve state from each individual user on the network. For example, you can imagine that every decentralized Twitter implementation would run on a few shared data models: one for each user\u2019s tweets, one for their social graph, one for their DMs, etc. By adopting the same underlying data models, applications are able to natively interoperate on the same data.</p>  <p>You can compare Ceramic\u2019s use of data model standards to the use of token standards for financial ledgers. On Ethereum, for example, the introduction of the ERC-20 fungible token and ERC-721 non-fungible token standards have given rise to entire ecosystems of tokens and financial applications that natively interoperate. Ceramic brings this same concept to data.</p>  <p>Ceramic takes a community-driven approach to creating these data models, allowing any developer to easily define, share, and reuse their models with other developers in the ecosystem. As more data models are created by the community, we will see a continuous expansion in the quantity and variety of applications that are built with composable data.</p> <p>Composability done this way also makes the developer experience better. Building an application on Ceramic looks like browsing a marketplace of data models, plugging them into your app, and automatically gaining access to all data on the network that\u2019s stored in these models. No longer will every single developer need to worry about bootstrapping their application with their own siloed users and data, making it easier than ever to go from idea to implementation.</p>","title":"Data models marketplace"},{"location":"learn/how-it-works/#open-apis","text":"<p>The final core component of Ceramic is its permissionless, open APIs for storing, modifying, and retrieving data from the network. By standardizing, generalizing, and opening these APIs up to every developer in the world, Ceramic enables developers to build on top of shared resources stored on the network without fear of centralization, censorship risk, or lock-in.</p>","title":"Open APIs"},{"location":"learn/networks/","text":"<p>Networks are collections of Ceramic nodes that share specific configurations and communicate over dedicated libp2p topics. Networks are discrete from one another. Streams that exist on one network are not discoverable on or portable to another.</p>","title":"Networks"},{"location":"learn/networks/#public-networks","text":"<p>Ceramic has three public networks that you can use when building applications: Mainnet, Clay Testnet, and Dev Unstable.</p>","title":"Public networks"},{"location":"learn/networks/#mainnet","text":"<p>Mainnet is the main public network used for production deployments on Ceramic. Ceramic's mainnet nodes communicate over the dedicated <code>/ceramic/mainnet</code> libp2p topic and use Ethereum's mainnet blockchain (<code>EIP155:1</code>) for generating timestamps used in anchor commits for streams. Mainnet is currently running and anyone can openly query data from streams on mainnet using the community mainnet gateway, but deployments that require writing data to the network are restricted to those projects on the mainnet early launch program (ELP) waitlist. If you want to write data to mainnet, sign up for ELP here. Over time, we will fully open mainnet to all applications.</p>","title":"Mainnet"},{"location":"learn/networks/#clay-testnet","text":"<p>Clay Testnet is a public Ceramic network used by the community for application prototyping, development, and testing purposes. Ceramic core devs also use Clay for testing official protocol release candidates. While we aim to maintain a high level of quality on the Clay testnet that mirrors the expectations of Mainnet as closely as possible, ultimately the reliability, performance, and stability guarantees of the Clay network are lower than that of Mainnet. Because of this, the Clay network should not be used for applications in production. Clay nodes communicate over the dedicated <code>/ceramic/testnet-clay</code> libp2p topic and use Ethereum's Rinkeby and Ropsten testnet blockchains for generating timestamps used in anchor commits for streams. Clay is openly available for anyone to use now.</p>","title":"Clay Testnet"},{"location":"learn/networks/#dev-unstable","text":"<p>Dev Unstable is a public Ceramic network used by Ceramic core protocol developers for testing new protocol features and the most recent commits on the develop branch of <code>js-ceramic</code>. It should be considered unstable and highly experimental; only use this network if you want to test the most cutting edge features, but expect issues. Dev Unstable nodes communicate over the dedicated <code>/ceramic/dev-unstable</code> libp2p topic and use Ethereum's Rinkeby and Ropsten testnet blockchains for generating timestamps used in anchor commits for streams.</p>","title":"Dev Unstable"},{"location":"learn/networks/#private-networks","text":"<p>You can also prototype applications on Ceramic by running the protocol in a local environment completely disconnected from other public nodes.</p>","title":"Private networks"},{"location":"learn/networks/#local","text":"<p>Local is a private test network used for the local development of Ceramic applications. Nodes connected to the same local network communicate over a randomly-generated libp2p topic <code>/ceramic/local-$(randomNumber)</code> and use a local Ethereum blockchain provided by Truffle's Ganache for generating timestamps used in anchor commits for streams.</p>","title":"Local"},{"location":"learn/use-cases/","text":"<p>Explore the many ways your project or business can leverage Ceramic's decentralized data streaming platform. Ceramic is a general-purpose protocol, so this list is definitely non-exhaustive; it's meant to serve as a starting point for ideation. The use cases on this list are not mutually exclusive and many Ceramic integrations will make use of more than one.</p>","title":"Use Cases"},{"location":"learn/use-cases/#decentralized-identity","text":"<p>Build secure applications using decentralized identities and portable, user-controlled data storage. Ceramic is home to the Identity Index protocol which provides a robust, flexible, and standards-based decentralized identity system that can serve as the cornerstone of any Web3 application. Building with the Identity Index protocol allows users to control their identities and data in a manner independent from any single application or platform, while allowing developers to build data-rich applications without the liability of custodying user data on a centralized server or the poor user experience of forcing users to recreate the same data on every application. Identities are based on W3C standards and can be used with wallets from many different blockchains and Web3 platforms.</p> <ul> <li>Decentralized identifiers (DIDs)</li> <li>Aggregated and cross-chain identities</li> <li>Web3: Connect wallets from any L1 or L2 protocol</li> <li>Web2: Link social accounts from any platform</li> <li>User profiles</li> <li>Social graphs</li> <li>Data storage</li> <li>Reputation systems</li> </ul>","title":"Decentralized identity"},{"location":"learn/use-cases/#decentralized-databases","text":"<p>Replace your database backend or local storage and store/host all of your content in mutable, decentralized streams.</p> <ul> <li>User data and user-generated content</li> <li>User activity and history</li> <li>Application data</li> <li>Application state and other cookie-like content</li> <li>Cross-device local storage</li> </ul>","title":"Decentralized databases"},{"location":"learn/use-cases/#evolutionary-files","text":"<p>Store editable, version-controlled files, documents, and other media on IPFS that maintains a tamper-proof and auditable history without needing external services to compute state changes, enforce permissions, or keep track of changing CIDs. Also make these files publicly available and discoverable over a global network.</p> <ul> <li>Mutable NFT files</li> <li>JSON documents</li> <li>JSON schemas</li> <li>Arbitrary metadata</li> <li>Verifiable credentials</li> </ul>","title":"Evolutionary files"},{"location":"learn/use-cases/#multi-user-applications","text":"<p>Leverage the unique features and properties of Ceramic to create permissionless social networks where content is decentralized and owned by users instead of platforms.</p> <ul> <li>Social media</li> <li>Community platforms</li> <li>Governance forums</li> </ul>","title":"Multi-user applications"},{"location":"learn/use-cases/#decentralized-publications","text":"<p>Publish and host content on a decentralized, censorship-resistant platform where data can be made globally available, authorship can be verified, links never rot, and each piece of content can be updated by its creator while still maintaining a tamper-proof audit trail of changes.</p> <ul> <li>Blogging platforms</li> <li>News media and publications</li> </ul>","title":"Decentralized publications"},{"location":"learn/use-cases/#cross-application-data-sharing","text":"<p>On Ceramic, all data is published to the open web where it's easy to share verifiable information between different organizations and applications in real-time without worrying about correctness or dealing with centralized servers and one-off API integrations.</p> <ul> <li>Cross-application data</li> <li>Cross-organizational data</li> <li>Enterprise system of record (SOR)</li> </ul>","title":"Cross-application data sharing"},{"location":"learn/use-cases/#semantic-web","text":"<p>Link multiple streams together to form a graph of relationships between verifiable data objects that can each individually evolve without breaking the graph.</p>","title":"Semantic web"},{"location":"learn/use-cases/#remixable-content","text":"<p>Fork and remix any streams on the network into entirely new creations. No permission needed.</p>","title":"Remixable content"},{"location":"learn/welcome/","text":"","title":"The Ceramic network"},{"location":"learn/welcome/#ceramic-is-a-decentralized-network-for-composable-data","text":"<p>Ceramic makes building applications with composable Web3 data as easy as browsing a marketplace of data models, plugging them into your app, and storing, updating, and retrieving data from those models. When different applications reuse the same data models, their data is automatically interoperable. By decentralizing application databases, Ceramic makes data composable and reusable across all applications.</p> <p></p> <p></p>","title":"Ceramic is a decentralized network for composable data."},{"location":"learn/welcome/#getting-started","text":"","title":"Getting started"},{"location":"learn/welcome/#build-applications-with-ceramic","text":"<p>Connect your app to Ceramic using a development framework or client library.</p>  <p>Frameworks provide a great way to get started quickly, while clients provide greater flexibility but require a lower-level understanding of how the network functions.</p>   <p>Don't know what to build with composable data? Check out these data models to get your creativity flowing.</p>","title":"Build applications with Ceramic"},{"location":"learn/welcome/#operate-the-ceramic-network","text":"<p>Provide storage, compute, and bandwidth to the network by running a node.</p>  <p>Today there are no tokenized incentives for running a Ceramic node, but by running a node you can ensure the data for your app remains available while helping contribute to the network's decentralization.</p>","title":"Operate the Ceramic network"},{"location":"learn/welcome/#join-the-community","text":"<ul> <li> <p>Join the Discord to ask questions and engage with the community</p> </li> <li> <p>Follow us on Twitter for updates</p> </li> <li> <p>Read the blog for news, announcements, and tutorials</p> </li> <li> <p>Watch the Youtube channel for videos and presentations</p> </li> <li> <p>Work on Ceramic through open roles at 3Box Labs</p> </li> </ul>","title":"Join the community"},{"location":"learn/advanced/consensus/","text":"<p>This page describes the consensus and conflict resolution model for streams on Ceramic.</p>","title":"Consensus"},{"location":"learn/advanced/consensus/#overview","text":"<p>Ceramic maintains consensus for individual data streams. This is in contrast to traditional blockchain systems where consensus is maintained on the entire global ledger, or to distributed database systems where consensus is maintained for the entire database. Maintaining consensus at the level of individual data objects allows Ceramic to be much more scalable, as nodes only need to track information for the Streams that they care about, rather than for all Streams on the network. This also allows different Streams to use different consensus models - allowing for a flexible and extensible consensus system that can evolve over time and be tailored to specific use cases. In Ceramic, consensus is handled by individual StreamTypes, meaning new StreamTypes introduced in the future may also introduce new consensus mechanisms.</p>  <p>Warning</p> <p>This page contains lots of information about how Ceramic handles reaching consensus on Streams, but the most important part for most developers to understand is the semantics around simultaneous updates.</p>","title":"Overview"},{"location":"learn/advanced/consensus/#existing-consensus-model","text":"<p>Most of the existing StreamTypes today use diffs encoded with json-patch to represent state transitions, and use the Earliest Anchor Wins rule for conflict resolution.</p>","title":"Existing consensus model"},{"location":"learn/advanced/consensus/#json-patch-diffs","text":"<p>In the existing TileDocument StreamType, updates to the document's contents are encoded using json-patch. The resulting diff goes into a Ceramic Commit and can be used to transform the stream's contents from a previous state to a new state. Syncing a TileDocument involves getting the initial state from the genesis commit, then applying the json-patch diffs from each subsequent commit to the content, one at a time, until the end of the stream's commit log, at which point you have the current state of the content.</p>","title":"Json-patch diffs"},{"location":"learn/advanced/consensus/#write-conflicts","text":"<p>Sometimes, two conflicting logs for the same Stream might exist simultaneously. This can happen when the controller of the stream makes conflicting updates to the same stream on different devices or via different applications. It can also happen if a single Stream has multiple end users who are able to author updates to the stream (either because the stream has multiple controller DIDs, or because the DID method being used as the stream controller allows multiple users/private keys to sign messages on its behalf, like the did:safe DID method, for example).</p> <p>Whatever the reason for the diverging logs for a single Stream, it is important that all nodes can come to agreement (consensus) as to which is the correct log for that Stream. Most StreamTypes currently rely on the Earliest Anchor Wins strategy for resolving conflicts between stream logs.</p>","title":"Write conflicts"},{"location":"learn/advanced/consensus/#earliest-anchor-wins","text":"<p>Updates to Ceramic Streams are periodically anchored onto a blockchain (currently Ethereum). This immutable proof-of-publication is used to get a trustless timestamp for when the update occurred. This allows us to safely compare the timestamps associated with different branches of a Stream's log to determine which update happened first. When there are conflicting histories for a Stream log and one branch was anchored earlier than the other, the branch that was anchored earlier wins. If one branch was anchored and the other not, then the branch that was anchored is prefered.</p>","title":"Earliest Anchor Wins"},{"location":"learn/advanced/consensus/#longest-update-chain","text":"<p>The Earliest Anchor Wins rule can solve many problems related to coming to consensus on a Stream's state, but still has issues if multiple updates are created quickly. Since anchors only happen periodically (depends on the anchor service being used, but currently twice a day for the anchor service that 3Box Labs operates for Ceramic mainnet), multiple updates can be created and published before any of them get anchored. In that case, we still need to come to consensus on the current state. When there are conflicting logs for a stream neither of which have been anchored, we prefer whichever log is longer. This ensures that the most active history with the most updates is preserved. If there are conflicting unanchored branches that have the same length, then the system picks the winning log arbtrarily, but deterministically, to ensure that all nodes come to agreement on the same log, even if there is no good information available to use to decide which to prefer. This can result writes being lost in certain rare instances where there are conflicting updates published within a few seconds of each other.</p>","title":"Longest update chain"},{"location":"learn/advanced/consensus/#simultaneous-updates","text":"<p>Ceramic Streams today are updated using a read-modify-write approach. This means that write conflicts can result in writes being lost in some specific scenarios. Consider an app that wants to add a new entry to an array contained within a TileDocument stream. The app loads a stream, gets the current contents of the Stream (including the current value of the array to be updated), adds an element into the array locally, then issues an update to Ceramic with the new contents. The code for this may look something like:</p> <pre><code>const streamId = '&lt;...&gt;' // A StreamID for an existing Ceramic Stream\nconst doc = await TileDocument.load(ceramic, streamId)\n// doc's content contains a 'friends' array field with the value ['mohsin', 'liz']\nconst content = doc.content\ncontent.friends.push('sergey')\nawait doc.update(content)\n</code></pre> <p>If, while this code is running, another update is made to this same Stream (using code that looks much the same but say adding 'stephanie' instead of 'sergey'), then this code may not be aware of that update when the new state is published to the network via the <code>doc.update</code> call. You could wind up with two conflicting updates published to the network, one adding 'sergey' to the list, the other adding 'stephanie' to the list. In this case the network will eventually come to consensus about which update to keep, but which one is chosen is arbitrary, and the rejected update will be lost forever. This means that there is a chance that the final array winds up being <code>['mohsin', 'liz', 'sergey']</code>, and it is equally possible that the final array winds up being <code>['mohsin', 'liz', 'stephanie']</code>, with no way to tell in advance which update will win out.</p> <p>This behavior is usually not a problem for Ceramic, since most Ceramic streams are controlled by a single end user, who will not be making multiple simultaneous updates to a given stream at the same time. This does mean, however, that Ceramic is not well suited at the moment to applications that depend on allowing multiple end users to update a single stream simultaneously. Note that so long as updates happen more than approximately 30 seconds apart, that should be enough time for the updates to be shared across the entire Ceramic network and prevent conflicts like these from occurring. Also, future StreamTypes may not be subject to this issue, as future StreamTypes will be able to use different consensus mechanisms better suited to handling simultaneous updates.</p>","title":"Simultaneous updates"},{"location":"learn/advanced/consensus/#future-improvements","text":"<p>In the future, Ceramic plans to offer StreamTypes that use CRDTs to encode updates to Streams, which will allow simultaneous updates to be merged automatically without conflict. Such plans, however, are currently still in the research phase.</p>","title":"Future improvements"},{"location":"learn/advanced/consensus/#further-reading","text":"<p>If you want more, lower-level details about how Ceramic maintains consensus on Stream logs, you can read the specification.</p>","title":"Further reading"},{"location":"learn/advanced/data-availability/","text":"<p>This page describes the data persistence and data availability model for streams on Ceramic.</p>","title":"Data Availability"},{"location":"learn/advanced/data-availability/#overview","text":"<p>Stream data can be divided into two main categories: commits and state. While there is some overlap, these two types of data have enough difference that they should be considered separately when planning how to persist and host your streams. All commits and state for a given stream must be available when performing writes or queries on that stream; if not, your client will return an error. This error will disappear once all data comes back online. In the event that one or more commits for the given stream were permanently lost due to improper persistence management, then this stream will be corrupted and the error will not disappear.</p>","title":"Overview"},{"location":"learn/advanced/data-availability/#stream-commits","text":"<p>Every stream is an event log consisting of one of more commits, and each commit contains of at least two IPLD objects. Collectively these commits store the data that makes up the content of a stream.</p>","title":"Stream commits"},{"location":"learn/advanced/data-availability/#caching","text":"<p>Ceramic nodes have a built-in caching mechanism for short-term storage of commits. Whenever a Ceramic node performs a write or a query on a stream, all commits for that stream are first synced from the network and automatically loaded into that node's in-memory cache. This results in the most popular streams being replicated the most, providing some level of data persistence and availability. However to preserve disk space and node resources, in-memory cache defaults to a limit of 500 streams (but can be configured to any number). Once that number is reached, the oldest streams will be evicted from the node's cache in order to make room for newer ones.</p> <p>If the node happens to shut down or restart, the cache will be cleared. Without sufficient replication across other nodes due to popularity or additional data persistence measures prior to a shutdown, streams that only exist in-memory will be lost forever. Therefore, cache-only is not a dependable source of data availability for a longer period than a specific session.</p>","title":"Caching"},{"location":"learn/advanced/data-availability/#pinning","text":"<p>Pinning provides a more long-lived mechanism of data persistence for commits. Pinning is a process for instructing a Ceramic node to explicitly host (i.e. \"pin\") the commits for a specific stream. Since commits are stored in IPLD, Ceramic nodes already contain a bundled IPFS node which is where this pinning occurs. IPFS nodes can pin all commits for any stream which is accessible over the Ceramic network to which it is connected. Ceramic pinning can also work using an external IPFS node instead of the bundled internal version.</p> <p>If developers want the easiest way to make their streams persistent beyond a single session and more resilient against data loss, then pinning is the right option. Ceramic nodes can pin an unlimited number of streams. However, note that if only one IPFS node is pinning a given stream and it disappears forever or gets corrupted, then that stream will be lost. Also, if only one node is pinning a stream (and no other Ceramic nodes have it in cache) and that node goes offline, then that stream will be unavailable to others. Therefore, for improved resilience and data availability it is best to have multiple IPFS nodes running in different envitonments pinning the same streams.</p>  <p>See the Pinning guide for instructions on how to pin streams on a Ceramic node.</p>","title":"Pinning"},{"location":"learn/advanced/data-availability/#archiving","text":"<p>Archiving is the most durable, long-lived form of persistence for commits. In addition to caching and pinning, Ceramic developers may also configure their node to connect to an external service for archiving all commits that make up a stream. The exact guarantees provided by archiving differ with each implementation and service provider. For example, archiving to Filecoin provides crypto-economically guaranteed data availability with a pay-as-you-go model, while archiving to Arweave provides crypto-economically guaranteed data availability with a one-time payment model. Conversely, archiving to Amazon S3 provides a simpler model however Amazon cannot guarantee that your data will always be available (for example you could stop paying your bill), but the storage is still more resilient than using pinning and caching only.</p>","title":"Archiving"},{"location":"learn/advanced/data-availability/#stream-state","text":"<p>In addition to the commit log mentioned above which is stored in IPFS, every stream has a state which is not stored in IPFS but rather is collectively tracked, persisted, and made available by all Ceramic nodes that are caching and/or pinning the stream. Both the complete commit history and the state are needed to successfully load and interact with streams.</p>","title":"Stream state"},{"location":"learn/advanced/data-availability/#caching_1","text":"<p>State caching works the same as commit caching.</p>","title":"Caching"},{"location":"learn/advanced/data-availability/#pinning_1","text":"<p>State pinning works the same as commit pinning, except state pinning does not occur on IPFS. State pinning simply occurs in a database internal to the Ceramic node.</p>","title":"Pinning"},{"location":"learn/advanced/data-availability/#archiving_1","text":"<p>Ceramic is working on a durable, decentralized state store which will be used to persist and guarantee availability for the state of streams. This is on the roadmap. It's not critical to the immediate use of Ceramic, but will serve to make state more resilient and available. In the meantime, Ceramic supports archiving state to Amazon S3, for an option with more durability and reliability than the local database used by default.</p>","title":"Archiving"},{"location":"learn/advanced/overview/","text":"<p>Ceramic is a public, permissionless, open source protocol that provides computation, state transformations, and consensus for all types of data structures stored on the decentralized web. Ceramic's stream processing enables developers to build secure, trustless, censorship-resistant applications on top of dynamic information without trusted database servers.</p> <p>This overview introduces how:</p> <ul> <li>Decentralized content computation gives rise to a new era of open source information</li> <li>Stream processing provides an appropriate framework for dynamic, decentralized content</li> <li>You can use Ceramic to replace your database with a truly decentralized alternative</li> </ul>  <p>To skip ahead and get started building, try the Playground to demo Ceramic in a browser application, the Quick Start guide to learn the basics using the Ceramic CLI, or follow the Installation page to integrate Ceramic into your project.</p>","title":"Overview"},{"location":"learn/advanced/overview/#the-internet-of-open-source-information","text":"<p>At its core, the internet is a collection of applications running on stateful data sources \u2013 from identity systems and user tables to databases and feeds for storing all kinds of content generated by users, services, or machines.</p> <p>Most of the information on today's internet is locked away on application-specific database servers designed to protect data as a proprietary resource. Acting as trusted middlemen, applications make it difficult and opaque for others to access this information by requiring explicit permissions, one-off API integrations, and trust that returned state is correct. This siloed and competitive environment results in more friction for developers and worse experiences for users.</p> <p>Along other dimensions, the web has rapidly evolved into a more open source, composable, and collaborative ecosystem. We can observe this trend in open source software enabled by Git's distributed version control and in open source finance enabled by blockchain's double-spend protection. The same principles of open source have not yet been applied to content.</p> <p>The next wave of transformative innovation will be in applying the same open source principles to the world's information, unlocking a universe of content that can be frictionlessly shared across application or organizational boundaries. Achieving this requires a decentralized computation network designed specifically for content with flexibility, scalability, and composability as first class requirements.</p>","title":"The internet of open source information"},{"location":"learn/advanced/overview/#decentralized-content-computation","text":"<p>Open sourcing the content layer for applications requires deploying information to a public, permissionless environment where files can be stored, computation can be performed, state can be tracked, and others can easily access content.</p> <p>Advancements in other Web3 protocols have already achieved success in decentralized file storage. As a universal file system for the decentralized web, IPFS (including IPLD and Libp2p) provides an extremely flexible content naming and routing system. As a storage disk, durable persistence networks (such as Filecoin, Arweave, and Sia) ensure that the content represented in IPFS files are persisted and kept available. This stack of Web3 protocols performs well for storing static files, but on its own lacks the computation and state management capacity for more advanced database-like features such as mutability, version control, access control, and programmable logic. These are required to enable developers to build fully-featured decentralized applications.</p> <p>Ceramic enables static files to be composed into higher-order mutable data structures, programmed to behave in any desired manner, and whose resulting state is stored and replicated across a decentralized network of nodes. Ceramic builds upon and extends the IPFS file system and underlying persistence networks, as well as other open standards in the decentralized ecosystem, with a general-purpose decentralized content computation substrate. Due to Ceramic's permissionless design and unified global network, anyone in the world can openly create, discover, query, and build upon existing data without needing to trust a centralized server, integrate one-off APIs, or worry if the state of information being returned is correct.</p>","title":"Decentralized content computation"},{"location":"learn/advanced/overview/#streams","text":"<p>Ceramic's decentralized content computation network is modeled after various stream processing frameworks found in Web2. In these types of systems, events are ingested, processed as they arrive, and the resulting output is applied to a log. When queried and reduced, this log represents the current state of a piece of information. This is an appropriate framework for conceptualizing how dynamic information should be modeled on the decentralized web. Furthermore because the function that processes incoming events on any particular stream can be custom written with logic for any use case, it provides the general-purpose flexibility and extensibility needed to represent the diversity of information that may exist on the web.</p> <p>On Ceramic, each piece of information is represented as an append-only log of commits, called a Stream. Each stream is a DAG stored in IPLD, with an immutable name called a StreamID, and a verifiable state called a StreamState. Streams are similar in concept to Git trees, and each stream can be thought of as its own blockchain, ledger, or event log.</p>","title":"Streams"},{"location":"learn/advanced/overview/#streamtypes","text":"<p>Each stream must specify a StreamType, which is the processing logic used by the particular stream. A StreamType is essentially a function that is executed by a Ceramic node upon receipt of a new commit to the stream that governs the stream's state transitions and resulting output. StreamTypes are responsible for enforcing all rules and logic for the stream, such as data structure, content format, authentication or access control, and consensus algorithm. If an update does not conform to the logic specified by the StreamType, the update is disregarded. After applying a valid commit to the stream, the resulting StreamState is broadcast out to the rest of the nodes on the Ceramic Network. Each of the other nodes that are also maintaining this stream will update their StreamState to reflect this new transaction.</p> <p>Ceramic's flexible StreamTypes framework enables developers to deploy any kind of information that conforms to any set of arbitrary rules as a stateful stream of events. Ceramic clients come pre-packaged with a standard set of StreamTypes that cover a wide range of common use cases, making it easy to get started building applications:</p> <ul> <li>Tile Document: a StreamType that stores a JSON document, providing similar functionality as a NoSQL document store. Tile Documents are frequently used as a database replacement for identity metadata (profiles, social graphs, reputation scores, linked social accounts), user-generated content (blog posts, social media, etc), indexes of other StreamIDs to form collections and user tables (IDX), DID documents, verifiable claims, and more. Tile Documents rely on DIDs for authentication and all valid updates to a stream must be signed by the DID that controls the stream.</li> <li>CAIP-10 Link: a StreamType that stores a cryptographically verifiable proof that links a blockchain address to a DID. A DID can have an unlimited number of CAIP-10 Links that bind it to many different addresses on many different blockchain networks. CAIP-10 Links also rely on DIDs for authentication, the same as Tile Documents.</li> <li>Custom: You can implement your own StreamType and deploy it to your Ceramic node if the pre-packaged StreamTypes are not suitable for your use case.</li> </ul>","title":"StreamTypes"},{"location":"learn/advanced/overview/#authentication","text":"<p>StreamTypes are able to specify their authentication requirements for how new data is authorized to be added to a particular stream. Different StreamTypes may choose to implement different authentication requirements. One of the most powerful and important authentication mechanisms that Ceramic StreamTypes support is DIDs, the W3C standard for decentralized identifiers. DIDs are used by the default StreamTypes (Tile Documents and CAIP-10 Links).</p> <p>DIDs provide a way to go from a globally-unique, platform-agnostic string identifier to a DID document containing public keys for signature verification and encryption. Ceramic is capable of supporting any DID method implementation. Below, find the DID methods that are currently supported by Ceramic:</p> <ul> <li>3ID DID Method: A DID method that uses Ceramic's Tile Document StreamType to represent a mutable DID document. 3IDs are typically used for end-user accounts. When 3IDs are used in conjunction with the Identity Index protocol and the 3ID Keychain (as is implemented in 3ID Connect), a 3ID can easily be controlled with any number of blockchain accounts from any L1 or L2 network. This provides a way to unify a user's identity across all other platforms.</li> <li>Key DID Method: A DID method statically generated from any Ed25519 key pair. Key DIDs are typically used for developer accounts. Key DID is lightweight, but the drawback is that its DID document is immutable and has no ability to rotate keys if it is compromised.</li> <li>NFT DID Method (coming soon): A DID method for any NFT on any blockchain. The DID document is statically generated from on-chain data. The DID associated to the blockchain account of the asset's current owner (using CAIP-10 Links) is the only entity authorized to act on behalf of the NFT DID, authenticate in DID-based systems, and make updates to streams or other data owned by the NFT DID. When owenership of the NFT changes, so does the controller permissions.</li> <li>Safe DID Method (coming soon): A DID method for a Gnosis Safe smart contract on any blockchain. Typically used for organizations, DAOs, and other multi-sig entities.</li> </ul>","title":"Authentication"},{"location":"learn/advanced/overview/#ceramic-network","text":"<p>The Ceramic Network is a decentralized, worldwide network of nodes running the Ceramic protocol that communicate over a dedicated topic on the Libp2p peer-to-peer networking protocol. Ceramic is able to achieve maximum horizontal scalability, throughput, and performance due to its unique design.</p>","title":"Ceramic Network"},{"location":"learn/advanced/overview/#sharded-execution-environment","text":"<p>Unlike traditional blockchain systems where scalability is limited to a single global virtual execution environment (VM) and the state of a single ledger is shared between all nodes, each Ceramic node acts as an individual execution environment for performing computations and validating transactions on streams \u2013 there is no global ledger. This \"built-in\" execution sharding enables the Ceramic Network to scale horizontally to parallelize the processing of an increasing number of simultaneous stream transactions as the number of nodes on the network increases. Such a design is needed to handle the scale of the world's data, which is orders of magnitude greater than the throughput needed on a financial blockchain. Another benefit of this design is that a Ceramic node can perform stream transactions in an offline-first environment and then later sync updates with the rest of the network when it comes back online.</p>","title":"Sharded execution environment"},{"location":"learn/advanced/overview/#global-namespace","text":"<p>Since all nodes are part of the same Ceramic Network, every stream on Ceramic exists within a single global namespace where it can be accessed by any other node or referenced by any other stream. This creates a public data web of open source information.</p>","title":"Global namespace"},{"location":"learn/advanced/overview/#additional-node-responsibilities","text":"<p>In addition to executing stream transactions according to StreamType logic, Ceramic nodes also maintain a few other key responsibilities:</p> <ul> <li>StreamState storage: A Ceramic node only persists StreamStates for the streams it cares to keep around, a process called \"pinning.\" Different nodes will maintain StreamStates for different streams, but multiple nodes can maintain the state of a single stream.</li> <li>Commit log storage: A Ceramic node maintains a local copy of all commits to the streams it is pinning.</li> <li>Persistence connectors: Ceramic nodes can optionally utilize an additional durable storage backend for backing up commits for streams it is pinning. This can be any of the persistence networks mentioned above, including Filecoin, Arweave, Sia, etc. (coming soon).</li> <li>Query responses: Ceramic nodes respond to stream queries from clients. If the node has the stream pinned it will return the response; if not, it will ask the rest of the network for the stream over libp2p and then return the response.</li> <li>Broadcasting transactions: When a Ceramic node successfully performs a transaction on a stream, it broadcasts this transaction out the rest of the network over libp2p so other nodes also pinning this stream can update their StreamState to reflect this new transaction.</li> </ul>","title":"Additional node responsibilities"},{"location":"learn/advanced/overview/#clients","text":"<p>Clients provide standard interfaces for performing transactions and queries on streams, and are installed into applications. Clients are also responsible for authenticating users and signing transactions.</p> <p>Currently there are three clients for Ceramic. Additional client implementations can easily be developed in other programming languages:</p> <ul> <li>JS HTTP client: A lightweight JavaScript client which connects to a remote Ceramic node over HTTP. The JS HTTP client is recommended for application developers.</li> <li>JS Core client: A JavaScript client which also includes a full Ceramic node. The JS Core client is for those who want the maximum decentralization of running the full Ceramic protocol directly in a browser application.</li> <li>CLI: A command line interface for interacting with a Ceramic node.</li> </ul>","title":"Clients"},{"location":"learn/advanced/overview/#getting-started","text":"","title":"Getting started"},{"location":"learn/advanced/overview/#try-ceramic","text":"<p>To experience how Ceramic works in a browser application, try the Playground app.</p>","title":"Try Ceramic"},{"location":"learn/advanced/overview/#installation","text":"<p>Getting started with Ceramic is simple. Visit the Quick Start guide to learn the basics using the Ceramic CLI or follow the Installation page to integrate Ceramic into your project.</p>","title":"Installation"},{"location":"learn/advanced/overview/#tools-and-services","text":"<p>In addition to various standards referenced throughout this document, the Ceramic community has already begun delevoping many different open source protocols, tools, and services that simplify the experience of developing on Ceramic. Here are a few notable examples:</p> <ul> <li>3ID Connect: A authentication SDK for browser-based applications that allows your users to transact with Ceramic using their blockchain wallet.</li> <li>Identity Index (IDX): A protocol for decentralized identity that allows a DID to aggregate an index of all their data from across all apps in one place. IDX enables user-centric data storage, discovery, and interoperability. It is effectively a decentralized, cross-platform user table. IDX can reference all data source types, including Ceramic streams and other peer-to-peer databases and files.</li> <li>IdentityLink: A service that issues verifiable claims which prove a DID owns various other Web2 social accounts such as Twitter, Github, Discord, Discourse, Telegram, Instagram, etc. Once issued, claims are stored in the DID's Identity Index.</li> <li>Documint: A browser-based IDE for creating and editing streams.</li> <li>Tiles: An explorer for the Ceramic Network.</li> </ul>","title":"Tools and services"},{"location":"learn/advanced/privacy/","text":"<p>This page describes various privacy aspects of the Ceramic protocol. Measures we've taken so far, planned future measures, and future research directions.</p>","title":"Privacy"},{"location":"learn/advanced/privacy/#ceramic-protocol","text":"<p>The StreamType system is already quite flexible in terms of how streams can provide developers with privacy features.</p>","title":"Ceramic Protocol"},{"location":"learn/advanced/privacy/#default-properties-of-tile-and-caip10links","text":"<p>Currently if you create a TileDocument or Caip10Link stream any data put into it will be public by default. It's however possible to encrypt the content put into the stream by accessing the DID instance from Ceramic (<code>ceramic.did</code>) and using its encryption functionality as described in the How to store signed and encrypted data on IPFS blog post.</p>","title":"Default properties of Tile and Caip10Links"},{"location":"learn/advanced/privacy/#confidential-streams","text":"<p>A planned improvement to the TileDocument StreamType is to add confidentiality. This basically means that the content of each update to the stream would be encrypted by a symmetric key. Whenever a Ceramic node syncs the stream it would only be able to read the stream content if it has the symmetric key for this stream. Stream metadata such as which DID signed the update, in what order, and when it was anchored would still be public.</p> <p>A StreamType without history like DIDPublish could further improve the situation somewhat since nodes that sync the stream would not see historical update metadata.</p>","title":"Confidential streams"},{"location":"learn/advanced/privacy/#private-streams","text":"<p>A fully private stream would mean that all of the data and metadata is encrypted.</p> <p>One approach to this is the one taken by Textile ThreadsDB which separates the notion of a follow key and a content key. This allows certain nodes to read the metadata and pin the stream, but without seeing the content, while other nodes can't see anything at all into the stream. So essentially streams are still only confidential to the trusted set of peers that have the follow key.</p> <p>A better approach could be to use some sort of zero-knowledge proof system to keep track of the tip of a set of streams anonymously. This is still a completely open research topic but would likely add some overhead to the party reading the stream. One upside here would be that this system could operate completely trustlessly unlike Textile ThreadsDB.</p>","title":"Private streams"},{"location":"learn/advanced/security/","text":"<p>This page describes various security aspects of the Ceramic protocol and miscellaneous systems like 3ID Connect.</p>","title":"Security"},{"location":"learn/advanced/security/#ceramic-protocol","text":"<p>The main security properties that makes up Ceramic are cryptographic signatures, proof-of-publication (through blockchain anchors), and hash-linked data structures. Together these properties allows the construction of a verifiable data structure. In addition to this Ceramic relies on libp2p pubsub to gossip about stream updates.</p>","title":"Ceramic Protocol"},{"location":"learn/advanced/security/#stream-data-structure","text":"<p>In general streams are made up of commits which are linked together as a DAG using hash links. This data structure is represented using IPLD. Commits always contain some sort of proof, usually this is a signature or a proof-of-publication. When a Ceramic node syncs a stream this linked DAG of commits can be verified locally and thus be fully trusted.</p> <p>Signed commits are generally signed by the controller of the stream. Different StreamTypes may have different rules about how the signature should be encoded. The TileDocument StreamType uses dag-jose to encode signatures. This format is recommended to be used by any new StreamTypes.</p> <p>A proof-of-publication is a proof that some content was published at some point in time. This is achieved by publishing the hash of the content on a blockchain. These proofs can be made more cost effective by putting multiple content hashes as leaves in a merkle tree and only publishing the root. The proof-of-publication provides a definite ordering of events in a stream, which is useful when you want to do key revocation in a secure manner.</p> <p>The linked commit DAG provides a logical ordering of events which is useful when constructing streams that use CRDT type logic. For a detailed description of these benefits reference the Merkle-CRDTs paper.</p>","title":"Stream data structure"},{"location":"learn/advanced/security/#conflict-resolution-strategies","text":"<p>Different StreamTypes in Ceramic may have different conflict resolution strategies with different security properties.</p> <p>The earliest anchor rule solves any conflict in the history of a stream by picking the stream that was anchored at the earliest point in time. This enables keys to be securely revoked since someone that gains possession of an old key after it was revoked will be unable to produce a proof-of-publication that is earlier than the first anchor. This is used in the 3ID DID Method which registers a set of public keys associated to a DID URL, when the 3ID stream is updated with new public keys, revoking the old keys, an outside observer can be sure of the state of the 3ID without any secondary sources of information. 3IDs are built on top of the TileDocument stream type, and alternative DID methods could also be built on top of it.</p> <p>A drawback with the \"earliest anchor rule\" is that the controller of the stream can create anchored commits in secret and reveal them at a later point in time to change the history of the stream. There are various ways to mitigate this. One of them is to only allow anchor services that actively publish all created anchor commits when they are created.</p> <p>The latest nonce rule solves any conflict by simply picking the signed commit which includes the largest nonce. This strategy doesn't support key revocation, so the controller of a stream with this strategy can't be changed. Ceramic doesn't support this strategy yet, but it is required for StreamTypes like DIDPublish. In the future The Caip10Link StreamType may also be updated to use this strategy for efficiency reasons.</p>","title":"Conflict resolution strategies"},{"location":"learn/advanced/security/#network-gossip","text":"<p>Ceramic nodes use libp2p pubsub to gossip about stream tips. The two operations that happen in the gossip is publication of stream updates and queries for tips by nodes that load a specific stream. The main security consideration for a Ceramic node is that any new tip that comes in for a stream which it cares about could be a fake or invalid tip for that stream and thus needs to be verified.</p>","title":"Network gossip"},{"location":"learn/advanced/security/#dos-attack","text":"<p>A malicious node can spam the pubsub topic by sending a lot of messages. This may be randomly generated messages that are not even for valid streams, or it could be invalid tips for valid streams that get rejected by the stream update rules (the \"false log attack\" explained below). The main counter attack for this is to limit the amount of messages a single node can send by having an automated reputation system that disconnects from nodes which are spammy. No such reputation systems exists in ceramic today, though it is planned as a future improvement.</p>","title":"DoS attack"},{"location":"learn/advanced/security/#false-log-attack","text":"<p>A malicious node can spam nodes that pin specific streams by sending faulty commit logs. The unsuspecting node would sync the log of the stream and find it invalid, at which point the node would throw out the faulty log without applying it to its local copy of the stream's state. However, if the false log is long and the malicious node sends multiple of these it may cause a significant amount of overhead. The most simple countermeasure to this is to simply stop accepting tips from nodes which have proven to not be reliable. A more significant approach would be to build a StreamType that includes a recursive zero-knowledge proof that the log is indeed correctly associated with the given streamid.</p>","title":"False log attack"},{"location":"learn/advanced/security/#caip10link-clock-synchronization","text":"<p>Currently the Caip10Link streamtype relies on system time on the client machine to mitigate replay attacks. A new update to a Caip10Link stream is only valid if the proof includes a timestamp that is larger than the timestamp of the previous update. This presents a problem however if the users system time for some reason is incorrectly far into the future. Users would at this point be unable to prevent a replay attack using a proof created on this machine. The replay attack could be used to reset a Caip10Link to point to any DID it had previously been linked to. A possible workaround could be to switch to using a <code>nonce</code> which is always incremented by one, or include the <code>prev</code> pointer to the previous commit in the proof.</p>","title":"Caip10Link clock synchronization"},{"location":"learn/network/clients/","text":"<p>Ceramic is a decentralized network of nodes that run the Ceramic protocol.</p>","title":"Network Overview"},{"location":"learn/network/clients/#clients","text":"<p>Clients are software that provide API access to Ceramic nodes. They allow interactions with the Ceramic network.</p>","title":"Clients"},{"location":"learn/network/clients/#responsibilities","text":"","title":"Responsibilities"},{"location":"learn/network/clients/#api-interface","text":"","title":"API Interface"},{"location":"learn/network/clients/#authenticate-users","text":"","title":"Authenticate users"},{"location":"learn/network/clients/#sign-records","text":"","title":"Sign records"},{"location":"learn/network/clients/#add-more","text":"","title":"Add more"},{"location":"learn/network/clients/#client-implementations","text":"<ul> <li>HTTP Client</li> <li>JS Client</li> <li>CLI Client</li> </ul>","title":"Client Implementations"},{"location":"learn/network/clients/#nodes","text":"<p>Nodes are software that run the Ceramic protocol and form a peer-to-peer network with other nodes.</p>","title":"Nodes"},{"location":"learn/network/clients/#networking","text":"","title":"Networking"},{"location":"learn/network/clients/#network-connection","text":"<p>Nodes must specify which Ceramic network they are connecting to. This configuration allows the node to mesh with all other nodes connected to the same network.</p>","title":"Network connection"},{"location":"learn/network/clients/#gossip-updates","text":"<p>Nodes must specify which Ceramic network they are connecting to. This configuration allows the node to mesh with all other nodes connected to the same network.</p>","title":"Gossip updates"},{"location":"learn/network/clients/#query-responses","text":"<p>Nodes are responsible for responding to queries about any document that it has. If the node has the document in its cache it will respond directly, but if if doesn't have it, it will ask other nodes on the network for it using libp2p.</p>","title":"Query responses"},{"location":"learn/network/clients/#storage","text":"","title":"Storage"},{"location":"learn/network/clients/#loading-documents","text":"<p>Nodes can ask other nodes for a document and it will sync it from the network and load it in memory. This includes the entire document log (contents) and its most recent tip (state).</p>","title":"Loading documents"},{"location":"learn/network/clients/#cachingpinning-documents","text":"<p>Ceramic nodes use an instance of IPFS for short-term pinning/caching the documents that they care about. For each document that it cares about, a node will cache its document log and its tip. Nodes cache the Ceramic nodes come prepackaged with an internal IPFS node, but an externally run IPFS node may be used instead. (add something in here about garbage collection?)</p>","title":"Caching/Pinning documents"},{"location":"learn/network/clients/#persistence-coordination","text":"<p>Ceramic nodes may optionally specify one or more external service(s) for the long-term storage of documents. If specified, the node is responsible for forwarding document records to this service. Learn more about persistence options.</p>","title":"Persistence coordination"},{"location":"learn/network/clients/#transactions","text":"","title":"Transactions"},{"location":"learn/network/clients/#authentication","text":"<p>Nodes take a DID provider instance and allow that authenticated user to perform transactions.</p>","title":"Authentication (??)"},{"location":"learn/network/clients/#record-validation","text":"<p>Nodes receive records (from clients (or anchor services?)) and then validate that these records conform to the rules of the document's specified doctype.</p>","title":"Record validation"},{"location":"learn/network/clients/#record-application","text":"<p>Nodes apply only valid records to the document's document log. Invalid or malformed records are discarded.</p>","title":"Record application"},{"location":"learn/network/clients/#anchor-service-coordination","text":"<p>After applying a genesis record or signed record to the document log, nodes then send these records to the HTTP endpoint of an anchor service which anchors it in a blockchain. After successfully anchoring the record, the anchor service sends back an anchor record over libp2p which is then applied to the document log by the node.</p>","title":"Anchor service coordination"},{"location":"learn/network/clients/#conflict-resolution","text":"<p>Should this be its own category, or should this live elsewhere?</p>","title":"Conflict resolution"},{"location":"learn/network/clients/#anchor-services","text":"","title":"Anchor Services"},{"location":"learn/network/clients/#responsibilities_1","text":"","title":"Responsibilities"},{"location":"learn/network/clients/#blockchain-anchoring","text":"<p>The primary responsibility of an anchor service is to generate anchor records by committing signed records into a blockchain. All of the responsibilities below are in service of this primary responsibility.</p>","title":"Blockchain anchoring"},{"location":"learn/network/clients/#merkle-tree-construction","text":"<p>Constructs a merkle tree of all signed records that eill be simultaneously committed to a blockchain in a single hash, called a merkle root.</p>","title":"Merkle tree construction"},{"location":"learn/network/clients/#anchor-metadata","text":"<p>Bloom filter, helps with indexing services.</p>","title":"Anchor metadata"},{"location":"learn/network/clients/#anchor-status-messages","text":"<p>Sends messages to the pubsub room specified for the Ceramic network that the anchor service is servicing. This allows Ceramic nodesLearn more about anchor status messages.</p>","title":"Anchor status messages"},{"location":"pages/3box-migration/","text":"<p>If you have used 3Box with 3ID-Connect in the past, you will already have an existing 3ID. No additional steps have to be taken to migrate your existing 3ID to the Ceramic network. When you interact with any application on Ceramic through 3ID-Connect, your 3ID will automatically be migrated.</p> <p>The migration includes moving your 3ID and control of your 3ID to the Ceramic network, migrating your 3Box profile to the profile definition and schema in IDX, and lastly migrating your address, Twitter and Github links.</p> <p>Any additional data in 3Box may or may not be migrated by the applications themselves built on 3Box. Those applications will guide you through any additional migration steps if necessary.</p>","title":"3ID Migration: 3Box to Ceramic"},{"location":"pages/3box-migration/#migration-difficulties","text":"<p>Most users will be able to migrate without difficulty, but there is a number of known instances where we can not easily migrate your 3ID. In theses cases we will create a new 3ID for you and partially migrate any data that we can. You will be able to re-add any profile data and social links that fail to migrate in the future.</p> <p>Very Early 3Box Users</p> <p>Early 3Box users will have muport DIDs instead of the now standard 3ID DID implementation. For future interoperability in Ceramic and to take advantage of all the features in 3ID we have chosen not to migrate these DIDs. When you use 3ID-Connect on Ceramic we will detect that you have a muport DID and instead create a new 3ID for you. We will still migrate your profile data if we can, but will not migrate your Twitter and Github links.</p> <p>Multiple Linked Accounts</p> <p>There was a known past bug in 3Box that resulted in multiple addresses being linked to a DID in an unexpected way. When you use 3ID-Connect on Ceramic we will detect that you have one of these accounts and instead create a new 3ID for you. Users accounts that have this issue may not have expected to link these accounts, so we will not migrate your profile data or your social links.</p> <p>Migration Failures</p> <p>3Box existed for a while before Ceramic and we may have not built support for all prior existing formats. If migration fails at any point during the process, we will still attempt partial migrations when we can and continue with a best effort migration. If migration fails during 3ID migration, we will create a new 3ID and try to migrate your profile data still. If migration fails during profile or social link migration, we will return your migrated 3ID anyways.</p>","title":"Migration Difficulties"},{"location":"pages/3box-migration/#for-developers","text":"<p>You can find more details in this blog post, if you are interested in the more technical details of the migration or in migrating your own application from 3Box to Ceramic.</p>","title":"For Developers"},{"location":"pages/3box-migration/#questions-or-support","text":"<p>We're always available to answer any questions and help you through this migration. Reach out to us in the\u00a0Ceramic Discord\u00a0for assistance.</p>","title":"Questions or support?"},{"location":"pages/3boxlabs-privacy-policy/","text":"<p>Last Updated: January 20, 2020</p> <p>This Privacy Policy (\u201cPolicy\u201d) describes how 3Box Labs, our related products, including but not limited to Ceramic, IDX, and self.ID(\u201cwe\u201d, \u201cour\u201d, or \u201cus\u201d) collects, uses, shares, and stores Personal Information when app developers and other users (\u201cyou\u201d) use 3Box Labs, Ceramic, IDX, self.ID, and all related tools, applications, websites, data, software, infrastructure, and other services we provide (the \u201cProducts, Services, and Network\u201d). By accessing or using the Products, Services, and Network you accept this Policy and our Terms and Conditions, and you consent to our collection, use, disclosure, and retention of your Personal Information as described in this Policy. If you do not agree with any part of this Policy or our Terms and Conditions, you must stop accessing the Products, Services, and Network. To exercise any rights you may have over your Personal Information, please see the section on Your Choices below.</p>","title":"Privacy Policy"},{"location":"pages/3boxlabs-privacy-policy/#decentralized-data-storage","text":"<p>Our Products, Services, and Network are blockchain-agnostic and leverage distributed-data-storage systems, so nearly all data is kept directly with you and other users and not on our servers, computers, or other systems and devices. To help you manage your data and content, our Products and Services allow you to create and link an Account or Decentralized ID (\u201cDID\u201d). These features are intended to give you more control over your data and privacy-preserving options to choose how your Personal Information is shared and used by other applications or services. For example, to the extent any data is stored privately on the Products and Services, it is unreadable by other apps and users unless you expressly grant others permission to access your data.</p> <p>If you shared your data with other users or a third-party app hosted on or linked to the Products, Services, and Network, you should look to the privacy policy and any terms those third parties or dApps. We do not control third-party apps and are not responsible for how they may treat your Personal Information.</p>","title":"DECENTRALIZED DATA STORAGE"},{"location":"pages/3boxlabs-privacy-policy/#what-we-collect","text":"<p>When you visit our Sites or use our Products, Services, and Network, we may collect information that could identify you directly or indirectly (\u201cPersonal Information\u201d). Personal Information does not include publicly available information or any data that has been deidentified, aggregated, or otherwise anonymized. We only collect the minimum information needed to provide the Products, Services, and Network including:</p> <ul> <li>Identifying Information. To enable you to use our Products, Services, and Network, control your data, and send and receive information, we may collect your public key or DID to identify you.   Account Information. To use certain features of the Products, Services, and Network you must create an Account or DID and provide information such as your Ethereum public key, or other form of authentication. You may also choose to enhance your profile with your name, photo, GitHub account, or other information.</li> <li>User Content. If you share files, content, messages, and other data (\u201cUser Content\u201d) on the Products, Services, Networks, or any third-party apps we may have access to User Content.</li> <li>Cookie Log Data. Our Site uses Cookies to collect your Internet Protocol (IP) address, device identifiers, browser type, and browsing activity (\u201cLog Data\u201d). We use this information to improve functionality and customize the Product, Services, and Network. See the section on Cookies below for more information.</li> <li>Signatures. To enable you to use our Products, Services, or Network, we may prompt you to sign messages with your private key or wallet seed as a way to authenticate and prove control over your key and identity. We are not able to see your private key or wallet seed.</li> </ul> <p>We will never ask you to share your private keys, wallet seed, or other sensitive Personal Information. Trust no one that asks you to enter your private keys or wallet seed.</p>","title":"WHAT WE COLLECT"},{"location":"pages/3boxlabs-privacy-policy/#cookies","text":"<p>Cookies, tags, and similar technologies are small pieces of code placed on your browser, device, or hard drive when you visit a website or use an application (\u201cCookies\u201d).</p> <ul> <li>How We Use Cookies. We may use Cookies for the following reasons:</li> <li>Functionality. To ensure they function properly;</li> <li>Security. To help detect fraud and abuse, including malicious attempts to access data without authorization;</li> <li>Analytics. To gather usage and performance data;</li> <li>Advertising. To collect information about how you interact with our website, and your activity to draw inferences about your preferences.</li> <li> <p>How to Control Cookies. If you wish to prevent cookies from tracking your activity on our website or visits across multiple websites, you can set your browser to block certain cookies or notify you when a cookie is set. If you block cookies, certain features on the Products, Services, or Network may not work.</p> </li> <li> <p>You may control Google analytics by visiting Google\u2019s website.</p> </li> <li> <p>You may control cookies by visiting the link below to your web browser below:</p> <ul> <li>Chrome</li> <li>Safari</li> <li>Internet Explorer</li> <li>Mozilla</li> </ul> </li> <li> <p>You may opt-out of interest-based advertising by visiting the Digital Advertising Alliance\u2019s or Network Advertising Initiative\u2019s websites.</p> </li> </ul> <p>We are not responsible for the completeness, effectiveness, or accuracy of any of these or other third party opt-out options or programs.</p> <ul> <li>Do Not Track Requests. Some web browsers or smartphones can set \u201cDo Not Track\u201d requests to block user activity from being tracked across web pages or devices. We do not recognize \u201cDo Not Track\u201d signals because there is no industry standard way to do so.</li> </ul>","title":"COOKIES"},{"location":"pages/3boxlabs-privacy-policy/#use-of-personal-information","text":"<p>We use the Personal Information we collect for:</p> <ul> <li>Functionality. To enable you to access the Site and use the Products, Services, and Network and deliver products or perform actions you request, for example enabling you to create an Account, DID, or develop apps.</li> <li>Communications. To inform you about relevant promotions, upcoming events, and other news about the Products, Services, or Network and our select partners. We may also use your Personal Information to respond to your comments and questions about the Products, Services, and Network and to provide customer service.</li> <li>System Updates or Alerts. To send information, including confirmations, technical notices, updates, security alerts, and support and administrative messages.</li> <li>Optimization. To optimize your user experience, we may use your Personal Information to operate, maintain, and improve our Products, Services, and Network.</li> <li>Compliance with the Law. To comply with applicable laws, regulations, lawful requests, and other legal process, such as to respond to subpoenas or requests from government authorities.</li> <li>Fraud Prevention and Safety. To protect, investigate, and deter against fraudulent, unauthorized, illegal activity, or unauthorized access to or use of Personal Information, our Products, Services, and Network or related systems.</li> </ul> <p>We may use Personal Information for other limited purposes consistent with the purposes for which we collected that information. We will not use Personal Information for materially different or incompatible purposes without first taking reasonable steps to notifying you and, if necessary, obtain your consent.</p>","title":"USE OF PERSONAL INFORMATION"},{"location":"pages/3boxlabs-privacy-policy/#sharing-personal-information","text":"<p>We only disclose or share Personal Information with others with your consent or when permitted by applicable law, including under these circumstances:</p> <ul> <li>Professional Advisors and Service Providers. We may share information with those who need it to do work for us. These recipients may include third-party companies and individuals to administer and provide the Products, Services, and Network on our behalf (such as customer support, hosting, email delivery and database management), and lawyers, bankers, auditors, and insurers.</li> <li>Affiliates. We may disclose Personal Information to our other brands, subsidiaries, and corporate affiliates for purposes consistent with this Privacy Policy.</li> <li>Third Parties. You may enable settings and features that enable your Personal Information to be available to or shared with other users, companies, or entities of your choosing. We do not control those third parties and we are not responsible for how they may treat your Personal Information. You should look to those third parties\u2019 privacy policy and terms to understand how they treat your Personal Information and what rights you may have.</li> <li>Business Transfers. We may share personal information when we do a business deal or transfer that includes the sale or transfer of all or a part of our business or assets, for example in any merger, financing, acquisition, or bankruptcy transaction or proceeding.</li> <li>Compliance with Laws and Law Enforcement; Protection and Safety. We may share Personal Information for legal, protection, and safety purposes, including to:</li> <li>Comply with laws;</li> <li>Respond to lawful requests, court order, and other legal processes;</li> <li>Protect the rights, freedoms, and property of the Company, our agents, customers, and others; or,</li> <li>Respond to an emergency concerning the safety or wellbeing of our employees, agents, our customers, or any other person.</li> </ul>","title":"SHARING PERSONAL INFORMATION"},{"location":"pages/3boxlabs-privacy-policy/#how-information-is-secured","text":"<p>We retain Personal Information only for as long as it is necessary and relevant to fulfill the purposes for which it was collected. We may retain Personal Information longer if we must do so to comply with applicable law. Once we no longer need to retain Personal Information, we permanently delete it or we may anonymize it so the Information can no longer be associated with a specific individual. We use industry-standard security measures to protect the security and confidentiality of Personal Information. However, the security of information transmitted through or stored on the internet can never be guaranteed. To the fullest extent permitted by law, we are not responsible for any interception, interruption, or loss of data through the internet. You are responsible for maintaining the security of any password, user ID or other form of authentication involved in obtaining access to password-protected or secure areas of any of our Products, Services, and Network. We may suspend use of any aspect of the Products, Services, and Network without notice if we suspect any breach of security or similar issues.</p>","title":"HOW INFORMATION IS SECURED"},{"location":"pages/3boxlabs-privacy-policy/#third-party-applications-or-websites","text":"<p>Our Products, Services, and Network allow you to share information through other third-party applications, including dApps, or websites. These links are provided solely as a convenience to you if you share content. When you visit third-party websites or applications, those third parties may collect your Personal Information along with all content you share. We do not control those websites and applications, and we are not responsible for how they may treat your information. We encourage you to check the privacy policies and terms of those websites and applications to learn more about their practices.</p>","title":"THIRD-PARTY APPLICATIONS OR WEBSITES"},{"location":"pages/3boxlabs-privacy-policy/#your-choices","text":"<p>You may review, opt-out of sharing, correct, or delete your Personal Information through your Account at any time or by contacting us at support@3box.io.</p>","title":"YOUR CHOICES"},{"location":"pages/3boxlabs-privacy-policy/#california-residents","text":"<p>California residents may have additional rights over their Personal Information.</p>","title":"California Residents"},{"location":"pages/3boxlabs-privacy-policy/#the-right-to-request-more-information","text":"<p>You may have the right to request more information about how we treated your Personal Information in the past 12 months, including:</p> <ul> <li>The categories of Personal Information we collected about you;</li> <li>The categories of sources from which we collected that information;</li> <li>Our business or commercial purpose for collecting that information;</li> <li>The categories of third parties with whom we shared that information; and/or</li> <li>The specific pieces of Personal Information we collected about you.</li> </ul>","title":"The Right to Request More Information"},{"location":"pages/3boxlabs-privacy-policy/#the-right-to-request-access","text":"<p>You also may have the right to request access to your Personal Information.</p>","title":"The Right to Request Access"},{"location":"pages/3boxlabs-privacy-policy/#the-right-to-request-deletion","text":"<p>Under certain conditions, you may have the right to request that we delete your Personal Information. Simply logging out does not delete your account or the Personal Information we may have collected.</p>","title":"The Right to Request Deletion"},{"location":"pages/3boxlabs-privacy-policy/#third-party-marketing-and-selling","text":"<p>We do not provide your information to third parties for their direct marketing purposes. Neither do we intend to sell your personal information to third parties without providing you notice and an opportunity to opt out.</p>","title":"Third-Party Marketing and Selling"},{"location":"pages/3boxlabs-privacy-policy/#how-to-exercise-your-rights","text":"<p>To submit a request to exercise these rights you may contact us at support@3box.io. For all requests, please clearly state that the request is related to \u201cYour California Privacy Rights\u201d and provide your name, Account or DID name, Ethereum public key and an e-mail address or mailing address where you may be reached. If you make a request, we will acknowledge we have received it within ten days. If you do not receive a response, please ensure your request was submitted and send a follow up email to support@3box.io.</p>","title":"How to Exercise Your Rights"},{"location":"pages/3boxlabs-privacy-policy/#verification","text":"<p>Before we can respond to your request, we must verify your identity using Personal Information. If we cannot verify your request, we will contact you for more information. If we cannot verify your identity after a good faith attempt, we may deny the request and, if so, will explain the basis for the denial.</p>","title":"Verification"},{"location":"pages/3boxlabs-privacy-policy/#designating-an-authorized-agent","text":"<p>You may designate someone to submit requests and act on your behalf (an \u201cAuthorized Agent\u201d). To do so, you must provide us with written permission to allow your Authorized Agent to act on your behalf.</p>","title":"Designating an Authorized Agent"},{"location":"pages/3boxlabs-privacy-policy/#eu-data-subjects","text":"<p>If you are located in the European Economic Area, you may have additional rights over your Personal Information.</p>","title":"EU Data Subjects"},{"location":"pages/3boxlabs-privacy-policy/#sensitive-data","text":"<p>Some of the information you provide us may constitute sensitive data as defined in the GDPR (also referred to as special categories of personal data), including identification of your race or ethnicity on government-issued identification documents.</p>","title":"Sensitive Data"},{"location":"pages/3boxlabs-privacy-policy/#legal-basis-for-processing","text":"<p>We only use your Personal Information as permitted by applicable law, including:</p> <ul> <li>With your Consent. You may choose to provide or share your Personal Information and consent to our processing of that Information. Where our use of your Personal Information is based upon your consent, you may withdraw consent anytime by adjusting your Account settings, refraining from accessing the Site or using the Products, Services, and Network or contacting us at support@3box.io.</li> <li>Legitimate Interests. Where processing is not based on your consent, we rely on our Legitimate Interests to accomplish the uses listed above. We consider and balance any potential impacts on you or your rights before we process your Personal Information for our Legitimate Interests. We do not use your Personal Information for activities where our interests are overridden by any adverse impact to you.</li> <li>Compliance with a Legal Obligation. We may need to process Personal Information to comply with applicable laws, regulations, or other legal requirements.</li> </ul>","title":"Legal Basis for Processing"},{"location":"pages/3boxlabs-privacy-policy/#international-transfers","text":"<p>We operate from the United States. This means your Personal Information may be transferred to or from the United States where privacy laws may not be as protective as those in your jurisdiction. We transfer Personal Information between the European Economic Area (\u201cEEA\u201d) and the U.S. or other countries based on a data transfer mechanism recognized by the European Commission as adequately protecting personal information.</p>","title":"International Transfers"},{"location":"pages/3boxlabs-privacy-policy/#retention","text":"<p>We will maintain your Personal Information for as long as reasonably necessary to accomplish the purposes for which it was collected, or as otherwise required or permitted by law.</p>","title":"Retention"},{"location":"pages/3boxlabs-privacy-policy/#data-subject-rights","text":"<p>If you are an individual in the EEA, you have the following additional rights over your Personal Information:</p> <ul> <li>Access. You have the right to request copies of your personal information. We may charge you a small fee for this service.</li> <li>Rectification. You have the right to request that we correct any information you believe is inaccurate. You also have the right to request we complete information you believe is incomplete. You may always correct and update your information by logging onto your Account and editing your information.</li> <li>Erasure. Under certain conditions, you have the right to request that we delete your personal information.</li> <li>Restrict processing. Under certain conditions, you have the right to object to the processing of your personal information.</li> <li>Data portability. Under certain conditions, you have the right to request we transfer personal information we have collected about you either to another organization, or directly to you.</li> </ul>","title":"Data Subject Rights"},{"location":"pages/3boxlabs-privacy-policy/#how-to-exercise-your-rights_1","text":"<p>To submit a request to exercise these rights please contact us: Email: support@3box.io. For all requests, please clearly state that the request is related to \u201cYour EU Privacy Rights\u201d and provide your name, Account or DID name, Ethereum public key and an e-mail address or mailing address where you may be reached. If you make a request, we have one month to respond to you. We may require you to verify your identity before we may respond to you. Although we urge you to contact us to find a solution for every concern, you have the right to lodge a complaint with your competent data protection authority.</p>","title":"How to Exercise Your Rights"},{"location":"pages/3boxlabs-privacy-policy/#children","text":"<p>The Products, Services, and Network are not intended for children under age 13, and we do not knowingly collect Personal Information from children under 13. If we discover we have Personal Information related to a child under 13 we will delete that information. If you are under the age of majority in your jurisdiction of residence, you may use the Products, Services, and Network only with the consent of or under the supervision of your parent or legal guardian. If you are the parent or legal guardian of a child under 13 or minor and you believe we have collected your child has used our Site or Products and Services without your permission, please contact us at support@3box.io.</p>","title":"CHILDREN"},{"location":"pages/3boxlabs-privacy-policy/#changes-to-this-privacy-policy","text":"<p>We may change this Policy. We encourage you to periodically review this page for the latest information on our privacy practices. If we make any material changes, we will take reasonable steps to notify you and, if necessary, obtain your consent. We will take your continued use of the Products, Services, and Network after any new Policy is posted as an indication you accept the modified Privacy Policy.</p>","title":"CHANGES TO THIS PRIVACY POLICY"},{"location":"pages/3boxlabs-privacy-policy/#contact-us","text":"<p>If you have questions or concerns about this Policy, please contact us at support@3box.io.</p>","title":"CONTACT US"},{"location":"pages/3boxlabs-terms-conditions/","text":"<p>Last Updated: January 20, 2020</p> <p>3Box Labs, our related products, including Ceramic, IDX, and self.ID, and our officers, employees, agents, affiliates, successors, and assigns (\u201cwe\u201d, \u201cour\u201d, or \u201cus\u201d) provide software for distributed infrastructure that allows people, companies, organizations and other entities (\u201cyou\u201d including any entity you may represent) to store, publish and selectively share content and information. The technology we provide is intended to empower users with control of their own data, agency in how it is used, and privacy where they want it. It is built to technologically assure that no company, including 3Box Labs, can access or exploit user data without express permission. To meet these goals, 3Box Labs has built a suite of products and services that are in active development. Please check these Terms and Conditions regularly to ensure you have the most up to date and relevant information. These Terms and Conditions (\u201cTerms\u201d) govern your use of 3Box Labs, Ceramic, IDX, self.ID, and all related tools, applications, websites, data, software, infrastructure, and other services we provide and to which these terms are attached (collectively our \u201cProducts, Services, and Network\u201d). Certain features of the Products, Services, and Network may be subject to additional guidelines, terms, or rules, which will be posted in connection with such features (\u201cAdditional Terms\u201d).</p> <p>IMPORTANT: Please read these Terms carefully because they are a legally binding contract between you, including the entity you may represent, and us. These Terms contain important information about your rights and responsibilities when accessing the Products, Services, or Network.</p> <p>IF THERE IS A LEGAL DISPUTE REGARDING THESE TERMS OR OUR PRODUCTS AND SERVICES, THE PARTIES AGREE TO RESOLVE ALL SUCH DISPUTES THROUGH BINDING ARBITRATION, TO THE MAXIMUM EXTENT PERMITTED BY LAW THE PARTIES WAIVE ANY RIGHT TO A JURY TRIAL, BENCH TRIAL, OR CLASS ACTION. BY ACCESSING OR USING THE PRODUCTS, SERVICES, OR NETWORK YOU ACKNOWLEDGE AND ACCEPT THESE TERMS AND CONDITION, OUR PRIVACY POLICY, AND ANY ADDITIONAL TERMS THAT MAY APPLY. IF YOU DO NOT AGREE WITH ALL OF THESE TERMS, OR SUBSEQUENT MODIFICATIONS OF WHICH YOU ARE PROVIDED NOTICE, YOU MAY NOT ACCESS, USE, OR CONTINUE TO ACCESS OR USE THE PRODUCTS, SERVICES, OR NETWORK.</p>","title":"Terms and Conditions"},{"location":"pages/3boxlabs-terms-conditions/#1-accounts","text":"<p>1.1 Eligibility. The Products, Services, and Network are not intended for children under age 13, and we do not knowingly collect Personal Information from children under 13. If we discover we have Personal Information related to a child under 13 we will delete that information. If you are under the age of majority in your jurisdiction of residence, you may use the Products, Services, and Network only with the consent of your parent or legal guardian. If you are the parent or legal guardian of a child under 13 or minor and you believe your child has used our Products, Services, or Network without your permission, please contact us at support@3box.io.</p> <p>1.2 Account Creation. To use certain features of the Products, Services, or Network, you must create or link a profile, or decentralized ID (\u201cDID\u201d) and public key (\u201cAccount\u201d). After this, you may choose to add other contact information such as your name, photo or GitHub account to your profile. You may delete your profile at any time, for any reason, by following the instructions on the applicable Product, Service, or Network. We may suspend or terminate your access to the Products, Services, or Network if you violate these Terms or applicable law.</p> <p>1.3 Account Privacy. You are responsible for maintaining the confidentiality of your Account login information and are responsible for all activities that occur under your Account. You may also choose to authorize other users, platforms, or apps to interact with you through your Account, including permission to view or update your profile and access any of your content, files, code, messages, and other data (your \u201cUser Content\u201d). Each user, party, application, website, product, or service to whom you choose to provide private access can view your User Content. With permission they can also store additional data or data in your Account. You should not use our Products, Services, or Network to store or share sensitive personal data that you do not want to make accessible to others.</p> <p>1.4 Account Security. You are responsible for ensuring that any networks, computers, or other systems and devices (\u201cComputer Networks\u201d) in your control are reasonably secured from the risk of unauthorized access, disruption, or compromise. You agree to immediately notify us of any actual or suspected unauthorized use of your Account, User Content, or any other breach of security by contacting us at support@3box.io. We are not responsible for security issues that result from your failure to maintain the privacy or security of your own Account and Computer Networks. If your activity causes or contributes to a breach of security on any related Computer Network, you may be required to indemnify us for any costs, damages, or other losses as a result. See Section 6.3 on Indemnification for more information.</p>","title":"1. ACCOUNTS"},{"location":"pages/3boxlabs-terms-conditions/#2-acceptable-use-of-the-products-services-and-network","text":"<p>2.1 Acceptable Use. When accessing the or using the Products, Services, and Network you agree not to:</p> <p>i. Upload, transmit, or distribute to or through the Products, Services, or Network any computer viruses, worms, or any software intended to damage or alter a computer system or data, including computer viruses, works, time bombs, Trojan horses, and other harmful or malicious code, routines, files, scripts, agents, or programs;</p> <p>ii. Send unsolicited or unauthorized advertising, promotional materials, junk mail, spam, chain letters, pyramid schemes, or any other form of duplicative or unsolicited messages, whether commercial or otherwise;</p> <p>iii. Harvest, collect, gather or assemble information or data regarding other users, including email addresses, without a legal basis to do so;</p> <p>iv. Interfere with, disrupt, or create an undue burden on servers or networks connected to the Products, Services, or Network, or violate the regulations, policies or procedures of such networks;</p> <p>v. Attempt to gain unauthorized access to the Products, Services, or Network (or to other computer systems or networks connected to or used together with the Products, Services,or Network), whether through password mining or any other means; or,</p> <p>vi. Harass, threaten, or otherwise interfere with any other user\u2019s use and enjoyment of the Products, Services, or Network.</p> <p>2.2 Ownership. Excluding any User Content you may create, you acknowledge that all the intellectual property rights, including copyrights, patents, trademarks, and trade secrets, in the Products, Services, and Network and their content are owned by 3Box Labs, Ceramic, IDX, or self.ID, respectively. Neither these Terms (nor your access to or use of Products, Services, or Network) transfers to you or any third party any rights, title, or interest in or to such intellectual property, except for the limited use and access rights expressly set forth below in Section 2.3. There are no implied licenses granted under these Terms, and we reserve all rights not granted in these Terms.</p> <p>2.3 License. Subject to these Terms, we grant you a non-transferable, non-exclusive, revocable, limited license to use and access the Products, Services, and Network for their intended, lawful purposes.</p> <p>2.4 Restrictions. The limited rights granted to you in these Terms are subject to restrictions, including that you shall not:</p> <p>i. License, sell, rent, lease, transfer, assign, distribute, host, or otherwise commercially exploit the Products, Services, or Network, whether in whole or in part, or any content displayed on the Products, Services, or Network;</p> <p>ii. Modify, make derivative works of, disassemble, reverse compile or reverse engineer any part of the Products, Services, or Network, except as expressly permitted in writing;</p> <p>iii. Access the Products, Services, or Network to build a similar or competitive website, product, platform, or service;</p> <p>iv. Copy, reproduce, distribute, republish, download, display, post, or transmit in any form or by any means any part of the Products, Services,or Network unless expressly stated otherwise in these Terms; or,</p> <p>v. Store or distribute any information, material or data that is infringing, unlawful, or which violates the privacy or intellectual property rights of any third party.</p> <p>2.5 Enforcement. We reserve the right to enforce these Terms and investigate or take appropriate action against you, in our sole discretion, if you violate the Acceptable Uses, Restrictions, or any other provision of these Terms. This may include clocking your access, removing or destroying User Content, and reporting you to law enforcement authorities.</p> <p>2.6 Feedback. Should you encounter any bugs, glitches, lack of functionality or other problems on the Products, Services, or Network, please let us know by contacting us at support@3box.io. We appreciate your feedback as it helps us develop the Products, Services, or Network and offer the best service possible. If you provide any feedback or suggestions regarding the Products, Service, or Network (\u201cFeedback\u201d), you assign to 3Box Labs all rights in such Feedback and agree that we shall have the right to use and fully act on such Feedback and related information as we deem appropriate. We will treat any Feedback you provide to us as non-confidential and non-proprietary. You agree that you will not submit any information or ideas you consider confidential or proprietary.</p> <p>2.7 Modification. We reserve the right, at any time, to modify, suspend, or discontinue the Products, Services, or Network (in whole or in part) with or without notice to you. You agree that we will not be liable to you or to any third party for any modification, suspension, or discontinuation of the Products, Services, and Network or any part thereof.</p> <p>2.8 No Support or Maintenance. You acknowledge and agree that we have no obligation to provide you with any support or maintenance in connection with the Products, Services, and Network.</p>","title":"2. ACCEPTABLE USE OF THE PRODUCTS, SERVICES, AND NETWORK"},{"location":"pages/3boxlabs-terms-conditions/#3-user-content","text":"<p>3.1 Creating User Content. When you use our Products, Services, and Network, you may provide things such as code, your files, content, messages, and other data (\u201cUser Content\u201d). You may choose to share User Content publicly, in which case it will be accessible and viewable by anybody. If you shared User Content which you no longer want to share publicly or privately using our Products, Services, or Network, you must either revoke access or delete that User Content. By making such deletion, other participants in the network will be notified to remove the content and it will be deleted from any nodes run by 3Box Labs. However, this may not permanently erase the existence of or substance of any User Content from all aspects of the network entirely. In a distributed network, it is not possible for us to guarantee that all node operators will delete content.</p> <p>3.2 User Content Restrictions. When accessing the Products, Services, or Network you must not collect, upload, transmit, display, or distribute any User Content that may:</p> <p>i. Violate any third-party right, including any copyright, trademark, patent, trade secret, moral right, privacy right, right of publicity, or any other intellectual property or proprietary right;</p> <p>ii. Contain any unlawful, harassing, abusive, tortious, threatening, harmful, invasive of another\u2019s privacy, vulgar, defamatory, false, intentionally misleading, trade libelous, pornographic, obscene, patently offensive, promotes racism, bigotry, hatred, or physical harm of any kind against any group or individual or is otherwise objectionable;</p> <p>iii. Contain viruses, worms, or any software intended to damage or alter a computer system or data, including computer viruses, works, time bombs, Trojan horses, and other harmful or malicious code, routines, files, scripts, agents, or programs;</p> <p>iv. Be harmful to minors in any way;</p> <p>v. Interfere with or disrupts the integrity or performance of the Site, Products, Services, Network, User Content, or any other data contained therein; or,</p> <p>vi. Violate any applicable law, regulation, or obligations or restrictions imposed by any third party.</p> <p>3.3 Rights in User Content. You represent and warrant that you have the right to grant and hereby grant 3Box Labs an irrevocable, nonexclusive, royalty-free and fully paid, worldwide license to reproduce, distribute, publicly display and perform, prepare derivative works of, incorporate into other works, and otherwise use your User Content; and, to grant sublicenses of these rights, solely for the purposes of including your User Content in the Products, Services, and Network. You irrevocably waive any claims and assertions of moral rights or attribution regarding your User Content.</p> <p>3.4 Responsibility for User Content. You are solely responsible for your User Content. You assume all risks associated with use of your User Content, including any reliance on its accuracy, completeness or usefulness by others, or any disclosure of your User Content that personally identifies you or any third party. You represent and warrant that your User Content does not violate these Terms. You may not represent or imply to others that your User Content is in any way provided, sponsored, or endorsed by 3Box Labs. Because you alone are responsible for your User Content, you may expose yourself to liability if, for example, your User Content violates the Acceptable Use Policy. We are not obligated to backup or maintain any User Content, and your User Content may be deleted at any time without prior notice. You are solely responsible for creating and maintaining your own backup copies of your User Content if you desire.</p> <p>3.5 Copyright Infringement. If you believe that your copyright or the copyright of a person on whose behalf you are authorized to act has been infringed, please provide us a written notice at support@3box.io containing the following information:</p> <p>i. An electronic or physical signature of the person authorized to act on behalf of the owner of the copyright or other intellectual property interest;</p> <p>ii. A description of the copyrighted work or other intellectual property you claim has been infringed; and,</p> <p>iii. A description of where the material you claim is infringing is on the Site.</p>","title":"3. USER CONTENT"},{"location":"pages/3boxlabs-terms-conditions/#4-third-party-links-ads-other-users","text":"<p>4.1 Third-Party Links &amp; Ads. The Products, Services, and Network may contain links to third-party websites, services, or display advertisements for third parties (\u201cThird-Party Links &amp; Ads\u201d). We provide access to these Third-Party Links &amp; Ads only as a convenience to you. We do not control these third parties or operate, review, approve, monitor, or endorse Third-Party Links &amp; Ads, so we are not responsible for those third parties\u2019 policies and practices, including how they may treat your data. Use caution and review the terms and privacy policies of those third parties before proceeding with any transaction in connection with such Third-Party Links &amp; Ads.</p> <p>4.2 Other Users\u2019 Content. Because we do not control User Content, you acknowledge and agree that we are not responsible for any User Content, whether provided by you or by others, such as dapps to whom you have granted private access. We make no guarantees regarding the accuracy, currency, suitability, or quality of any User Content. Your interactions with other users are solely between you and such users. You agree that we will not be responsible for any loss or damage incurred as the result of any such interactions. If there is a dispute between you and any user, we are under no obligation to become involved.</p>","title":"4. THIRD-PARTY LINKS &amp; ADS; OTHER USERS"},{"location":"pages/3boxlabs-terms-conditions/#5-disclaimers-and-warranties","text":"<p>5.1 Limited Warranty. WE EXPRESSLY DISCLAIM ANY AND ALL WARRANTIES AND CONDITIONS OF ANY KIND, WHETHER EXPRESS, IMPLIED, OR STATUTORY, INCLUDING ALL WARRANTIES OR CONDITIONS OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE, QUIET ENJOYMENT, ACCURACY, OR NON-INFRINGEMENT. WE (AND OUR SUPPLIERS) MAKE NO WARRANTY THAT THE PRODUCTS, SERVICES, OR NETWORK WILL MEET YOUR REQUIREMENTS, WILL BE AVAILABLE ON AN UNINTERRUPTED, TIMELY, SECURE, OR ERROR-FREE BASIS, OR WILL BE ACCURATE, RELIABLE, FREE OF VIRUSES OR OTHER HARMFUL CODE, COMPLETE, LEGAL, OR SAFE. IF APPLICABLE LAW REQUIRES ANY WARRANTIES WITH RESPECT TO THE PRODUCTS, SERVICES, OR NETWORK, ALL SUCH WARRANTIES ARE LIMITED IN DURATION TO NINETY (90) DAYS FROM THE DATE OF FIRST USE. SOME JURISDICTIONS DO NOT ALLOW THE EXCLUSION OF IMPLIED WARRANTIES, SO THE ABOVE EXCLUSION MAY NOT APPLY TO YOU. SOME JURISDICTIONS DO NOT ALLOW LIMITATIONS ON HOW LONG AN IMPLIED WARRANTY LASTS, SO THE ABOVE LIMITATION MAY NOT APPLY TO YOU.</p> <p>5.2 Risks of Cryptographic Systems. You acknowledge and understand that cryptography is a progressing field. Advances in code cracking or technical advances such as developing quantum computers may present risks to cryptographic systems and the Products, Services, or Network, which could cause the theft or loss of your property. To the extent possible, we intend to update the code underlying the Products, Services, or Network to account for any advances in cryptography and to incorporate additional security measures, but do not guarantee or otherwise represent full security of the system. By using the Products, Services, or Network you acknowledge these inherent risks.</p> <p>5.3 Security, Vulnerabilities, or Interruptions. We are in early stages of development. You acknowledge that applications are code subject to flaws and acknowledge that you are solely responsible for evaluating any available code provided by the Products, Services, or Network. You further expressly acknowledge that applications can be written maliciously or negligently, and we cannot be held liable for your interactions with third party applications. These warnings and others later provided by us in no way evidence or represent an ongoing duty to alert you to all of the potential risks of utilizing the Products, Services, and Network. You agree that we have no responsibility or liability to:</p> <p>i. Update the Products, Services, or Network to address, mitigate, or remediate any security or other vulnerabilities;</p> <p>ii. Ensure that any integrations or APIs are secure and function without errors, bugs, or other interruptions; or,</p> <p>iii. Ensure that the Products, Services, or Network have no weaknesses or bugs that may cause security vulnerabilities, data loss, damage, destructions, disclosure, or other compromises.</p> <p>5.4 Release of all Claims. YOU RELEASE, FOREVER DISCHARGE 3BOX LABS, CERAMIC, IDX, AND/OR SELF.ID FROM, AND WAIVE AND RELINQUISH EACH AND EVERY PAST, PRESENT, OR FUTURE DISPUTE, CLAIM, CONTROVERSY, DEMAND, RIGHT, OBLIGATION, LIABILITY ACTION, OR CAUSE OF ACTION OF EVERY KIND AND NATURE THAT ARISES DIRECTLY OR INDIRECTLY FROM YOUR USE OF THE PRODUCTS, SERVICES, AND NETWORK TO THE FULLEST EXTENT PERMITTED BY APPLICABLE LAW. IF YOU ARE A CALIFORNIA RESIDENT, YOU HEREBY WAIVE CALIFORNIA CIVIL CODE SECTION 1542 IN CONNECTION WITH THE FOREGOING, WHICH STATES: \u201cA general release does not extend to claims that the creditor or releasing party does not know or suspect to exist in his or her favor at the time of executing the release and that, if known by him or her, would have materially affected his or her settlement with the debtor or released party.\u201d</p> <p>5.5 No Third Party Beneficiaries. You agree there shall be no third party beneficiaries to the Terms, nor will these Terms be construed as creating or implying any relationship of agency, franchise, partnership, or joint venture between you and 3Box Labs.</p>","title":"5. DISCLAIMERS AND WARRANTIES"},{"location":"pages/3boxlabs-terms-conditions/#6-limitation-on-liability-and-indemnification","text":"<p>PLEASE READ THIS SECTION CAREFULLY AS IT CONTAINS IMPORTANT LIMITATIONS ON OUR LIABILITY AND YOUR RIGHTS.</p> <p>6.1 Limitation on Liability. TO THE FULLEST EXTENT PERMITTED BY LAW, IN NO EVENT SHALL 3BOX LABS, CERAMIC, IDX, AND/OR SELF.ID (OR OUR SUPPLIERS) BE LIABLE TO YOU OR ANY THIRD PARTY FOR ANY LOST PROFITS, LOST DATA, COSTS OF PROCUREMENT OF SUBSTITUTE PRODUCTS, OR ANY INDIRECT, CONSEQUENTIAL, EXEMPLARY, INCIDENTAL, SPECIAL OR PUNITIVE DAMAGES ARISING FROM OR RELATING TO THESE TERMS OR YOUR USE OF, OR INABILITY TO USE, THE PRODUCTS, SERVICES, OR NETWORK, EVEN IF WE HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. ACCESS TO, AND USE OF, THE PRODUCTS, SERVICES, OR NETWORK IS AT YOUR OWN DISCRETION AND RISK, AND YOU WILL BE SOLELY RESPONSIBLE FOR ANY DAMAGE TO YOUR DEVICE OR COMPUTER SYSTEM, OR LOSS OF DATA RESULTING THEREFROM.</p> <p>6.2 Total Aggregate Liability. TO THE FULLEST EXTENT PERMITTED BY LAW, NOTWITHSTANDING ANYTHING TO THE CONTRARY CONTAINED HEREIN, OUR LIABILITY TO YOU FOR ANY DAMAGES ARISING FROM OR RELATED TO THIS AGREEMENT (FOR ANY CAUSE WHATSOEVER AND REGARDLESS OF THE FORM OF THE ACTION), WILL AT ALL TIMES BE LIMITED TO A MAXIMUM OF FIFTY US DOLLARS (U.S. $50). THE EXISTENCE OF MORE THAN ONE CLAIM WILL NOT ENLARGE THIS LIMIT. YOU AGREE THAT OUR SUPPLIERS WILL HAVE NO LIABILITY OF ANY KIND ARISING FROM OR RELATING TO THIS AGREEMENT. SOME JURISDICTIONS DO NOT ALLOW THE LIMITATION OR EXCLUSION OF LIABILITY FOR INCIDENTAL OR CONSEQUENTIAL DAMAGES, SO THE ABOVE LIMITATION OR EXCLUSION MAY NOT APPLY TO YOU.</p> <p>6.3 Indemnification. YOU AGREE TO INDEMNIFY AND HOLD HARMLESS 3BOX LABS, CERAMIC, IDX, AND/OR SELF.ID FROM EVERY PAST, PRESENT, OR FUTURE DISPUTE, CLAIM, CONTROVERSY, DEMAND, RIGHT, OBLIGATION, LIABILITY ACTION, OR CAUSE OF ACTION OF EVERY KIND, INCLUDING COSTS AND ATTORNEYS FEES, THAT ARISES OUT OF YOUR:</p> <p>i. Misuse of the Products, Services, and Network;</p> <p>ii. Failure to secure your Networks, Account, or User Content;</p> <p>iii. Violation of these Terms;</p> <p>iv. Violation of applicable laws; or,</p> <p>v. User Content.</p> <p>We reserve the right, at your expense, to assume the exclusive defense and control of any matter for which you must indemnify us, and you agree to cooperate with our defense of these claims. You agree not to settle any matter without our prior written consent. We will use reasonable efforts to notify you of any such claim, action or proceeding upon learning of it.</p>","title":"6. LIMITATION ON LIABILITY AND INDEMNIFICATION"},{"location":"pages/3boxlabs-terms-conditions/#7-dispute-resolution","text":"<p>PLEASE READ THIS SECTION CAREFULLY. IT CONTAINS IMPORTANT INFORMATION THAT COMPELS MANDATORY ARBITRATION AND PROVIDES A CLASS ACTION WAIVER.</p> <p>7.1 Applicability of Arbitration Agreement. All claims and disputes (excluding claims for injunctive or other equitable relief as set forth below) in connection with the Terms or the use of any product or service provided by 3Box Labs, Ceramic, IDX, or Self.ID, respectively, that cannot be resolved informally or in small claims court shall be resolved by binding arbitration on an individual basis under this Arbitration Agreement. Unless otherwise agreed to, all arbitration proceedings shall be held in English. This Arbitration Agreement applies to you and 3Box Labs, Ceramic, IDX, or Self.ID, respectively, and to any of our subsidiaries, affiliates, agents, employees, predecessors in interest, successors, and assigns, as well as all authorized or unauthorized users or beneficiaries of the Products, Services, and Network these Terms.</p> <p>7.2 Notice Requirement and Informal Dispute Resolution. Before either party may seek arbitration, the party must first send to the other party a written Notice of Dispute (\u201cNotice\u201d) describing the claim or dispute, and the requested relief. A Notice to 3Box Labs, Ceramic, IDX, or Self.ID, should be sent to: 275 S 5th St, 15E, Brooklyn, NY 11211. After the Notice is received, you and 3Box Labs, Ceramic, IDX, or Self.ID, may attempt to resolve the claim or dispute informally. If unable to resolve the claim or dispute within thirty (30) days after the Notice is received, either party may begin an arbitration proceeding. Any settlement offer made by any party may not be disclosed to the arbitrator until after the arbitrator has determined the amount of the award, if any, to which either party is entitled.</p> <p>7.3 Arbitration Rules. Arbitration shall be initiated through the American Arbitration Association (\u201cAAA\u201d), an established alternative dispute resolution provider (\u201cADR Provider\u201d). If AAA is not available to arbitrate, the parties shall select an alternative ADR Provider. The rules of the ADR Provider shall govern all aspects of the arbitration, including but not limited to the method of initiating and/or demanding arbitration, except to the extent such rules conflict with the Terms. The AAA Consumer Arbitration Rules (\u201cArbitration Rules\u201d) governing the arbitration are available online at www.adr.org or by calling the AAA at 1-800-778-7879. The arbitration shall be conducted by a single, neutral arbitrator. Any claims or disputes where the total award sought is less than Ten Thousand U.S. Dollars (US $10,000.00) may be resolved through binding non-appearance-based arbitration, at the option of the party seeking relief. For claims or disputes where the total award sought is Ten Thousand U.S. Dollars (US $10,000.00) or more, the right to a hearing will be determined by the Arbitration Rules. Any judgment on the award rendered by the arbitrator may be entered in any court of competent jurisdiction, subject to the Limitations of Liability set out in Section 6. Each party shall bear its own costs (including attorney\u2019s fees) and disbursements arising out of the arbitration and shall pay an equal share of the fees and costs of the ADR Provider.</p> <p>7.4 Additional Rules for Non-Appearance Based Arbitration. If non-appearance based arbitration is elected, the arbitration shall be conducted by telephone, online and/or based solely on written submissions; the specific manner shall be chosen by the party initiating the arbitration. The arbitration shall not involve any personal appearance by the parties or witnesses unless otherwise agreed by the parties.</p> <p>7.5 Time Limits. If you or 3Box Labs, Ceramic, IDX, or Self.ID, pursue arbitration, the arbitration action must be initiated and/or demanded within the statute of limitations (i.e., the legal deadline for filing a claim) and within any deadline imposed under the AAA Rules for the pertinent claim.</p> <p>7.6 Authority of Arbitrator. If arbitration is initiated, the arbitrator will decide the rights and liabilities, if any, of you and 3Box Labs, Ceramic, IDX, or Self.ID, and the dispute will not be consolidated with any other matters or joined with any other cases or parties. The arbitrator shall have the authority to grant motions dispositive of all or part of any claim. The arbitrator shall have the authority to award monetary damages, and to grant any non-monetary remedy or relief available to an individual under applicable law, the AAA Rules, and the Terms. The arbitrator shall issue a written award and statement of decision describing the essential findings and conclusions on which the award is based, including the calculation of any damages awarded. The arbitrator has the same authority to award relief on an individual basis that a judge in a court of law would have. The award of the arbitrator is final and binding upon you and 3Box Labs, Ceramic, IDX, or Self.ID.</p> <p>7.7 Waiver of Jury Trial. THE PARTIES HEREBY WAIVE THEIR CONSTITUTIONAL AND STATUTORY RIGHTS TO GO TO COURT AND HAVE A TRIAL IN FRONT OF A JUDGE OR A JURY, instead electing that all claims and disputes shall be resolved by arbitration under this Arbitration Agreement. Arbitration procedures are typically more limited, more efficient and less costly than rules applicable in a court and are subject to very limited review by a court. If any litigation should arise between you and 3Box Labs, Ceramic, IDX, or Self.ID, in any state or federal court in a suit to vacate or enforce an arbitration award or otherwise, YOU AND 3BOX LABS, CERAMIC, IDX, AND SELF ID WAIVE ALL RIGHTS TO A JURY TRIAL, instead electing that the dispute be resolved by a judge.</p> <p>7.8 Waiver of Class or Consolidated Actions. ALL CLAIMS AND DISPUTES WITHIN THE SCOPE OF THIS ARBITRATION AGREEMENT MUST BE ARBITRATED OR LITIGATED ON AN INDIVIDUAL BASIS AND NOT ON A CLASS BASIS, AND CLAIMS OF MORE THAN ONE CUSTOMER OR USER CANNOT BE ARBITRATED OR LITIGATED JOINTLY OR CONSOLIDATED WITH THOSE OF ANY OTHER CUSTOMER OR USER.</p> <p>7.9 Confidentiality. All aspects of the arbitration proceeding, including but not limited to the award of the arbitrator and compliance therewith, shall be strictly confidential. The parties agree to maintain confidentiality unless otherwise required by law. This paragraph shall not prevent a party from submitting to a court of law any information necessary to enforce this Agreement, to enforce an arbitration award, or to seek injunctive or equitable relief.</p> <p>7.10 Small Claims Court. Notwithstanding the foregoing, either you or 3Box Labs, Ceramic, IDX, or Self.ID may bring an individual action in small claims court.</p> <p>7.11 Emergency Equitable Relief. Notwithstanding the foregoing, either party may seek emergency equitable relief before a state or federal court to maintain the status quo pending arbitration. A request for interim measures shall not be deemed a waiver of any other rights or obligations under this Arbitration Agreement.</p> <p>7.12 Survival of Arbitration Agreement. This Arbitration Agreement will survive the termination of your relationship with 3Box Labs, Ceramic, IDX, or Self.ID.</p> <p>7.13 Courts. Where the foregoing Arbitration Agreement permits the parties to litigate in court, the parties agree to submit to the personal jurisdiction of the courts within Kings County, New York, for such purpose.</p> <p>7.14 Governing Law. These Terms are to be interpreted and applied under New York state law without regards for the state\u2019s conflicts of law policies.</p>","title":"7. DISPUTE RESOLUTION"},{"location":"pages/3boxlabs-terms-conditions/#8-other-general-terms","text":"<p>8.1 Term and Termination. Subject to this Section, these Terms will remain in full force and effect while you use the Products, Services, and Network. We may suspend or terminate your rights to use the Products, Services, and Network (including your Account) at any time for any reason at our sole discretion, including for any use of the Products, Services, or Network in violation of these Terms. Upon termination of your rights under these Terms, your Account and right to access and use the Products, Services, and Network will terminate immediately. You understand that any termination of your Account may involve deletion of your User Content associated with your Account from our live databases. We will have no liability whatsoever to you for any termination of your rights under these Terms, including for termination of your Account or deletion of your User Content. To the fullest extent permitted by law, even after your rights under these Terms are terminated, the Terms will remain in effect.</p> <p>8.2 Severability. If any part or parts of this Arbitration Agreement are found under the law to be invalid or unenforceable by a court of competent jurisdiction, then such specific part or parts shall be of no force and effect and shall be severed and the remainder of the Agreement shall continue in full force and effect.</p> <p>8.3 Right to Waive. We may, at our sole discretion, waive any of the rights and limitations in these Terms. Such waiver shall not waive or affect any other portion of these Terms.</p> <p>8.4 Export. The Products, Services, and Network, or User Content may be subject to U.S. export control laws and may be subject to export or import regulations in other countries. You agree not to export, re-export, or transfer, directly or indirectly, any U.S. technical data acquired from 3Box Labs or any products utilizing such data, in violation of the United States export laws or regulations.</p>","title":"8. OTHER GENERAL TERMS"},{"location":"pages/3boxlabs-terms-conditions/#9-entire-terms","text":"<p>These Terms constitute the entire agreement between you and us regarding the Products, Services, and Network. Our failure to exercise or enforce any right or provision of these Terms shall not operate as a waiver of such right or provision. The section titles in these Terms are for convenience only and have no legal or contractual effect. The word \u201cincluding\u201d means \u201cincluding without limitation\u201d. If any provision of these Terms is, for any reason, held to be invalid or unenforceable, the other provisions of these Terms will be unimpaired and the invalid or unenforceable provision will be deemed modified so it is valid and enforceable to the maximum extent permitted by law. Your relationship to 3Box Labs, Ceramic, IDX, or Self.ID, is that of an independent contractor, and neither party is an agent or partner of the other. These Terms, and your rights and obligations herein, may not be assigned, subcontracted, delegated, or otherwise transferred by you without our prior written consent, and any attempted assignment, subcontract, delegation, or transfer in violation of the foregoing will be null and void. We may freely assign these Terms. These Terms shall be binding upon assignees.</p>","title":"9. ENTIRE TERMS"},{"location":"pages/3boxlabs-terms-conditions/#10-changes","text":"<p>These Terms are subject to occasional revision. If we make any material changes, we will take reasonable steps to notify you and change the Last Updated date above. Continued use of our Products, Services, or Network following such updates shall indicate your acknowledgement and agreement to be bound by the updated Terms.</p>","title":"10. CHANGES"},{"location":"pages/3boxlabs-terms-conditions/#11-contact","text":"<p>We welcome your comments or questions about these Terms. Contact us at support@3box.io.</p>","title":"11. CONTACT"},{"location":"pages/3id-lifecycle/","text":"<p>This page describes the complete lifecycle of a 3ID DID, including how the DID document is created, how keys are managed, and how 3ID Connect uses these building blocks. Most of the logic described here is implemented in the 3id-did-provider package.</p> <p>The two core components to the 3ID lifecycle are the 3ID DID method and the 3ID Keychain which is a standard for storing encrypted key material in a DID's Identity Index.</p>","title":"3ID Lifecycle"},{"location":"pages/3id-lifecycle/#3id-did-provider-lifecycle","text":"<p>Every 3ID has a seed which is the secret used to update the 3ID, sign messages, and decrypt messages as the 3ID. The 3ID DID provider manages this seed using authSecrets. Each <code>authSecret</code> can be used to authenticate to the 3ID and thus get access to the seed.</p> <p></p>","title":"3ID DID provider lifecycle"},{"location":"pages/3id-lifecycle/#creating-a-3id","text":"<p>To create a 3ID the 3id-did-provider accepts an <code>authSecret</code> and an <code>authId</code>. It roughly follows the following algorithm.</p> <ol> <li>We have an <code>authSecret A</code> that is used to create <code>did:key:A</code> using the <code>key-did-provider-ed25519</code> provider</li> <li>A deterministic TileDocument, referred to as AuthLink, is created. If this is a new <code>authSecret</code> the loaded AuthLink will be empty</li> <li>A seed for the 3ID is randomly generated; two asymmetric keys (<code>signing</code>, and <code>encryption</code>), and a <code>did:key:management-1</code> are derived from the seed. A stream for the 3ID DID document is created with <code>did:key:management-1</code> as the controller, the <code>signing</code> and <code>encryption</code> public keys are stored in the streams content</li> <li>The seed is encrypted to <code>did:key:A</code></li> <li>The encrypted seed is put into the 3ID Keychain, which is an Identity Index record associated with the 3ID from step 3</li> <li>The AuthLink document is updated to contain the 3ID from step 3.</li> </ol>","title":"Creating a 3ID"},{"location":"pages/3id-lifecycle/#loading-an-existing-3id","text":"<p>If an <code>authSecret</code> has already been associated with a 3ID then this 3ID will be loaded instead of a new one created. Once authenticated the user can make updates to the 3ID document itself, as well author signatures and decrypt messages as the 3ID.</p> <ol> <li><code>authSecret A</code> is used to create <code>did:key:A</code> using the <code>key-did-provider-ed25519</code> provider.</li> <li>A deterministic TileDocument, referred to as AuthLink, is created. If this is an existing <code>authSerect</code> the loaded AuthLink contain a 3ID</li> <li>Using the 3ID from the previous step we can deterministically load the 3ID keychain</li> <li>Decrypt the seed in the 3ID Keychain that was encrypted to <code>did:key:A</code></li> </ol>","title":"Loading an existing 3ID"},{"location":"pages/3id-lifecycle/#adding-a-new-authsecret","text":"<p>We can add a new <code>authSecret</code> with two simple steps.</p> <ol> <li><code>authSecret B</code> is used to create <code>did:key:B</code></li> <li>The <code>seed</code> is encrypted to <code>did:key:B</code> and stored in the 3ID Keychain</li> <li>An AuthLink stream is created for <code>did:key:B</code> and updated to link to the 3ID</li> </ol>","title":"Adding a new <code>authSecret</code>"},{"location":"pages/3id-lifecycle/#revoking-an-authsecret","text":"<p>Assume that we have <code>authSecret A</code> and <code>authSecret B</code> associated to our 3ID, and we want to revoke <code>authSecret A</code>. Lets refer to the current seed as <code>seed 1</code>. Note that you should always end up with at least one <code>authSecret</code> in the end. It doesn't make sense to revoke all authSecrets as there no longer would be a way to authenticate to this 3ID.</p> <ol> <li>Randomly generate a new seed, <code>seed 2</code></li> <li>Two asymmetric keys (<code>signing</code>, and <code>encryption</code>), and a <code>did:key:management-2</code> are derived from <code>seed 2</code>. The 3ID stream for the 3ID DID document is updated with <code>did:key:management-2</code> as the controller, the <code>signing</code> and <code>encryption</code> public keys in the content</li> <li>The <code>seed 1</code> is encrypted to <code>seed 2</code> and stored in the 3ID Keychain, so that we can use it to decrypt any message encrypted to the previous version of the 3ID document</li> <li><code>seed 2</code> is encrypted to <code>authSecret B</code> but not to <code>authSecret A</code></li> <li>The encrypted <code>seed 2</code> is stored in the 3ID keychain</li> </ol> <p>After these steps are taken, <code>authSecret A</code> can no longer be used to authenticate to the 3ID.</p>","title":"Revoking an <code>authSecret</code>"},{"location":"pages/3id-lifecycle/#usage-in-3id-connect","text":"<p>A natural question at this point is: Where does these authSecrets come from? In 3ID Connect normal blockchain wallets are used to create these secrets in the following way.</p> <ol> <li>A signature of some static message is requested from the users wallet, e.g. MetaMask</li> <li>If the user accepts a signature is returned</li> <li>The entropy (randomness) of the signature is now used as an <code>authSecret</code> (we take the hash of the signature to get the <code>authSecret</code>), in addition 3ID Connect will use the wallet AccountID as the <code>authId</code></li> </ol> <p>Note that this relies on the wallet making deterministic signatures, such that we can get the same <code>authSecret</code> every time.</p> <p>In addition to the authentication flow, 3ID Connect also creates a Caip10Link from the wallet AccountID to the 3ID. This allows application developers to query the users 3ID using an Ethereum address for example. The Caip10Link is also stored in the users CryptoAccounts Identity Index definition.</p>","title":"Usage in 3ID Connect"},{"location":"pages/3id-security/","text":"<p>The 3ID Connect system allows blockchain accounts to be used as an authentication method to the keys used for the users 3ID. In order to authenticate a user signs a message with their wallet. The entropy is used to generate a Key DID which in turn is used to decrypt the seed used for the 3ID.</p> <p>The main security concern here is that the seed used for the 3ID is stored within the 3ID iframe. While this restricts the app using 3ID Connect from doing whatever it wants with the seed, a malicious browser plugin could easily pick up the seed from the web browser and take full control over the users 3ID. While are multiple paths that can be used to mitigate this issue, it's currently considered to be a fair tradeoff to improve UX for users. In contrast to a users crypto wallet, the 3ID doesn't actually hold or control any cryptocurrency; it only controls data read/writes. This means that the incentive for a hacker to execute an attack is much smaller since there is no immediate financial reward. Also note that this security issue is not inherent to 3ID itself, it's just related to how 3ID is used within 3ID connect.</p>","title":"3ID Security"},{"location":"pages/3id-security/#possible-security-improvements","text":"","title":"Possible security improvements"},{"location":"pages/3id-security/#external-3id-controller","text":"<p>The 3ID DID document has different public keys used for writing and controlling the DID document itself. Currently however, these keys are generated from the same seed and this seed is stored in the iframe as mentioned above. This means that if someone gets access to this seed and rotates keys using the controller key they will own the 3ID forever.</p> <p>One possible mitigation strategy is to generate the day-to-day public keys and the controller public key from different seeds, and then make sure to store the controller key separately in a more secure manner (not in the iframe). This would make it possible to recover from a scenario where the day-to-day writing public keys are compromised (seed is stolen from the iframe) because the seed of the controller key would still be in control of the user. An example solution here could be to store the seed of the controller key in a MetaMask Snap plugin.</p>","title":"External 3ID controller"},{"location":"pages/3id-security/#dont-store-keys-in-web-context","text":"<p>The long term solution is of course to not store any keys of the 3ID in the web browser context. This could be achieved though wallets supporting 3ID directly, or an Object-based capability system rooted in blockchain accounts which would allow applications to request specific permissions from wallets.</p>","title":"Don't store keys in web context"},{"location":"reference/","text":"<p>This section contains reference documentation as well as instructions for common usage for core Ceramic libraries and various developer tools in the ecosystem.</p>","title":"Ceramic Reference Documentation"},{"location":"reference/#ceramic-clients","text":"<ul> <li>Ceramic JS HTTP client</li> <li>DID JSON-RPC client</li> </ul>","title":"Ceramic Clients"},{"location":"reference/#accounts","text":"<ul> <li>3ID DID libraries</li> <li>Key DID libraries</li> </ul>","title":"Accounts"},{"location":"reference/#streams","text":"<ul> <li>Tile Document client</li> <li>CAIP-10 Link client</li> </ul>","title":"Streams"},{"location":"reference/#glaze-suite","text":"<ul> <li>DID DataStore client</li> <li>DevTools library</li> </ul>  <ul> <li>DataModel client</li> <li>Tile loader library</li> </ul>","title":"Glaze Suite"},{"location":"reference/#selfid-sdk","text":"<ul> <li>Self.ID Framework</li> <li>Self.ID React</li> <li>Self.ID Web</li> <li>Self.ID Core</li> <li>Self.ID Image utilities</li> </ul>","title":"Self.ID SDK"},{"location":"reference/#glossary","text":"<ul> <li>Glossary of terms</li> </ul>","title":"Glossary"},{"location":"reference/glossary/","text":"<p>This page contains a glossary of terms for Ceramic. Consider this list a work-in-progress; we will continue to update it until it's complete.</p>","title":"Glossary of terms"},{"location":"reference/glossary/#core-concepts","text":"","title":"Core concepts"},{"location":"reference/glossary/#streams","text":"<p>Streams are DAG-based data structures for storing continuous, mutable streams of content on IPFS and tracking state in a completely decentralized, peer-to-peer way. When syncing or loading a stream from the network, you will always get back the current state.</p>","title":"Streams"},{"location":"reference/glossary/#streamid","text":"<p>A StreamID is an immutable identifier for a stream. StreamIDs enable continuous streams of data to be referenced by a persistent identifier instead of by constantly-changing IPFS CIDs.</p>","title":"StreamID"},{"location":"reference/glossary/#streamtypes","text":"<p>StreamTypes are functions used for processing updates to streams. StreamTypes handle everything from defining the data structure of the stream, to what can be stored in its commits, its state transitition function, authentication requirements, and conflict resolution strategy. Every stream must specify a StreamType; and StreamTypes run on Ceramic nodes. Ceramic comes pre-installed with various StreamTypes, or you can code your own.</p>","title":"StreamTypes"},{"location":"reference/glossary/#commits","text":"<p>Commits are individual IPFS records that make up a stream. Streams may contain one or more commits.</p>","title":"Commits"},{"location":"reference/glossary/#genesis-commit","text":"<p>A genesis commit is the first commit in a stream. Genesis commits may be signed by a public key, or unsigned.</p>","title":"Genesis commit"},{"location":"reference/glossary/#signed-commit","text":"<p>Signed commits are commits that update the state of a stream. All signed commits need to be cryptographically signed by a public key.</p>","title":"Signed commit"},{"location":"reference/glossary/#anchor-commit","text":"<p>Anchor commits are commits that contain a blockchain timestamp, providing an immutable record of time and ordering to other commits in the stream, sometimes known as a proof-of-publication. Anchor commits are needed since vanilla merkle DAGs have no notion of absolute time needed to build consensus.</p>","title":"Anchor commit"},{"location":"reference/glossary/#commitid","text":"<p>A commitID is an immutable identifier for a specific commit in a stream.</p>","title":"CommitID"},{"location":"reference/glossary/#state","text":"<p>State represents the state of a stream at various points in time. When a stream is loaded or queried from the network, the current state is returned.</p>","title":"State"},{"location":"reference/glossary/#tip","text":"<p>A tip is the CID for the most recent commit(s) of a stream.</p>","title":"Tip"},{"location":"reference/glossary/#conflict-resolution-strategy","text":"<p>A conflict resolution strategy is logic defined by a StreamType that describes how the protocol should handle conflicting updates to a stream that uses this StreamType.</p>","title":"Conflict resolution strategy"},{"location":"reference/glossary/#controllers","text":"<p>Controllers are entities allowed to perform updates to a stream, by creating new signed commits. A given stream may have one or more controllers.</p>","title":"Controllers"},{"location":"reference/glossary/#stream-authentication","text":"","title":"Stream authentication"},{"location":"reference/glossary/#authentication","text":"<p>Authentication allows a user to perform protected operations on a stream, such as creating genesis commits, signed commits, or decrypting data. Each StreamType implementation is able to specify its own authentication mechanism as long as the signatures can be resolved/validated by Ceramic, but most StreamTypes use DIDs.</p>","title":"Authentication"},{"location":"reference/glossary/#dids","text":"<p>DIDs is the W3C standard for decentralized identifiers. The DID specification outlines a standard URI scheme for creating a persistent decentralized identifier (DID) for a given subject as well as resolving metadata about that identifier via a DID document. DIDs are used as an authentication mechanism by most StreamTypes.</p>","title":"DIDs"},{"location":"reference/glossary/#did-methods","text":"<p>DID methods are implementations of the DID specification. DID methods must specify a name for the method in the form of a string (see below), a description of where the DID document is stored (or how it is statically generated), and a DID resolver which can return a DID document given a URI that conforms to that particular DID method. There are over 40 DID methods on the W3C's official DID registry. Ceramic can support any DID method if needed, and currently supports the 3ID DID method and the Key DID method. DID URIs look like this:</p> <pre><code>did:&lt;method-name&gt;:&lt;method-specific-identifier&gt;\n</code></pre>","title":"DID methods"},{"location":"reference/glossary/#did-document","text":"<p>DID documents are documents which contain metadata about a given DID. At a minimum they should contain cryptographic key material used for signature verification and encryption/decryption. They may be mutable where their keys and content can be changed/rotated (i.e. 3ID DID method) or statically generated where their contents cannot be manually changed (i.e. Key DID method).</p>","title":"DID document"},{"location":"reference/glossary/#did-resolver","text":"<p>DID resolvers are software libraries responsible for returning a DID document given a DID string. Each DID method has at least one resolver implementation. For all DID methods supported by Ceramic, the corresponding DID resolver must be included in a Ceramic node. Ceramic uses DID resolvers to verify stream transactions by comparing the signature on the transaction to the controller of the stream. For the transaction to be successfully processed, a public key corresponding to the transaction signature must be present in the DID Document of the DID listed as a controller.</p>","title":"DID resolver"},{"location":"reference/glossary/#did-providers","text":"<p>DID providers are software libraries that expose a json-rpc interface which allows for the creation and usage of a DID that conforms to a particular DID method. Usually a DID provider is constructed using a seed that the user controls. When using Ceramic with streams that require DIDs for authentication, applications either need to integrate a DID provider library, which leaves the responsibility of key management up to the application, or a DID wallet, which is a more user-friendly experience.</p>","title":"DID providers"},{"location":"reference/glossary/#did-wallets","text":"<p>DID wallets are software libraries or end-user applications that wrap DID providers with additional capabilities. 3ID Connect is the most popular DID wallet SDK that allows users create, manage, and use a 3ID DID method with their existing blockchain wallets, and without needing to install any additional software.</p>","title":"DID wallets"},{"location":"reference/glossary/#network","text":"","title":"Network"},{"location":"reference/glossary/#clients","text":"<p>Clients are software libraries that provide developer interfaces to a Ceramic node. Clients are responsible for authenticating users, providing StreamType-specific interfaces for generating genesis commits and signed commits, and providing generic, streamtype-agnostic interfaces for loading or querying streams. A list of Ceramic clients can be found here.</p>","title":"Clients"},{"location":"reference/glossary/#nodes","text":"<p>Nodes are software libraries that provide core protocol functionality for the Ceramic network. Nodes are responsible for processing stream updates (in the form of signed commits from clients), storing state for the streams that it cares about, responding to queries, networking with other nodes, replicating streams across the network, and sending valid signed commits to an external anchor service for generating anchor commits.</p>","title":"Nodes"},{"location":"reference/glossary/#anchor-service","text":"<p>A Ceramic Anchor Service (CAS) is a hosted \"layer-2\" solution for generating anchor commits for many different stream transactions in a scalable, low cost manner. Ceramic nodes are responsible for sending anchor requests containing a StreamID and a CommitID to a CAS, which then batches these transactions into a merkle tree, and includes the merkle root into a blockchain platform in a single transaction (currently Ethereum). After the transaction makes its way onto a blockchain, a Ceramic node creates an anchor commit which includes a reference to the blockchain transaction for every anchored stream. A CAS eliminates the need for each stream transaction to have its own corresponding blockchain transaction, which would be slower and more expensive.</p>","title":"Anchor service"},{"location":"reference/glossary/#networks","text":"<p>Networks are collections of Ceramic nodes that share specific configurations and communicate over a dedicated libp2p topic. Networks are discrete from one another. Streams that exist on one network are not discoverable on or portable to another. Currently, Ceramic has three primary networks: mainnet, Clay Testnet, and dev unstable.</p>","title":"Networks"},{"location":"reference/glossary/#mainnet","text":"<p>Mainnet is the Ceramic network used for production deployments. For more information on mainnet, see the Networks page.</p>","title":"Mainnet"},{"location":"reference/glossary/#clay-testnet","text":"<p>Clay Testnet is a Ceramic network used by the community for application prototyping, development, and testing purposes. Ceramic core devs also use Clay for testing official protocol release candidates. For more information on Clay Testnet, see the Networks page.</p>","title":"Clay Testnet"},{"location":"reference/glossary/#dev-unstable","text":"<p>Dev Unstable is a Ceramic network used by Ceramic core protocol developers for testing new protocol features and the most recent commits on the <code>develop</code> branch of js-ceramic. It should be considered unstable and highly experimental.</p>","title":"Dev Unstable"},{"location":"reference/glossary/#underlying-technologies","text":"","title":"Underlying technologies"},{"location":"reference/glossary/#ipfs","text":"<p>IPFS is the Interplanetary File System. Simply put, IPFS is a way to address static content using CIDs and to discover this content over a peer-to-peer network of nodes. Ceramic relies on IPFS for storing the commits that make up streams and discovering this data over the network.</p>","title":"IPFS"},{"location":"reference/glossary/#cid","text":"<p>A CID (content identifier) is an immutable identifier for a discrete piece of static content stored on IPFS. CIDs are essentially a hash of the content along with metadata that describes how the content is encoded. Ceramic streams consist of multiple CIDs, encoded using dag-jose (and other formats such as dag-cbor), and linked together using IPLD.</p>","title":"CID"},{"location":"reference/glossary/#ipld","text":"<p>IPLD (Interplanetary Linked Data) is the data structures layer of IPFS. It is used to link multiple CIDs together into higher-level linked-data structures. Ceramic uses IPLD to create the data structures for streams.</p>","title":"IPLD"},{"location":"reference/glossary/#dagjose","text":"<p>DagJOSE is a codec for IPLD which stores content in IPFS using IETF's JOSE (JSON object signing and encryption) format. With DagJOSE, each data object actually consists of two separate but linked CIDs. It supports both signed and encrypted objects. JWS is used for signed objects and it encodes the payload as a CID, which means that the actual payload is a separate IPLD object. JWE is used for encrypted objects, and it requires the ciphertext to be a CID in order to not leak the full cleartext. A separate inline CID is used to encode the entire cleartext. For more information refer to the DagJOSE spec.</p>","title":"DagJOSE"},{"location":"reference/glossary/#libp2p","text":"<p>Libp2p is the peer-to-peer networking protocol that is used by Ceramic. It is included as part of the IPFS stack. Ceramic relies on libp2p for discovering data over the network and communicating between nodes. Libp2p is also used by other major decentralized platforms such as Ethereum (Eth2) and Polkadot.</p>","title":"Libp2p"},{"location":"reference/glossary/#ethereum","text":"<p>Ethereum is the world's leading public, permissionless smart contract blockchain platform. Ceramic uses Ethereum for generating the timestamps contained within anchor commits.</p>","title":"Ethereum"},{"location":"reference/accounts/3id-did/","text":"<p>The 3ID DID libraries provide support for the <code>did:3</code> method as a Ceramic account, which notably uses Ceramic to store DID documents as Ceramic streams, enabling features such as supporting multiple authentication keys and rotating these keys.</p>","title":"3ID DID libraries"},{"location":"reference/accounts/3id-did/#available-libraries","text":"<ul> <li>The 3ID DID resolver allows a DID JSON-RPC client to resolve accounts using the <code>did:3</code> method from the Ceramic network</li> <li>The 3ID DID provider allows applications to create and use 3ID DID accounts to perform transactions</li> <li>3ID Connect exposes a hosted implementation of the 3ID DID provider for use with web applications (recommended)</li> </ul>","title":"Available libraries"},{"location":"reference/accounts/3id-did/#3id-did-resolver","text":"<p>A 3ID DID resolver is needed to resolve DID documents using the <code>did:3</code> method.</p>","title":"3ID DID resolver"},{"location":"reference/accounts/3id-did/#installation","text":"<pre><code>npm install @ceramicnetwork/3id-did-resolver key-did-resolver\n</code></pre> <p>A Ceramic client is also needed to use this resolver:</p> <pre><code>npm install @ceramicnetwork/http-client\n</code></pre>","title":"Installation"},{"location":"reference/accounts/3id-did/#usage","text":"<pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { DID } from 'dids'\nimport { getResolver as getKeyResolver } from 'key-did-resolver'\nimport { getResolver as get3IDResolver } from '@ceramicnetwork/3id-did-resolver'\n\nfunction createCeramicWith3ID() {\n  const ceramic = new CeramicClient()\n  const did = new DID({\n    resolver: {\n      // A Ceramic client instance is needed by the 3ID DID resolver to load DID documents\n      ...get3IDResolver(ceramic),\n      // `did:key` DIDs are used internally by 3ID DIDs, therefore the DID instance must be able to resolve them\n      ...getKeyResolver(),\n    },\n  })\n  // This will allow the Ceramic client instance to resolve DIDs using the `did:3` method\n  ceramic.did = did\n}\n</code></pre>","title":"Usage"},{"location":"reference/accounts/3id-did/#3id-did-provider","text":"<p>The <code>3id-did-provider</code> module implements a provider to create and manage DIDs using the <code>did:3</code> method, either using a <code>seed</code> or an <code>authId</code> associated to an <code>authSecret</code> (recommended).</p> <p>It is up to applications using <code>3id-did-provider</code> to take care of the security of authentication secrets and seeds, whether they are providing a custodial key management, prompting users to input secrets, or alternative solutions.</p>","title":"3ID DID provider"},{"location":"reference/accounts/3id-did/#installation_1","text":"<pre><code>npm install 3id-did-provider\n</code></pre>","title":"Installation"},{"location":"reference/accounts/3id-did/#permissions-management","text":"<p>The <code>getPermission</code> parameter is always required when creating an instance of <code>ThreeIdProvider</code>. It allows your application to request actions from a 3ID, such as signing and/or decrypting data. When called, this function should prompt the user in the UI asking for permission to the given paths. You would likely need to implement a UI for this.</p> <p>The function is called with one parameter which is the request object. It looks like this:</p> <pre><code>{\n  type: 'authenticate',\n  origin: 'https://my.app.origin',\n  payload: {\n    paths: ['/path/1', '/path/2']\n  }\n}\n</code></pre> <p>In the above example the app with origin <code>https://my.app.origin</code> is requesting access to /path/1 and /path/2. If the user approves, the function should return the paths array. If they decline, it will return an empty array. Note that a user may approve only some of the requested paths, which would return an array containing only the approved paths.</p> <p>The most simple <code>getPermission</code> function simply grants all requested permissions.</p> <pre><code>function getPermission(request) {\n  return Promise.resolve(request.payload.paths)\n}\n</code></pre>","title":"Permissions management"},{"location":"reference/accounts/3id-did/#usage-with-authid-and-secret","text":"<p>This is the recommended method for using a 3ID DID provider.</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { DID } from 'dids'\nimport { getResolver as getKeyResolver } from 'key-did-resolver'\nimport { getResolver as get3IDResolver } from '@ceramicnetwork/3id-did-resolver'\nimport ThreeIdProvider from '3id-did-provider'\n\n// `authSecret` must be a 32-byte long Uint8Array\nasync function authenticateWithSecret(authSecret) {\n  const ceramic = new CeramicClient()\n\n  const threeID = await ThreeIdProvider.create({\n    authId: 'myAuthID',\n    authSecret,\n    // See the section above about permissions management\n    getPermission: (request) =&gt; Promise.resolve(request.payload.paths),\n  })\n\n  const did = new DID({\n    provider: threeID.getDidProvider(),\n    resolver: {\n      ...get3IDResolver(ceramic),\n      ...getKeyResolver(),\n    },\n  })\n\n  // Authenticate the DID using the 3ID provider\n  await did.authenticate()\n\n  // The Ceramic client can create and update streams using the authenticated DID\n  ceramic.did = did\n}\n</code></pre>","title":"Usage with authID and secret"},{"location":"reference/accounts/3id-did/#usage-with-seed","text":"<pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { DID } from 'dids'\nimport { getResolver as getKeyResolver } from 'key-did-resolver'\nimport { getResolver as get3IDResolver } from '@ceramicnetwork/3id-did-resolver'\nimport ThreeIdProvider from '3id-did-provider'\n\n// `seed` must be a 32-byte long Uint8Array\nasync function authenticateWithSecret(seed) {\n  const ceramic = new CeramicClient()\n\n  const threeID = await ThreeIdProvider.create({\n    seed,\n    // See the section above about permissions management\n    getPermission: (request) =&gt; Promise.resolve(request.payload.paths),\n  })\n\n  const did = new DID({\n    provider: threeID.getDidProvider(),\n    resolver: {\n      ...get3IDResolver(ceramic),\n      ...getKeyResolver(),\n    },\n  })\n\n  // Authenticate the DID using the 3ID provider\n  await did.authenticate()\n\n  // The Ceramic client can create and update streams using the authenticated DID\n  ceramic.did = did\n}\n</code></pre>","title":"Usage with seed"},{"location":"reference/accounts/3id-did/#3id-connect","text":"<p>3ID Connect is an in-browser 3ID DID provider, using blockchain wallets to create deterministic authentication secrets using to control a DID.</p> <p>Using 3ID Connect, web apps do not need to take care of key custody directly, but rather to use an authentication provider such as <code>EthereumAuthProvider</code> to allow 3ID Connect to generate the necessarry authentication secrets.</p>","title":"3ID Connect"},{"location":"reference/accounts/3id-did/#installation_2","text":"<pre><code>npm install @3id/connect\n</code></pre>","title":"Installation"},{"location":"reference/accounts/3id-did/#usage_1","text":"<p>3ID Connect is a browser-only library, if your app has shared code between browser and server logic, you need to make sure the following code is not executed server-side, otherwise it will not work and may throw errors.</p>  <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { DID } from 'dids'\nimport { getResolver as getKeyResolver } from 'key-did-resolver'\nimport { getResolver as get3IDResolver } from '@ceramicnetwork/3id-did-resolver'\nimport { EthereumAuthProvider, ThreeIdConnect } from '@3id/connect'\n\n// Create a ThreeIdConnect connect instance as soon as possible in your app to start loading assets\nconst threeID = new ThreeIdConnect()\n\nasync function authenticateWithEthereum(ethereumProvider) {\n  // Request accounts from the Ethereum provider\n  const accounts = await ethereumProvider.request({\n    method: 'eth_requestAccounts',\n  })\n  // Create an EthereumAuthProvider using the Ethereum provider and requested account\n  const authProvider = new EthereumAuthProvider(ethereumProvider, accounts[0])\n  // Connect the created EthereumAuthProvider to the 3ID Connect instance so it can be used to\n  // generate the authentication secret\n  await threeID.connect(authProvider)\n\n  const ceramic = new CeramicClient()\n  const did = new DID({\n    // Get the DID provider from the 3ID Connect instance\n    provider: threeID.getDidProvider(),\n    resolver: {\n      ...get3IDResolver(ceramic),\n      ...getKeyResolver(),\n    },\n  })\n\n  // Authenticate the DID using the 3ID provider from 3ID Connect, this will trigger the\n  // authentication flow using 3ID Connect and the Ethereum provider\n  await did.authenticate()\n\n  // The Ceramic client can create and update streams using the authenticated DID\n  ceramic.did = did\n}\n\n// When using extensions such as MetaMask, an Ethereum provider may be injected as `window.ethereum`\nasync function tryAuthenticate() {\n  if (window.ethereum == null) {\n    throw new Error('No injected Ethereum provider')\n  }\n  await authenticateWithEthereum(window.ethereum)\n}\n</code></pre>","title":"Usage"},{"location":"reference/accounts/key-did/","text":"<p>The Key DID libraries include the resolver and multiple providers to provide a simple way for developers to get started using the DID client with the <code>did:key</code> method.</p>","title":"Key DID libraries"},{"location":"reference/accounts/key-did/#available-libraries","text":"<ul> <li>The Key DID resolver allows a DID JSON-RPC client to resolve accounts using the <code>did:key</code> method</li> <li>The Key DID provider ED25519 allows applications to create and use Key DID accounts for ED25519 keypairs. This provider supports encryption.</li> <li>The Key DID provider secp256k1 allows applications to create and use Key DID accounts for secp256k1 keypairs. This provider does not supports encryption.</li> </ul>","title":"Available libraries"},{"location":"reference/accounts/key-did/#key-did-resolver","text":"<p>The <code>key-did-resolver</code> module is needed to resolve DID documents using the <code>did:key</code> method.</p>","title":"Key DID resolver"},{"location":"reference/accounts/key-did/#installation","text":"<pre><code>npm install key-did-resolver\n</code></pre>","title":"Installation"},{"location":"reference/accounts/key-did/#usage","text":"<pre><code>import { DID } from 'dids'\nimport { getResolver } from 'key-did-resolver'\n\nasync function resolveDID() {\n  const did = new DID({ resolver: getResolver() })\n  return await did.resolve('did:key:...')\n}\n</code></pre>","title":"Usage"},{"location":"reference/accounts/key-did/#key-did-providers","text":"<p>Different libraries implement a provider for the <code>did:key</code> method based on different cryptographic primitives. These providers may have different possibilities, for example <code>key-did-provider-ed25519</code> supports encryption while <code>key-did-provider-secp256k1</code> does not.</p>","title":"Key DID providers"},{"location":"reference/accounts/key-did/#key-did-provider-ed25519","text":"<p>This is the recommended provider for the <code>key:did</code> method in most cases.</p>","title":"Key DID provider ED25519"},{"location":"reference/accounts/key-did/#installation_1","text":"<pre><code>npm install key-did-provider-ed25519\n</code></pre>","title":"Installation"},{"location":"reference/accounts/key-did/#usage_1","text":"<pre><code>import { DID } from 'dids'\nimport { Ed25519Provider } from 'key-did-provider-ed25519'\nimport { getResolver } from 'key-did-resolver'\n\n// `seed` must be a 32-byte long Uint8Array\nasync function authenticateDID(seed) {\n  const provider = new Ed25519Provider(seed)\n  const did = new DID({ provider, resolver: getResolver() })\n  await did.authenticate()\n  return did\n}\n</code></pre>","title":"Usage"},{"location":"reference/accounts/key-did/#key-did-provider-secp256k1","text":"<p>This provider does not support encryption, so using methods such as <code>createJWE</code> on the <code>DID</code> instance is not supported.</p>","title":"Key DID provider secp256k1"},{"location":"reference/accounts/key-did/#installation_2","text":"<pre><code>npm install key-did-provider-secp256k1\n</code></pre>","title":"Installation"},{"location":"reference/accounts/key-did/#usage_2","text":"<pre><code>import { DID } from 'dids'\nimport { Secp256k1Provider } from 'key-did-provider-secp256k1'\nimport { getResolver } from 'key-did-resolver'\n\n// `seed` must be a 32-byte long Uint8Array\nasync function authenticateDID(seed) {\n  const provider = new Secp256k1Provider(seed)\n  const did = new DID({ provider, resolver: getResolver() })\n  await did.authenticate()\n  return did\n}\n</code></pre>","title":"Usage"},{"location":"reference/accounts/nft-did/","text":"","title":"NFT DID"},{"location":"reference/accounts/safe-did/","text":"","title":"Safe DID"},{"location":"reference/core-clients/ceramic-http/","text":"<p>The Ceramic HTTP client library can be used in browsers and Node.js to connect your application to a Ceramic node. It is actively maintained and supports the latest Ceramic features.</p> <p></p>","title":"Ceramic HTTP client"},{"location":"reference/core-clients/ceramic-http/#things-to-know","text":"<ul> <li>The HTTP client currently supports loading CAIP-10 links (CIP-7) and Tile document (CIP-8) streams.</li> <li>The client is read-only by default, to enable transactions a DID client needs to be attached to the Ceramic client instance.</li> <li>Ceramic streams can be identified by a stream ID or a commit ID. A stream ID is generated when creating the stream and can be used to load the latest version of the stream, while a commit ID represents a specific version of the stream.</li> </ul>","title":"Things to know"},{"location":"reference/core-clients/ceramic-http/#installation","text":"<pre><code>npm install @ceramicnetwork/http-client\n</code></pre>","title":"Installation"},{"location":"reference/core-clients/ceramic-http/#common-use-cases","text":"","title":"Common use-cases"},{"location":"reference/core-clients/ceramic-http/#load-a-single-stream","text":"<pre><code>// Import the client\nimport { CeramicClient } from '@ceramicnetwork/http-client'\n\n// Connect to a Ceramic node\nconst ceramic = new CeramicClient('https://your-ceramic-node.com')\n\n// The `id` argument can be a stream ID (to load the latest version)\n// or a commit ID (to load a specific version)\nasync function load(id) {\n  return await ceramic.loadStream(id)\n}\n</code></pre>","title":"Load a single stream"},{"location":"reference/core-clients/ceramic-http/#load-multiple-streams","text":"<p>Rather than using the <code>loadStream</code> method multiple times with <code>Promise.all()</code> to load multiple streams at once, a more efficient way for loading multiple streams is to use the <code>multiQuery</code> method.</p> <pre><code>// Import the client\nimport { CeramicClient } from '@ceramicnetwork/http-client'\n\n// Connect to a Ceramic node\nconst ceramic = new CeramicClient('https://your-ceramic-node.com')\n\n// The `ids` argument can contain an arry of stream IDs (to load the latest version)\n// or commit IDs (to load a specific version)\nasync function loadMulti(ids = []) {\n  const queries = ids.map((streamId) =&gt; ({ streamId }))\n  // This will return an Object of stream ID keys to stream values\n  return await ceramic.multiQuery(queries)\n}\n</code></pre>","title":"Load multiple streams"},{"location":"reference/core-clients/ceramic-http/#enable-transactions","text":"<p>In order to create and update streams, the Ceramic client instance must be able to sign transaction payloads by using an authenticated DID instance. The DID client documentation describes the process of authenticating and attaching a DID instance to the Ceramic instance.</p>","title":"Enable transactions"},{"location":"reference/core-clients/ceramic-http/#interact-with-json-data","text":"<p>The Tile document client provides APIs to interact specifically with Tile document streams (CIP-8).</p>","title":"Interact with JSON data"},{"location":"reference/core-clients/ceramic-http/#interact-with-crypto-account-links","text":"<p>The CAIP-10 links client provides APIs to interact specifically with CAIP-10 links streams (CIP-7).</p>","title":"Interact with crypto account links"},{"location":"reference/core-clients/did-jsonrpc/","text":"<p>DID JSON-RPC client provides a simple JS API for interacting with Ceramic accounts.</p>","title":"DID JSON-RPC client"},{"location":"reference/core-clients/did-jsonrpc/#things-to-know","text":"<ul> <li>Provides the DID object, which must be authenticated, then mounted on the Ceramic object to perform transactions.</li> <li>For Ceramic nodes, the DID client serves as a way to resolve ad verify transaction signatures</li> <li>For Ceramic clients, the DID client serves as a way to create account, authenticate, sign, encrypt</li> <li>If your project requires transactions, you need to install this package, or one that offers similar EIP-2844 API support.</li> <li>The DID client library can be used in both browser and Node.js environments.</li> <li>It supports any DID wallet provider that adheres to the EIP-2844 interface.</li> <li>Communicating between a Ceramic client and any account provider.</li> <li>Ceramic does not work without a DID client, as it is how all participants are identified and how transactions and messages are signed and verified.</li> </ul>","title":"Things to know"},{"location":"reference/core-clients/did-jsonrpc/#installation","text":"<pre><code>npm install dids\n</code></pre> <p>The <code>DID</code> class provides the interface on top of underlying account libraries. The next step is to set up your account system, which requires you to make some important decisisions about your account model and approach to key management. This process consists of three steps: choosing your account types, installing a provider, and installing resolver(s).</p>","title":"Installation"},{"location":"reference/core-clients/did-jsonrpc/#choose-your-account-types","text":"<p>Choosing an account type can have a big impact on the interoperability of your users' identity and data. For example some account types are fixed to a single public key (Key DID, PHK DID) so the data is siloed to that key, while others (3ID DID) have mutable key management schemes that can support multiple authorized signing keys and works cross-chain with blockchain wallets. Visit each account to learn more about its capabilities.</p>","title":"Choose your account types"},{"location":"reference/core-clients/did-jsonrpc/#3id-did","text":"<p>Supports multi-account, cross-chain (MACC) identities. Mutability and key rotations. Good for users + most popular. Relies on Ceramic for account storage.</p>","title":"3ID DID"},{"location":"reference/core-clients/did-jsonrpc/#key-did","text":"<p>Simple, self-contained DID method.</p>","title":"Key DID"},{"location":"reference/core-clients/did-jsonrpc/#nft-did","text":"<p>Experimental DID method using NFT ownership for authentication.</p>","title":"NFT DID"},{"location":"reference/core-clients/did-jsonrpc/#safe-did","text":"<p>Experimental DID method using a Gnosis Safe for authentication.</p>","title":"Safe DID"},{"location":"reference/core-clients/did-jsonrpc/#install-account-resolvers","text":"<p>The next step is to install resolver libraries for all of the account types which you may need to read and verify data (signatures). This includes at least the resolver for the provider or wallet chosen in the previous step. However, most projects install all reslovers to be safe:</p>    Account Resolver libraries Maintainer     3ID DID <code>@ceramicnetwork/3id-did-resolver</code> 3Box Labs   Key DID <code>key-did-resolver</code> 3Box Labs","title":"Install account resolvers"},{"location":"reference/core-clients/did-jsonrpc/#install-account-providers","text":"<p>Install providers to manage accounts and sign transactions. Once you have chosen one or more account types, you'll need to install the providers for these account types. These will enable the client-side creation and use of accounts within your application. If your application is using Ceramic in a read-only manner without transactions then you do not need to install a provider.</p>","title":"Install account providers"},{"location":"reference/core-clients/did-jsonrpc/#using-web-wallets","text":"<p>However, the providers listed above are low-level, run locally, and burden developers with UX issues related to secret key management and transaction signing. Instead of using a local provider, you can alternatively use a wallet system. Wallets wrap providers with additional user experience features related to signing and key management and can be used in place of a provider. Benefit is multiple applications can access the same wallet and key management system, so users have a continuous experience between applications.</p>    Account Wallet Benefits Drawbacks     3ID DID <code>3ID Connect</code> \u2705 Sign with blockchain wallets including MetaMask\u2705 Connect multiple blockchain accounts to one Ceramic account\u2705 Implements 3ID DID\u2705 Works cross-chain\u2705 Sleek UI \u274c Risks     <p>Most user-facing applications use the 3ID Connect wallet instead of using a provider.</p>","title":"Using web wallets"},{"location":"reference/core-clients/did-jsonrpc/#create-your-own-wallet","text":"<p>One option is to install and set up one or more account providers that run locally. Note that these local signers have different wallet support</p>    Account Supported Key Types Provider libraries     3ID DID Ed25519 <code>3id-did-provider</code>   Key DID Ed25519 <code>key-did-provider-ed25519</code>   Key DID Secp256k1 <code>key-did-provider-secp256k1</code>     <p>Note that NFT DID and Safe DID do not have a signer because they are compatible with all other providers.</p>","title":"Create your own wallet"},{"location":"reference/core-clients/did-jsonrpc/#setup-your-project","text":"<p>By now you should have installed DID.js and set up your account system, including authentication to perform transactions. When you include everything in your project it should look something like this. Note that exact code will vary by your setup including provider and wallet. Consult your provider's documentation for authentication specifics.</p> <pre><code>// Import DID client\nimport { DID } from 'dids'\n\n// Add account system\nimport { Ed25519Provider } from 'key-did-provider-ed25519'\nimport { getResolver } from 'key-did-resolver'\n\n// Connect to a Ceramic node\nconst API_URL = 'https://your-ceramic-node.com'\n\n// Create the Ceramic object\nconst ceramic = new CeramicClient(API_URL)\n\n// \u2191 With this setup you can perform read-only queries.\n// \u2193 Continue to authenticate the account and perform transactions.\n\nasync function authenticateCeramic(seed) {\n  // Activate the account by somehow getting its seed.\n  // See further down this page for more details on\n  // seed format, generation, and key management.\n  const provider = new Ed25519Provider(seed)\n  // Create the DID object\n  const did = new DID({ provider, resolver: getResolver() })\n  // Authenticate with the provider\n  await did.authenticate()\n  // Mount the DID object to your Ceramic object\n  ceramic.did = did\n}\n</code></pre>","title":"Setup your project"},{"location":"reference/core-clients/did-jsonrpc/#common-use-cases","text":"","title":"Common use-cases"},{"location":"reference/core-clients/did-jsonrpc/#authenticate-the-user","text":"<p>This will flow will vary slightly depending on which account provider library you use. Please see the documentation specific to your provider library.</p>  <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { DID } from 'dids'\nimport { Ed25519Provider } from 'key-did-provider-ed25519'\nimport { getResolver } from 'key-did-resolver'\n\n// `seed` must be a 32-byte long Uint8Array\nasync function createJWS(seed) {\n  const provider = new Ed25519Provider(seed)\n  const did = new DID({ provider, resolver: getResolver() })\n  // Authenticate the DID with the provider\n  await did.authenticate()\n  // This will throw an error if the DID instance is not authenticated\n  const jws = await did.createJWS({ hello: 'world' })\n}\n</code></pre>","title":"Authenticate the user"},{"location":"reference/core-clients/did-jsonrpc/#enable-ceramic-transactions","text":"<pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { DID } from 'dids'\nimport { Ed25519Provider } from 'key-did-provider-ed25519'\nimport { getResolver } from 'key-did-resolver'\n\nconst ceramic = new CeramicClient()\n\n// `seed` must be a 32-byte long Uint8Array\nasync function authenticateCeramic(seed) {\n  const provider = new Ed25519Provider(seed)\n  const did = new DID({ provider, resolver: getResolver() })\n  // Authenticate the DID with the provider\n  await did.authenticate()\n  // The Ceramic client can create and update streams using the authenticated DID\n  ceramic.did = did\n}\n</code></pre>","title":"Enable Ceramic transactions"},{"location":"reference/core-clients/did-jsonrpc/#resolve-a-did-document","text":"<pre><code>import { DID } from 'dids'\nimport { getResolver } from 'key-did-resolver'\n\n// See https://github.com/decentralized-identity/did-resolver\nconst did = new DID({ resolver: getResolver() })\n\n// Resolve a DID document\nawait did.resolve('did:key:...')\n</code></pre>","title":"Resolve a DID document"},{"location":"reference/core-clients/did-jsonrpc/#store-signed-data-on-ipfs-using-dagjws","text":"<p>The DagJWS functionality of the DID library can be used in conjunction with IPFS.</p> <pre><code>const payload = { some: 'data' }\n\n// sign the payload as dag-jose\nconst { jws, linkedBlock } = await did.createDagJWS(payload)\n\n// put the JWS into the ipfs dag\nconst jwsCid = await ipfs.dag.put(jws, {\n  format: 'dag-jose',\n  hashAlg: 'sha2-256',\n})\n\n// put the payload into the ipfs dag\nconst block = await ipfs.block.put(linkedBlock, { cid: jws.link })\n\n// get the value of the payload using the payload cid\nconsole.log((await ipfs.dag.get(jws.link)).value)\n// output:\n// &gt; { some: 'data' }\n\n// alternatively get it using the ipld path from the JWS cid\nconsole.log((await ipfs.dag.get(jwsCid, { path: '/link' })).value)\n// output:\n// &gt; { some: 'data' }\n\n// get the jws from the dag\nconsole.log((await ipfs.dag.get(jwsCid)).value)\n// output:\n// &gt; {\n// &gt;   payload: 'AXESINDmZIeFXbbpBQWH1bXt7F2Ysg03pRcvzsvSc7vMNurc',\n// &gt;   signatures: [\n// &gt;     {\n// &gt;       protected: 'eyJraWQiOiJkaWQ6Mzp1bmRlZmluZWQ_dmVyc2lvbj0wI3NpZ25pbmciLCJhbGciOiJFUzI1NksifQ',\n// &gt;       signature: 'pNz3i10YMlv-BiVfqBbHvHQp5NH3x4TAHQ5oqSmNBUx1DH_MONa_VBZSP2o9r9epDdbRRBLQjrIeigdDWoXrBQ'\n// &gt;     }\n// &gt;   ],\n// &gt;   link: CID(bafyreigq4zsipbk5w3uqkbmh2w2633c5tcza2n5fc4x45s6soo54ynxk3q)\n// &gt; }\n</code></pre>","title":"Store signed data on IPFS using DagJWS"},{"location":"reference/core-clients/did-jsonrpc/#how-it-works","text":"<p>As can be observed above the createDagJWS method takes the payload, encodes it using dag-cbor and computes it's CID. It then uses this CID as the payload of the JWS that is then signed. The JWS that was just created can be put into ipfs using the dag-jose codec. Returned is also the encoded block of the payload. This can be put into ipfs using ipfs.block.put. Alternatively ipfs.dag.put(payload) would have the same effect.</p>","title":"How it Works"},{"location":"reference/core-clients/did-jsonrpc/#store-encrypted-data-on-ipfs-with-dagjwe","text":"<p>The DagJWE functionality allows us to encrypt IPLD data to one or multiple DIDs. The resulting JWE object can then be put into ipfs using the dag-jose codec. A user that is authenticated can at a later point decrypt this object.</p> <pre><code>const cleartext = { some: 'data', coolLink: new CID('bafyqacnbmrqxgzdgdeaui') }\n\n// encrypt the cleartext object\nconst jwe = await did.createDagJWE(cleartext, [\n  'did:3:bafy89h4f9...',\n  'did:key:za234...',\n])\n\n// put the JWE into the ipfs dag\nconst jweCid = await ipfs.dag.put(jwe, {\n  format: 'dag-jose',\n  hashAlg: 'sha2-256',\n})\n\n// get the jwe from the dag and decrypt it\nconst dagJWE = await ipfs.dag.get(jweCid)\nconsole.log(await did.decryptDagJWE(dagJWE))\n// output:\n// &gt; { some: 'data' }\n</code></pre>","title":"Store encrypted data on IPFS with DagJWE"},{"location":"reference/glaze/","text":"<p>Glaze suite includes a collection of tools for building applications on Ceramic, including data model management tools, runtime libraries for user-centric data storage and retrieval, and client-side tools for caching data from the network. Glaze modules can be used separately, but are best when used together.</p> <p></p>  <p> Before reading further and getting started using Glaze packages, you should be familiar with other Ceramic concepts previously presented, such as DIDs, authentication, schemas, streams and stream types.</p>","title":"Glaze Suite"},{"location":"reference/glaze/#data-model-management","text":"","title":"Data model management"},{"location":"reference/glaze/#deploy-from-javascript","text":"<p>The devtools module provides JavaScript APIs for managing and deploying the data models used by your Ceramic application.</p>","title":"Deploy from JavaScript \u2192"},{"location":"reference/glaze/#deploy-from-the-cli","text":"<p>The Glaze CLI provides a set of command-line tools for managing and deploying the data models used by your Ceramic application.</p>","title":"Deploy from the CLI \u2192"},{"location":"reference/glaze/#build-with-data-models","text":"","title":"Build with data models"},{"location":"reference/glaze/#user-centric-storage","text":"<p>The DID DataStore module provides read and write APIs allowing applications to interact with user data based on data model. DID DataStore also makes it possible for applications to discover all information about a user in one place, forming the basis for user-centric data composability on Ceramic.</p>","title":"User-centric storage \u2192"},{"location":"reference/glaze/#data-model-aliasing","text":"<p>The DataModel module provides human-readable aliasing for data models at runtime, making it easier to use the DID DataStore API.</p>","title":"Data model aliasing \u2192"},{"location":"reference/glaze/#client-side-caching","text":"","title":"Client-side caching"},{"location":"reference/glaze/#tile-loader","text":"<p>The tile loader module provides client-side batching and caching for Ceramic data, improving the performance of retrieving data from the network in order to populate your application.</p>","title":"Tile loader \u2192"},{"location":"reference/glaze/cli/","text":"","title":"Glaze CLI"},{"location":"reference/glaze/cli/#purpose","text":"<p>The Glaze CLI allows to interact with Ceramic nodes, notably to help support DataModel lifecycle operations, such as the creation, edition and publication of models.</p>","title":"Purpose"},{"location":"reference/glaze/cli/#installation","text":"<pre><code>npm install --global @glazed/cli\n</code></pre> <p>The CLI is then accessible as <code>glaze</code>. Run <code>glaze help</code> to list the available commands.</p>","title":"Installation"},{"location":"reference/glaze/cli/#common-use-cases","text":"","title":"Common use-cases"},{"location":"reference/glaze/cli/#create-a-key-did","text":"<p>CLI commands performing stream mutations require the 32-byte hexadecimal-encoded seed of a key DID to be provided, either as the <code>--key</code> flag or the <code>DID_KEY</code> environment variable:</p> <pre><code>glaze did:create\n</code></pre> <p>The expected output will be similar to the following, with <code>...</code> used as placeholder for brievety:</p> <pre><code>\u2714 Created DID did:key:z6Mk... with seed ab...f0\n</code></pre> <p>The seed can then be used when running other commands:</p> <pre><code>glaze [command] --key=ab...f0\nDID_KEY=ab...f0 glaze [command]\n</code></pre>","title":"Create a key DID"},{"location":"reference/glaze/cli/#create-a-local-model","text":"<p>Creating a local model can be done using the <code>model:create</code> command:</p> <pre><code>glaze model:create my-model\n</code></pre> <p>Note that this model is only stored on your local file system, it will not be available externally.</p>","title":"Create a local model"},{"location":"reference/glaze/cli/#add-a-schema-to-a-local-model","text":"<p>Schemas can be added to the model, either by using a Stream already present on the given Ceramic node:</p> Using an existing schemaCreating a new schema   <pre><code>glaze model:add my-model schema MySchema ceramic://k2...ab\n</code></pre>   <pre><code>glaze model:add my-model schema MySchema '{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"title\":\"MySchema\",\"type\":\"object\",\"properties\":{}}' --key=ab...f0\n</code></pre>    <p>The <code>model:add</code> command can be used in a similar way to add definitions (<code>model:add my-model definition ...</code>) and tiles (<code>model:add my-model tile ...</code>).</p>","title":"Add a schema to a local model"},{"location":"reference/glaze/cli/#import-an-existing-model","text":"<p>Existing models can be imported in a local model either using JSON files or locally installed packages (that can be imported by Node) using the <code>model:import</code> command:</p> Using a local fileUsing a package name   <pre><code>glaze model:import my-model ./model-to-import.json\n</code></pre>   <pre><code>glaze model:import my-model package-name-of-model\n</code></pre>","title":"Import an existing model"},{"location":"reference/glaze/cli/#export-a-local-model","text":"<p>A local model can be exported to a JSON file using the <code>model:export</code> command:</p> <pre><code>glaze model:export my-model ./my-model.json\n</code></pre>","title":"Export a local model"},{"location":"reference/glaze/cli/#deploy-a-model-to-ceramic","text":"<p>The <code>model:publish</code> command can be used to publish all the streams used by a given model:</p> Publishing a local modelPublishing a model filePublishing a model package   <pre><code>glaze model:publish my-model\n</code></pre>   <pre><code>glaze model:publish ./my-model.json\n</code></pre>   <pre><code>glaze model:publish package-name-of-model\n</code></pre>    <p>Optionally, a second argment can be provided to output the published model object to a JSON file:</p> <pre><code>glaze model:publish my-model ./published-model.json\n</code></pre> <p>This output file can then be used by the DataModel runtime.</p>","title":"Deploy a model to Ceramic"},{"location":"reference/glaze/cli/#publish-idx-models","text":"<p>In this example, we will import and publish the datamodels defined by the CIP-19 \"Basic Profile\", CIP-21 \"Crypto Accounts\" and CIP-23 \"Also Known As\" specifications.</p> <p>First, we need to install these datamodels using npm:</p> <pre><code>npm install --dev @datamodels/identity-profile-basic @datamodels/identity-accounts-crypto @datamodels/identity-accounts-web\n</code></pre> <p>We can then import them when using the CLI in a folder where these npm packages can be resolved from, using the steps described in other examples above:</p> <pre><code>glaze model:create idx\nglaze model:import idx @datamodels/identity-profile-basic\nglaze model:import idx @datamodels/identity-accounts-crypto\nglaze model:import idx @datamodels/identity-accounts-web\nglaze model:publish idx\n</code></pre>","title":"Publish IDX models"},{"location":"reference/glaze/classes/datamodel.DataModel/","text":"<p>datamodel.DataModel</p> <pre><code>import { DataModel } from '@glazed/datamodel'\n</code></pre>","title":"Class: DataModel&lt;ModelTypes, ModelAliases&gt;"},{"location":"reference/glaze/classes/datamodel.DataModel/#type-parameters","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code>   <code>ModelAliases</code> extends <code>ModelTypesToAliases</code>&lt;<code>ModelTypes</code>&gt; = <code>ModelTypesToAliases</code>&lt;<code>ModelTypes</code>&gt;","title":"Type parameters"},{"location":"reference/glaze/classes/datamodel.DataModel/#constructors","text":"","title":"Constructors"},{"location":"reference/glaze/classes/datamodel.DataModel/#constructor","text":"<p>\u2022 new DataModel&lt;<code>ModelTypes</code>, <code>ModelAliases</code>&gt;(<code>params</code>)</p>","title":"constructor"},{"location":"reference/glaze/classes/datamodel.DataModel/#type-parameters_1","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt;   <code>ModelAliases</code> extends <code>ModelTypesToAliases</code>&lt;<code>ModelTypes</code>&gt; = <code>ModelTypesToAliases</code>&lt;<code>ModelTypes</code>&gt;","title":"Type parameters"},{"location":"reference/glaze/classes/datamodel.DataModel/#parameters","text":"Name Type     <code>params</code> <code>DataModelParams</code>&lt;<code>ModelAliases</code>&gt;","title":"Parameters"},{"location":"reference/glaze/classes/datamodel.DataModel/#accessors","text":"","title":"Accessors"},{"location":"reference/glaze/classes/datamodel.DataModel/#loader","text":"<p>\u2022 <code>get</code> loader(): <code>TileLoader</code></p>","title":"loader"},{"location":"reference/glaze/classes/datamodel.DataModel/#returns","text":"<p><code>TileLoader</code></p>","title":"Returns"},{"location":"reference/glaze/classes/datamodel.DataModel/#methods","text":"","title":"Methods"},{"location":"reference/glaze/classes/datamodel.DataModel/#createtile","text":"<p>\u25b8 createTile&lt;<code>Alias</code>, <code>ContentType</code>&gt;(<code>schemaAlias</code>, <code>content</code>, <code>__namedParameters?</code>): <code>Promise</code>&lt;<code>TileDocument</code>&lt;<code>ContentType</code>&gt;&gt;</p> <p>Create a TileDocument using a schema identified by the given <code>schemaAlias</code>.</p>","title":"createTile"},{"location":"reference/glaze/classes/datamodel.DataModel/#type-parameters_2","text":"Name Type     <code>Alias</code> extends <code>string</code> | <code>number</code> | <code>symbol</code>   <code>ContentType</code> <code>ModelTypes</code>[<code>\"schemas\"</code>][<code>Alias</code>]","title":"Type parameters"},{"location":"reference/glaze/classes/datamodel.DataModel/#parameters_1","text":"Name Type     <code>schemaAlias</code> <code>Alias</code>   <code>content</code> <code>ContentType</code>   <code>__namedParameters</code> <code>CreateOptions</code>","title":"Parameters"},{"location":"reference/glaze/classes/datamodel.DataModel/#returns_1","text":"<p><code>Promise</code>&lt;<code>TileDocument</code>&lt;<code>ContentType</code>&gt;&gt;</p>","title":"Returns"},{"location":"reference/glaze/classes/datamodel.DataModel/#getdefinitionid","text":"<p>\u25b8 getDefinitionID&lt;<code>Alias</code>&gt;(<code>alias</code>): <code>null</code> | <code>string</code></p>","title":"getDefinitionID"},{"location":"reference/glaze/classes/datamodel.DataModel/#type-parameters_3","text":"Name Type     <code>Alias</code> extends <code>string</code> | <code>number</code> | <code>symbol</code>","title":"Type parameters"},{"location":"reference/glaze/classes/datamodel.DataModel/#parameters_2","text":"Name Type     <code>alias</code> <code>Alias</code>","title":"Parameters"},{"location":"reference/glaze/classes/datamodel.DataModel/#returns_2","text":"<p><code>null</code> | <code>string</code></p>","title":"Returns"},{"location":"reference/glaze/classes/datamodel.DataModel/#getschemaurl","text":"<p>\u25b8 getSchemaURL&lt;<code>Alias</code>&gt;(<code>alias</code>): <code>null</code> | <code>string</code></p>","title":"getSchemaURL"},{"location":"reference/glaze/classes/datamodel.DataModel/#type-parameters_4","text":"Name Type     <code>Alias</code> extends <code>string</code> | <code>number</code> | <code>symbol</code>","title":"Type parameters"},{"location":"reference/glaze/classes/datamodel.DataModel/#parameters_3","text":"Name Type     <code>alias</code> <code>Alias</code>","title":"Parameters"},{"location":"reference/glaze/classes/datamodel.DataModel/#returns_3","text":"<p><code>null</code> | <code>string</code></p>","title":"Returns"},{"location":"reference/glaze/classes/datamodel.DataModel/#gettileid","text":"<p>\u25b8 getTileID&lt;<code>Alias</code>&gt;(<code>alias</code>): <code>null</code> | <code>string</code></p>","title":"getTileID"},{"location":"reference/glaze/classes/datamodel.DataModel/#type-parameters_5","text":"Name Type     <code>Alias</code> extends <code>string</code> | <code>number</code> | <code>symbol</code>","title":"Type parameters"},{"location":"reference/glaze/classes/datamodel.DataModel/#parameters_4","text":"Name Type     <code>alias</code> <code>Alias</code>","title":"Parameters"},{"location":"reference/glaze/classes/datamodel.DataModel/#returns_4","text":"<p><code>null</code> | <code>string</code></p>","title":"Returns"},{"location":"reference/glaze/classes/datamodel.DataModel/#loadtile","text":"<p>\u25b8 loadTile&lt;<code>Alias</code>, <code>ContentType</code>&gt;(<code>alias</code>): <code>Promise</code>&lt;<code>null</code> | <code>TileDocument</code>&lt;<code>ContentType</code>&gt;&gt;</p> <p>Load the TileDocument identified by the given <code>alias</code>.</p>","title":"loadTile"},{"location":"reference/glaze/classes/datamodel.DataModel/#type-parameters_6","text":"Name Type     <code>Alias</code> extends <code>string</code> | <code>number</code> | <code>symbol</code>   <code>ContentType</code> <code>ModelTypes</code>[<code>\"schemas\"</code>][<code>ModelTypes</code>[<code>\"tiles\"</code>][<code>Alias</code>]]","title":"Type parameters"},{"location":"reference/glaze/classes/datamodel.DataModel/#parameters_5","text":"Name Type     <code>alias</code> <code>Alias</code>","title":"Parameters"},{"location":"reference/glaze/classes/datamodel.DataModel/#returns_5","text":"<p><code>Promise</code>&lt;<code>null</code> | <code>TileDocument</code>&lt;<code>ContentType</code>&gt;&gt;</p>","title":"Returns"},{"location":"reference/glaze/classes/devtools.ModelManager/","text":"<p>devtools.ModelManager</p> <pre><code>import { ModelManager } from '@glazed/devtools'\n</code></pre>","title":"Class: ModelManager"},{"location":"reference/glaze/classes/devtools.ModelManager/#constructors","text":"","title":"Constructors"},{"location":"reference/glaze/classes/devtools.ModelManager/#constructor","text":"<p>\u2022 new ModelManager(<code>ceramic</code>, <code>model?</code>)</p>","title":"constructor"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters","text":"Name Type     <code>ceramic</code> <code>CeramicApi</code>   <code>model?</code> <code>ManagedModel</code>&lt;<code>DagJWSResult</code>&gt;","title":"Parameters"},{"location":"reference/glaze/classes/devtools.ModelManager/#accessors","text":"","title":"Accessors"},{"location":"reference/glaze/classes/devtools.ModelManager/#definitions","text":"<p>\u2022 <code>get</code> definitions(): <code>string</code>[]</p>","title":"definitions"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns","text":"<p><code>string</code>[]</p>","title":"Returns"},{"location":"reference/glaze/classes/devtools.ModelManager/#model","text":"<p>\u2022 <code>get</code> model(): <code>ManagedModel</code>&lt;<code>DagJWSResult</code>&gt;</p>","title":"model"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_1","text":"<p><code>ManagedModel</code>&lt;<code>DagJWSResult</code>&gt;</p>","title":"Returns"},{"location":"reference/glaze/classes/devtools.ModelManager/#schemas","text":"<p>\u2022 <code>get</code> schemas(): <code>string</code>[]</p>","title":"schemas"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_2","text":"<p><code>string</code>[]</p>","title":"Returns"},{"location":"reference/glaze/classes/devtools.ModelManager/#tiles","text":"<p>\u2022 <code>get</code> tiles(): <code>string</code>[]</p>","title":"tiles"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_3","text":"<p><code>string</code>[]</p>","title":"Returns"},{"location":"reference/glaze/classes/devtools.ModelManager/#methods","text":"","title":"Methods"},{"location":"reference/glaze/classes/devtools.ModelManager/#addjsonmodel","text":"<p>\u25b8 addJSONModel(<code>encoded</code>): <code>void</code></p>","title":"addJSONModel"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_1","text":"Name Type     <code>encoded</code> <code>EncodedManagedModel</code>","title":"Parameters"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_4","text":"<p><code>void</code></p>","title":"Returns"},{"location":"reference/glaze/classes/devtools.ModelManager/#addmodel","text":"<p>\u25b8 addModel(<code>model</code>): <code>void</code></p>","title":"addModel"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_2","text":"Name Type     <code>model</code> <code>ManagedModel</code>&lt;<code>DagJWSResult</code>&gt;","title":"Parameters"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_5","text":"<p><code>void</code></p>","title":"Returns"},{"location":"reference/glaze/classes/devtools.ModelManager/#create","text":"<p>\u25b8 create&lt;<code>T</code>, <code>Content</code>&gt;(<code>type</code>, <code>alias</code>, <code>content</code>, <code>meta?</code>): <code>Promise</code>&lt;<code>string</code>&gt;</p>","title":"create"},{"location":"reference/glaze/classes/devtools.ModelManager/#type-parameters","text":"Name Type     <code>T</code> extends keyof <code>CreateContentType</code>   <code>Content</code> <code>CreateContentType</code>[<code>T</code>]","title":"Type parameters"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_3","text":"Name Type     <code>type</code> <code>T</code>   <code>alias</code> <code>string</code>   <code>content</code> <code>Content</code>   <code>meta?</code> <code>Partial</code>&lt;<code>StreamMetadata</code>&gt;","title":"Parameters"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_6","text":"<p><code>Promise</code>&lt;<code>string</code>&gt;</p>","title":"Returns"},{"location":"reference/glaze/classes/devtools.ModelManager/#createdefinition","text":"<p>\u25b8 createDefinition(<code>alias</code>, <code>definition</code>): <code>Promise</code>&lt;<code>string</code>&gt;</p>","title":"createDefinition"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_4","text":"Name Type     <code>alias</code> <code>string</code>   <code>definition</code> <code>Definition</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;&gt;","title":"Parameters"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_7","text":"<p><code>Promise</code>&lt;<code>string</code>&gt;</p>","title":"Returns"},{"location":"reference/glaze/classes/devtools.ModelManager/#createschema","text":"<p>\u25b8 createSchema(<code>alias</code>, <code>schema</code>): <code>Promise</code>&lt;<code>string</code>&gt;</p>","title":"createSchema"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_5","text":"Name Type     <code>alias</code> <code>string</code>   <code>schema</code> <code>Schema</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;&gt;","title":"Parameters"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_8","text":"<p><code>Promise</code>&lt;<code>string</code>&gt;</p>","title":"Returns"},{"location":"reference/glaze/classes/devtools.ModelManager/#createtile","text":"<p>\u25b8 createTile&lt;<code>T</code>&gt;(<code>alias</code>, <code>contents</code>, <code>meta?</code>): <code>Promise</code>&lt;<code>string</code>&gt;</p>","title":"createTile"},{"location":"reference/glaze/classes/devtools.ModelManager/#type-parameters_1","text":"Name Type     <code>T</code> extends <code>Record</code>&lt;<code>string</code>, <code>unknown</code>&gt;","title":"Type parameters"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_6","text":"Name Type     <code>alias</code> <code>string</code>   <code>contents</code> <code>T</code>   <code>meta</code> <code>Partial</code>&lt;<code>StreamMetadata</code>&gt;","title":"Parameters"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_9","text":"<p><code>Promise</code>&lt;<code>string</code>&gt;</p>","title":"Returns"},{"location":"reference/glaze/classes/devtools.ModelManager/#getdefinition","text":"<p>\u25b8 getDefinition(<code>id</code>): <code>null</code> | <code>ManagedEntry</code>&lt;<code>DagJWSResult</code>&gt;</p>","title":"getDefinition"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_7","text":"Name Type     <code>id</code> <code>string</code>","title":"Parameters"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_10","text":"<p><code>null</code> | <code>ManagedEntry</code>&lt;<code>DagJWSResult</code>&gt;</p>","title":"Returns"},{"location":"reference/glaze/classes/devtools.ModelManager/#getdefinitionid","text":"<p>\u25b8 getDefinitionID(<code>alias</code>): <code>null</code> | <code>string</code></p>","title":"getDefinitionID"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_8","text":"Name Type     <code>alias</code> <code>string</code>","title":"Parameters"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_11","text":"<p><code>null</code> | <code>string</code></p>","title":"Returns"},{"location":"reference/glaze/classes/devtools.ModelManager/#getschema","text":"<p>\u25b8 getSchema(<code>id</code>): <code>null</code> | <code>ManagedSchema</code>&lt;<code>DagJWSResult</code>&gt;</p>","title":"getSchema"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_9","text":"Name Type     <code>id</code> <code>string</code>","title":"Parameters"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_12","text":"<p><code>null</code> | <code>ManagedSchema</code>&lt;<code>DagJWSResult</code>&gt;</p>","title":"Returns"},{"location":"reference/glaze/classes/devtools.ModelManager/#getschemabyalias","text":"<p>\u25b8 getSchemaByAlias(<code>alias</code>): <code>null</code> | <code>ManagedSchema</code>&lt;<code>DagJWSResult</code>&gt;</p>","title":"getSchemaByAlias"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_10","text":"Name Type     <code>alias</code> <code>string</code>","title":"Parameters"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_13","text":"<p><code>null</code> | <code>ManagedSchema</code>&lt;<code>DagJWSResult</code>&gt;</p>","title":"Returns"},{"location":"reference/glaze/classes/devtools.ModelManager/#getschemaid","text":"<p>\u25b8 getSchemaID(<code>alias</code>): <code>null</code> | <code>string</code></p>","title":"getSchemaID"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_11","text":"Name Type     <code>alias</code> <code>string</code>","title":"Parameters"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_14","text":"<p><code>null</code> | <code>string</code></p>","title":"Returns"},{"location":"reference/glaze/classes/devtools.ModelManager/#getschemaurl","text":"<p>\u25b8 getSchemaURL(<code>id</code>): <code>null</code> | <code>string</code></p>","title":"getSchemaURL"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_12","text":"Name Type     <code>id</code> <code>string</code>","title":"Parameters"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_15","text":"<p><code>null</code> | <code>string</code></p>","title":"Returns"},{"location":"reference/glaze/classes/devtools.ModelManager/#gettile","text":"<p>\u25b8 getTile(<code>id</code>): <code>null</code> | <code>ManagedEntry</code>&lt;<code>DagJWSResult</code>&gt;</p>","title":"getTile"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_13","text":"Name Type     <code>id</code> <code>string</code>","title":"Parameters"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_16","text":"<p><code>null</code> | <code>ManagedEntry</code>&lt;<code>DagJWSResult</code>&gt;</p>","title":"Returns"},{"location":"reference/glaze/classes/devtools.ModelManager/#gettileid","text":"<p>\u25b8 getTileID(<code>alias</code>): <code>null</code> | <code>string</code></p>","title":"getTileID"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_14","text":"Name Type     <code>alias</code> <code>string</code>","title":"Parameters"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_17","text":"<p><code>null</code> | <code>string</code></p>","title":"Returns"},{"location":"reference/glaze/classes/devtools.ModelManager/#hasdefinitionalias","text":"<p>\u25b8 hasDefinitionAlias(<code>alias</code>): <code>boolean</code></p>","title":"hasDefinitionAlias"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_15","text":"Name Type     <code>alias</code> <code>string</code>","title":"Parameters"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_18","text":"<p><code>boolean</code></p>","title":"Returns"},{"location":"reference/glaze/classes/devtools.ModelManager/#hasschemaalias","text":"<p>\u25b8 hasSchemaAlias(<code>alias</code>): <code>boolean</code></p>","title":"hasSchemaAlias"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_16","text":"Name Type     <code>alias</code> <code>string</code>","title":"Parameters"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_19","text":"<p><code>boolean</code></p>","title":"Returns"},{"location":"reference/glaze/classes/devtools.ModelManager/#hastilealias","text":"<p>\u25b8 hasTileAlias(<code>alias</code>): <code>boolean</code></p>","title":"hasTileAlias"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_17","text":"Name Type     <code>alias</code> <code>string</code>","title":"Parameters"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_20","text":"<p><code>boolean</code></p>","title":"Returns"},{"location":"reference/glaze/classes/devtools.ModelManager/#loadcommits","text":"<p>\u25b8 loadCommits(<code>id</code>): <code>Promise</code>&lt;<code>DagJWSResult</code>[]&gt;</p>","title":"loadCommits"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_18","text":"Name Type     <code>id</code> <code>string</code>","title":"Parameters"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_21","text":"<p><code>Promise</code>&lt;<code>DagJWSResult</code>[]&gt;</p>","title":"Returns"},{"location":"reference/glaze/classes/devtools.ModelManager/#loadschema","text":"<p>\u25b8 loadSchema(<code>id</code>, <code>alias?</code>): <code>Promise</code>&lt;<code>string</code>&gt;</p>","title":"loadSchema"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_19","text":"Name Type     <code>id</code> <code>string</code> | <code>StreamRef</code>   <code>alias?</code> <code>string</code>","title":"Parameters"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_22","text":"<p><code>Promise</code>&lt;<code>string</code>&gt;</p>","title":"Returns"},{"location":"reference/glaze/classes/devtools.ModelManager/#loadschemadependencies","text":"<p>\u25b8 loadSchemaDependencies(<code>schema</code>): <code>Promise</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>string</code>[]&gt;&gt;</p>","title":"loadSchemaDependencies"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_20","text":"Name Type     <code>schema</code> <code>Schema</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;&gt;","title":"Parameters"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_23","text":"<p><code>Promise</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>string</code>[]&gt;&gt;</p>","title":"Returns"},{"location":"reference/glaze/classes/devtools.ModelManager/#loadstream","text":"<p>\u25b8 loadStream(<code>streamID</code>): <code>Promise</code>&lt;<code>TileDocument</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;&gt;&gt;</p>","title":"loadStream"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_21","text":"Name Type     <code>streamID</code> <code>string</code> | <code>StreamRef</code>","title":"Parameters"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_24","text":"<p><code>Promise</code>&lt;<code>TileDocument</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;&gt;&gt;</p>","title":"Returns"},{"location":"reference/glaze/classes/devtools.ModelManager/#tojson","text":"<p>\u25b8 toJSON(): <code>EncodedManagedModel</code></p>","title":"toJSON"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_25","text":"<p><code>EncodedManagedModel</code></p>","title":"Returns"},{"location":"reference/glaze/classes/devtools.ModelManager/#topublished","text":"<p>\u25b8 toPublished(): <code>Promise</code>&lt;<code>ModelData</code>&lt;<code>string</code>&gt;&gt;</p>","title":"toPublished"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_26","text":"<p><code>Promise</code>&lt;<code>ModelData</code>&lt;<code>string</code>&gt;&gt;</p>","title":"Returns"},{"location":"reference/glaze/classes/devtools.ModelManager/#usepublished","text":"<p>\u25b8 usePublished&lt;<code>T</code>, <code>ID</code>&gt;(<code>type</code>, <code>alias</code>, <code>id</code>): <code>Promise</code>&lt;<code>string</code>&gt;</p>","title":"usePublished"},{"location":"reference/glaze/classes/devtools.ModelManager/#type-parameters_2","text":"Name Type     <code>T</code> extends keyof <code>UsePublishedIDType</code>   <code>ID</code> <code>UsePublishedIDType</code>[<code>T</code>]","title":"Type parameters"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_22","text":"Name Type     <code>type</code> <code>T</code>   <code>alias</code> <code>string</code>   <code>id</code> <code>ID</code>","title":"Parameters"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_27","text":"<p><code>Promise</code>&lt;<code>string</code>&gt;</p>","title":"Returns"},{"location":"reference/glaze/classes/devtools.ModelManager/#usepublisheddefinition","text":"<p>\u25b8 usePublishedDefinition(<code>alias</code>, <code>id</code>): <code>Promise</code>&lt;<code>string</code>&gt;</p>","title":"usePublishedDefinition"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_23","text":"Name Type     <code>alias</code> <code>string</code>   <code>id</code> <code>string</code> | <code>StreamID</code>","title":"Parameters"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_28","text":"<p><code>Promise</code>&lt;<code>string</code>&gt;</p>","title":"Returns"},{"location":"reference/glaze/classes/devtools.ModelManager/#usepublishedschema","text":"<p>\u25b8 usePublishedSchema(<code>alias</code>, <code>id</code>): <code>Promise</code>&lt;<code>string</code>&gt;</p>","title":"usePublishedSchema"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_24","text":"Name Type     <code>alias</code> <code>string</code>   <code>id</code> <code>string</code> | <code>StreamRef</code>","title":"Parameters"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_29","text":"<p><code>Promise</code>&lt;<code>string</code>&gt;</p>","title":"Returns"},{"location":"reference/glaze/classes/devtools.ModelManager/#usepublishedtile","text":"<p>\u25b8 usePublishedTile(<code>alias</code>, <code>id</code>): <code>Promise</code>&lt;<code>string</code>&gt;</p>","title":"usePublishedTile"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_25","text":"Name Type     <code>alias</code> <code>string</code>   <code>id</code> <code>string</code> | <code>StreamID</code>","title":"Parameters"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_30","text":"<p><code>Promise</code>&lt;<code>string</code>&gt;</p>","title":"Returns"},{"location":"reference/glaze/classes/devtools.ModelManager/#fromjson","text":"<p>\u25b8 <code>Static</code> fromJSON(<code>ceramic</code>, <code>encoded</code>): <code>ModelManager</code></p>","title":"fromJSON"},{"location":"reference/glaze/classes/devtools.ModelManager/#parameters_26","text":"Name Type     <code>ceramic</code> <code>CeramicApi</code>   <code>encoded</code> <code>EncodedManagedModel</code>","title":"Parameters"},{"location":"reference/glaze/classes/devtools.ModelManager/#returns_31","text":"<p><code>ModelManager</code></p>","title":"Returns"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/","text":"<p>did-datastore.DIDDataStore</p> <pre><code>import { DIDDataStore } from '@glazed/did-datastore'\n</code></pre>","title":"Class: DIDDataStore&lt;ModelTypes, Alias&gt;"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#type-parameters","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code> = <code>ModelTypeAliases</code>   <code>Alias</code> extends keyof <code>ModelTypes</code>[<code>\"definitions\"</code>] = keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]","title":"Type parameters"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#constructors","text":"","title":"Constructors"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#constructor","text":"<p>\u2022 new DIDDataStore&lt;<code>ModelTypes</code>, <code>Alias</code>&gt;(<code>params</code>)</p>","title":"constructor"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#type-parameters_1","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt; = <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt;   <code>Alias</code> extends <code>string</code> | <code>number</code> | <code>symbol</code> = keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]","title":"Type parameters"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#parameters","text":"Name Type     <code>params</code> <code>DIDDataStoreParams</code>&lt;<code>ModelTypes</code>&gt;","title":"Parameters"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#accessors","text":"","title":"Accessors"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#authenticated","text":"<p>\u2022 <code>get</code> authenticated(): <code>boolean</code></p>","title":"authenticated"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns","text":"<p><code>boolean</code></p>","title":"Returns"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#ceramic","text":"<p>\u2022 <code>get</code> ceramic(): <code>CeramicApi</code></p>","title":"ceramic"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns_1","text":"<p><code>CeramicApi</code></p>","title":"Returns"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#id","text":"<p>\u2022 <code>get</code> id(): <code>string</code></p>","title":"id"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns_2","text":"<p><code>string</code></p>","title":"Returns"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#loader","text":"<p>\u2022 <code>get</code> loader(): <code>TileLoader</code></p>","title":"loader"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns_3","text":"<p><code>TileLoader</code></p>","title":"Returns"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#model","text":"<p>\u2022 <code>get</code> model(): <code>DataModel</code>&lt;<code>ModelTypes</code>, <code>ModelTypesToAliases</code>&lt;<code>ModelTypes</code>&gt;&gt;</p>","title":"model"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns_4","text":"<p><code>DataModel</code>&lt;<code>ModelTypes</code>, <code>ModelTypesToAliases</code>&lt;<code>ModelTypes</code>&gt;&gt;</p>","title":"Returns"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#methods","text":"","title":"Methods"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#get","text":"<p>\u25b8 get&lt;<code>Key</code>, <code>ContentType</code>&gt;(<code>key</code>, <code>did?</code>): <code>Promise</code>&lt;<code>null</code> | <code>ContentType</code>&gt;</p> <p>Get the record contents.</p>","title":"get"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#type-parameters_2","text":"Name Type     <code>Key</code> extends <code>string</code> | <code>number</code> | <code>symbol</code>   <code>ContentType</code> <code>DefinitionContentType</code>&lt;<code>ModelTypes</code>, <code>Key</code>&gt;","title":"Type parameters"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#parameters_1","text":"Name Type     <code>key</code> <code>Key</code>   <code>did?</code> <code>string</code>","title":"Parameters"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns_5","text":"<p><code>Promise</code>&lt;<code>null</code> | <code>ContentType</code>&gt;</p>","title":"Returns"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#getdefinition","text":"<p>\u25b8 getDefinition(<code>id</code>): <code>Promise</code>&lt;<code>DefinitionWithID</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>unknown</code>&gt;&gt;&gt;</p> <p>Load and validate a definition by its ID.</p>","title":"getDefinition"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#parameters_2","text":"Name Type     <code>id</code> <code>string</code> | <code>StreamID</code>","title":"Parameters"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns_6","text":"<p><code>Promise</code>&lt;<code>DefinitionWithID</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>unknown</code>&gt;&gt;&gt;</p>","title":"Returns"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#getdefinitionid","text":"<p>\u25b8 getDefinitionID(<code>aliasOrID</code>): <code>string</code></p> <p>Get the definition ID for the given alias.</p>","title":"getDefinitionID"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#parameters_3","text":"Name Type     <code>aliasOrID</code> <code>string</code>","title":"Parameters"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns_7","text":"<p><code>string</code></p>","title":"Returns"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#getindex","text":"<p>\u25b8 getIndex(<code>did?</code>): <code>Promise</code>&lt;<code>null</code> | <code>IdentityIndex</code>&gt;</p> <p>Load the full index contents.</p>","title":"getIndex"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#parameters_4","text":"Name Type     <code>did</code> <code>string</code>","title":"Parameters"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns_8","text":"<p><code>Promise</code>&lt;<code>null</code> | <code>IdentityIndex</code>&gt;</p>","title":"Returns"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#getmultiple","text":"<p>\u25b8 getMultiple&lt;<code>Key</code>, <code>ContentType</code>&gt;(<code>key</code>, <code>dids</code>): <code>Promise</code>&lt;(<code>null</code> | <code>ContentType</code>)[]&gt;</p> <p>Get the record contents for multiple DIDs at once.</p>","title":"getMultiple"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#type-parameters_3","text":"Name Type     <code>Key</code> extends <code>string</code> | <code>number</code> | <code>symbol</code>   <code>ContentType</code> <code>DefinitionContentType</code>&lt;<code>ModelTypes</code>, <code>Key</code>&gt;","title":"Type parameters"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#parameters_5","text":"Name Type     <code>key</code> <code>Key</code>   <code>dids</code> <code>string</code>[]","title":"Parameters"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns_9","text":"<p><code>Promise</code>&lt;(<code>null</code> | <code>ContentType</code>)[]&gt;</p>","title":"Returns"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#getrecord","text":"<p>\u25b8 getRecord&lt;<code>ContentType</code>&gt;(<code>definitionID</code>, <code>did?</code>): <code>Promise</code>&lt;<code>null</code> | <code>ContentType</code>&gt;</p> <p>Load a record contents for the given definition ID.</p>","title":"getRecord"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#type-parameters_4","text":"Name Type     <code>ContentType</code> <code>unknown</code>","title":"Type parameters"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#parameters_6","text":"Name Type     <code>definitionID</code> <code>string</code>   <code>did?</code> <code>string</code>","title":"Parameters"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns_10","text":"<p><code>Promise</code>&lt;<code>null</code> | <code>ContentType</code>&gt;</p>","title":"Returns"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#getrecorddocument","text":"<p>\u25b8 getRecordDocument(<code>definitionID</code>, <code>did?</code>): <code>Promise</code>&lt;<code>null</code> | <code>TileDoc</code>&gt;</p> <p>Load a record TileDocument for the given definition ID.</p>","title":"getRecordDocument"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#parameters_7","text":"Name Type     <code>definitionID</code> <code>string</code>   <code>did?</code> <code>string</code>","title":"Parameters"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns_11","text":"<p><code>Promise</code>&lt;<code>null</code> | <code>TileDoc</code>&gt;</p>","title":"Returns"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#getrecordid","text":"<p>\u25b8 getRecordID(<code>definitionID</code>, <code>did?</code>): <code>Promise</code>&lt;<code>null</code> | <code>string</code>&gt;</p> <p>Load a record ID in the index for the given definition ID.</p>","title":"getRecordID"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#parameters_8","text":"Name Type     <code>definitionID</code> <code>string</code>   <code>did?</code> <code>string</code>","title":"Parameters"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns_12","text":"<p><code>Promise</code>&lt;<code>null</code> | <code>string</code>&gt;</p>","title":"Returns"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#has","text":"<p>\u25b8 has(<code>key</code>, <code>did?</code>): <code>Promise</code>&lt;<code>boolean</code>&gt;</p> <p>Returns whether a record exists in the index or not.</p>","title":"has"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#parameters_9","text":"Name Type     <code>key</code> <code>Alias</code>   <code>did?</code> <code>string</code>","title":"Parameters"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns_13","text":"<p><code>Promise</code>&lt;<code>boolean</code>&gt;</p>","title":"Returns"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#iterator","text":"<p>\u25b8 iterator(<code>did?</code>): <code>AsyncIterableIterator</code>&lt;<code>Entry</code>&gt;</p> <p>Asynchronously iterate over the entries of the index, loading one record at a time.</p>","title":"iterator"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#parameters_10","text":"Name Type     <code>did?</code> <code>string</code>","title":"Parameters"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns_14","text":"<p><code>AsyncIterableIterator</code>&lt;<code>Entry</code>&gt;</p>","title":"Returns"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#merge","text":"<p>\u25b8 merge&lt;<code>Key</code>, <code>ContentType</code>&gt;(<code>key</code>, <code>content</code>, <code>options?</code>): <code>Promise</code>&lt;<code>StreamID</code>&gt;</p> <p>Perform a shallow (one level) merge of the record contents.</p>","title":"merge"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#type-parameters_5","text":"Name Type     <code>Key</code> extends <code>string</code> | <code>number</code> | <code>symbol</code>   <code>ContentType</code> <code>DefinitionContentType</code>&lt;<code>ModelTypes</code>, <code>Key</code>&gt;","title":"Type parameters"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#parameters_11","text":"Name Type     <code>key</code> <code>Key</code>   <code>content</code> <code>ContentType</code>   <code>options</code> <code>CreateOptions</code>","title":"Parameters"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns_15","text":"<p><code>Promise</code>&lt;<code>StreamID</code>&gt;</p>","title":"Returns"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#remove","text":"<p>\u25b8 remove(<code>key</code>, <code>controller?</code>): <code>Promise</code>&lt;<code>void</code>&gt;</p> <p>Remove a record from the index.</p> <p>Notice: this does not change the contents of the record itself, only the index.</p>","title":"remove"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#parameters_12","text":"Name Type     <code>key</code> <code>Alias</code>   <code>controller</code> <code>string</code>","title":"Parameters"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns_16","text":"<p><code>Promise</code>&lt;<code>void</code>&gt;</p>","title":"Returns"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#set","text":"<p>\u25b8 set&lt;<code>Key</code>, <code>ContentType</code>&gt;(<code>key</code>, <code>content</code>, <code>options?</code>): <code>Promise</code>&lt;<code>StreamID</code>&gt;</p> <p>Set the record contents.</p> <p>Warning: calling this method replaces any existing contents in the record, use <code>merge</code> if you want to only change some fields.</p>","title":"set"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#type-parameters_6","text":"Name Type     <code>Key</code> extends <code>string</code> | <code>number</code> | <code>symbol</code>   <code>ContentType</code> <code>DefinitionContentType</code>&lt;<code>ModelTypes</code>, <code>Key</code>&gt;","title":"Type parameters"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#parameters_13","text":"Name Type     <code>key</code> <code>Key</code>   <code>content</code> <code>ContentType</code>   <code>options</code> <code>CreateOptions</code>","title":"Parameters"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns_17","text":"<p><code>Promise</code>&lt;<code>StreamID</code>&gt;</p>","title":"Returns"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#setall","text":"<p>\u25b8 setAll&lt;<code>Contents</code>&gt;(<code>contents</code>, <code>options?</code>): <code>Promise</code>&lt;<code>IdentityIndex</code>&gt;</p> <p>Set the contents of multiple records at once. The index only gets updated after all wanted records have been written.</p> <p>Warning: calling this method replaces any existing contents in the records.</p>","title":"setAll"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#type-parameters_7","text":"Name Type     <code>Contents</code> extends <code>DefinitionsContentTypes</code>&lt;<code>ModelTypes</code>, <code>Record</code>&lt;<code>string</code>, <code>unknown</code>&gt;&gt;","title":"Type parameters"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#parameters_14","text":"Name Type     <code>contents</code> <code>Contents</code>   <code>options</code> <code>CreateOptions</code>","title":"Parameters"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns_18","text":"<p><code>Promise</code>&lt;<code>IdentityIndex</code>&gt;</p>","title":"Returns"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#setdefaults","text":"<p>\u25b8 setDefaults&lt;<code>Contents</code>&gt;(<code>contents</code>, <code>options?</code>): <code>Promise</code>&lt;<code>IdentityIndex</code>&gt;</p> <p>Set the contents of multiple records if they are not already set in the index.</p>","title":"setDefaults"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#type-parameters_8","text":"Name Type     <code>Contents</code> extends <code>DefinitionsContentTypes</code>&lt;<code>ModelTypes</code>, <code>Record</code>&lt;<code>string</code>, <code>unknown</code>&gt;&gt;","title":"Type parameters"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#parameters_15","text":"Name Type     <code>contents</code> <code>Contents</code>   <code>options</code> <code>CreateOptions</code>","title":"Parameters"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns_19","text":"<p><code>Promise</code>&lt;<code>IdentityIndex</code>&gt;</p>","title":"Returns"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#setrecord","text":"<p>\u25b8 setRecord(<code>definitionID</code>, <code>content</code>, <code>options?</code>): <code>Promise</code>&lt;<code>StreamID</code>&gt;</p> <p>Set the contents of a record for the given definition ID.</p>","title":"setRecord"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#parameters_16","text":"Name Type     <code>definitionID</code> <code>string</code>   <code>content</code> <code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;   <code>options</code> <code>CreateOptions</code>","title":"Parameters"},{"location":"reference/glaze/classes/did_datastore.DIDDataStore/#returns_20","text":"<p><code>Promise</code>&lt;<code>StreamID</code>&gt;</p>","title":"Returns"},{"location":"reference/glaze/classes/tile_loader.TileLoader/","text":"<p>tile-loader.TileLoader</p> <p>A TileLoader extends DataLoader to provide batching and caching functionalities for loading TileDocument streams.</p>","title":"Class: TileLoader"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#hierarchy","text":"<ul> <li><code>DataLoader</code>&lt;<code>TileKey</code>, <code>TileDocument</code>&gt;</li> </ul> <p>\u21b3 <code>TileLoader</code></p>","title":"Hierarchy"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#constructors","text":"","title":"Constructors"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#constructor","text":"<p>\u2022 new TileLoader(<code>params</code>)</p>","title":"constructor"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#parameters","text":"Name Type     <code>params</code> <code>TileLoaderParams</code>","title":"Parameters"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#overrides","text":"<p>DataLoader&lt;TileKey, TileDocument\\&gt;.constructor</p>","title":"Overrides"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#methods","text":"","title":"Methods"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#cache","text":"<p>\u25b8 cache(<code>stream</code>): <code>boolean</code></p> <p>Add a TileDocument to the local cache if enabled.</p>","title":"cache"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#parameters_1","text":"Name Type     <code>stream</code> <code>TileDocument</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;&gt;","title":"Parameters"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#returns","text":"<p><code>boolean</code></p>","title":"Returns"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#create","text":"<p>\u25b8 create&lt;<code>T</code>&gt;(<code>content</code>, <code>metadata?</code>, <code>options?</code>): <code>Promise</code>&lt;<code>TileDocument</code>&lt;<code>T</code>&gt;&gt;</p> <p>Create a new TileDocument and add it to the cache if enabled.</p>","title":"create"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#type-parameters","text":"Name Type     <code>T</code> extends <code>Record</code>&lt;<code>string</code>, <code>any</code>&gt; = <code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;","title":"Type parameters"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#parameters_2","text":"Name Type     <code>content</code> <code>T</code>   <code>metadata?</code> <code>TileMetadataArgs</code>   <code>options?</code> <code>CreateOpts</code>","title":"Parameters"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#returns_1","text":"<p><code>Promise</code>&lt;<code>TileDocument</code>&lt;<code>T</code>&gt;&gt;</p>","title":"Returns"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#deterministic","text":"<p>\u25b8 deterministic&lt;<code>T</code>&gt;(<code>metadata</code>, <code>options?</code>): <code>Promise</code>&lt;<code>TileDocument</code>&lt;<code>undefined</code> | <code>null</code> | <code>T</code>&gt;&gt;</p> <p>Create or load a deterministic TileDocument based on its metadata.</p>","title":"deterministic"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#type-parameters_1","text":"Name Type     <code>T</code> extends <code>Record</code>&lt;<code>string</code>, <code>any</code>&gt; = <code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;","title":"Type parameters"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#parameters_3","text":"Name Type     <code>metadata</code> <code>TileMetadataArgs</code>   <code>options?</code> <code>CreateOpts</code>","title":"Parameters"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#returns_2","text":"<p><code>Promise</code>&lt;<code>TileDocument</code>&lt;<code>undefined</code> | <code>null</code> | <code>T</code>&gt;&gt;</p>","title":"Returns"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#load","text":"<p>\u25b8 load&lt;<code>T</code>&gt;(<code>key</code>): <code>Promise</code>&lt;<code>TileDocument</code>&lt;<code>T</code>&gt;&gt;</p> <p>Load a TileDocument from the cache (if enabled) or remotely.</p>","title":"load"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#type-parameters_2","text":"Name Type     <code>T</code> extends <code>Record</code>&lt;<code>string</code>, <code>any</code>&gt; = <code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;","title":"Type parameters"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#parameters_4","text":"Name Type     <code>key</code> <code>TileKey</code>","title":"Parameters"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#returns_3","text":"<p><code>Promise</code>&lt;<code>TileDocument</code>&lt;<code>T</code>&gt;&gt;</p>","title":"Returns"},{"location":"reference/glaze/classes/tile_loader.TileLoader/#overrides_1","text":"<p>DataLoader.load</p>","title":"Overrides"},{"location":"reference/glaze/modules/datamodel/","text":"<p>Aliases for Ceramic stream references.</p>","title":"Module: datamodel"},{"location":"reference/glaze/modules/datamodel/#purpose","text":"<p>The <code>datamodel</code> module exports a <code>DataModel</code> class for runtime interactions with a published data model, using aliases for Ceramic stream IDs.</p>","title":"Purpose"},{"location":"reference/glaze/modules/datamodel/#installation","text":"<pre><code>npm install @glazed/datamodel\n</code></pre>","title":"Installation"},{"location":"reference/glaze/modules/datamodel/#common-use-cases","text":"","title":"Common use-cases"},{"location":"reference/glaze/modules/datamodel/#get-the-id-of-a-known-alias","text":"<pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { DataModel } from '@glazed/datamodel'\n\nconst ceramic = new CeramicClient()\nconst publishedModel = {\n schemas: {\n    MySchema: 'ceramic://k2...ab',\n  },\n  definitions: {\n    myDefinition: 'k2...ef',\n  },\n  tiles: {},\n}\nconst model = new DataModel({ ceramic, model: publishedModel })\n\nfunction getMySchemaURL() {\n  return model.getSchemaURL('MySchema') // 'ceramic://k2...ab'\n}\n\nfunction getMyDefinitionID() {\n  return model.getDefinitionID('myDefinition') // 'k2...ef'\n}\n</code></pre>","title":"Get the ID of a known alias"},{"location":"reference/glaze/modules/datamodel/#load-a-tile-by-alias","text":"<pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { DataModel } from '@glazed/datamodel'\n\nconst ceramic = new CeramicClient()\nconst publishedModel = {\n schemas: {\n    MySchema: 'ceramic://k2...ab',\n  },\n  definitions: {},\n  tiles: {\n    myTile: 'k2...cd',\n  },\n}\nconst model = new DataModel({ ceramic, model: publishedModel })\n\nasync function loadMyTile() {\n  return await model.loadTile('myTile')\n}\n</code></pre>","title":"Load a tile by alias"},{"location":"reference/glaze/modules/datamodel/#create-a-tile-with-a-schema-alias","text":"<pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { DataModel } from '@glazed/datamodel'\n\nconst ceramic = new CeramicClient()\nconst publishedModel = {\n schemas: {\n    MySchema: 'ceramic://k2...ab',\n  },\n  definitions: {},\n  tiles: {},\n}\nconst model = new DataModel({ ceramic, model: publishedModel })\n\nasync function createTileWithMySchema(content) {\n  return await model.createTile('MySchema', content)\n}\n</code></pre>","title":"Create a tile with a schema alias"},{"location":"reference/glaze/modules/datamodel/#classes","text":"<ul> <li>DataModel</li> </ul>","title":"Classes"},{"location":"reference/glaze/modules/datamodel/#type-aliases","text":"","title":"Type aliases"},{"location":"reference/glaze/modules/datamodel/#createoptions","text":"<p>\u01ac CreateOptions: <code>Object</code></p>","title":"CreateOptions"},{"location":"reference/glaze/modules/datamodel/#type-declaration","text":"Name Type Description     <code>pin?</code> <code>boolean</code> Pin the created stream (default)","title":"Type declaration"},{"location":"reference/glaze/modules/datamodel/#datamodelparams","text":"<p>\u01ac DataModelParams&lt;<code>Model</code>&gt;: <code>Object</code></p>","title":"DataModelParams"},{"location":"reference/glaze/modules/datamodel/#type-parameters","text":"Name     <code>Model</code>","title":"Type parameters"},{"location":"reference/glaze/modules/datamodel/#type-declaration_1","text":"Name Type Description     <code>autopin?</code> <code>boolean</code> Pin all created streams (default)   <code>cache?</code> <code>TileCache</code> | <code>boolean</code> <code>TileLoader</code> cache parameter, only used if <code>loader</code> is not provided   <code>ceramic?</code> <code>CeramicApi</code> A Ceramic client instance, only used if <code>loader</code> is not provided   <code>loader?</code> <code>TileLoader</code> A <code>TileLoader</code> instance to use, must be provided if <code>ceramic</code> is not provided   <code>model</code> <code>Model</code> The runtime model aliases to use","title":"Type declaration"},{"location":"reference/glaze/modules/devtools/","text":"<p>Development tools library.</p>","title":"Module: devtools"},{"location":"reference/glaze/modules/devtools/#purpose","text":"<p>The <code>devtools</code> library provides APIs to help support common use-cases when building applications on top of Ceramic, notably as a complement to the runtime Glaze libraries. It is meant to be used by developers in scripts or other tools such as the CLI, not as a runtime library.</p> <p>The <code>ModelManager</code> class notably allows developers to create, update and publish data models to be used with the <code>DataModel</code> runtime.</p>","title":"Purpose"},{"location":"reference/glaze/modules/devtools/#installation","text":"<pre><code>npm install --dev @glazed/devtools\n</code></pre>","title":"Installation"},{"location":"reference/glaze/modules/devtools/#common-use-cases","text":"","title":"Common use-cases"},{"location":"reference/glaze/modules/devtools/#add-an-existing-schema-to-a-model","text":"<p>An existing schema can be added using the <code>usePublishedSchema</code> method, as shown below.</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { ModelManager } from '@glazed/devtools'\n\nconst ceramic = new CeramicClient()\nconst manager = new ModelManager(ceramic)\n\n// Set the alias (human-readable name) and stream reference (stream or commit ID or URL) of the\n// schema to add to the model. The schema must be already present on the Ceramic node.\nawait manager.usePublishedSchema('MySchema', 'ceramic://k2...ab')\n</code></pre> <p>The <code>usePublishedDefinition</code> and <code>usePublishedTile</code> methods can be used similarly to add definitions and tiles to the model.</p>","title":"Add an existing schema to a model"},{"location":"reference/glaze/modules/devtools/#create-and-add-a-schema-to-a-model","text":"<p>Using the <code>createSchema</code> method allows to create the schema on the Ceramic node and add it to the model. Note that using this method creates a new schema every time it is called, therefore generating different stream IDs.</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { ModelManager } from '@glazed/devtools'\n\nconst ceramic = new CeramicClient()\nconst manager = new ModelManager(ceramic)\n\n// Set the alias (human-readable name) and JSON schema contents\nawait manager.createSchema('MySchema', {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  title: 'MySchema',\n  type: 'object',\n  properties: {\n    ...\n  },\n})\n</code></pre> <p>The <code>createDefinition</code> and <code>createTile</code> methods can be used similarly to add definitions and tiles to the model.</p>","title":"Create and add a schema to a model"},{"location":"reference/glaze/modules/devtools/#export-a-model-to-json","text":"<p>A managed model can be serialized to JSON, making it portable and reusable, with the <code>toJSON</code> method.</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { ModelManager } from '@glazed/devtools'\n\nconst ceramic = new CeramicClient()\nconst manager = new ModelManager(ceramic)\n\nawait manager.usePublishedSchema('MySchema', 'ceramic://k2...ab')\nconst encodedModel = await manager.toJSON()\n</code></pre>","title":"Export a model to JSON"},{"location":"reference/glaze/modules/devtools/#import-a-model-from-json","text":"<p>A managed model serialized using the <code>toJSON</code> method can be deserialized with the <code>fromJSON</code> static method.</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { ModelManager } from '@glazed/devtools'\n\nconst ceramic = new CeramicClient()\nconst manager = new ModelManager(ceramic)\n\nawait manager.usePublishedSchema('MySchema', 'ceramic://k2...ab')\nconst encodedModel = await manager.toJSON()\n\n// The `clonedManager` instance will contain the same model as the `manager` instance\nconst clonedManager = ModelManager.fromJSON(ceramic, encodedModel)\n</code></pre>","title":"Import a model from JSON"},{"location":"reference/glaze/modules/devtools/#publish-a-model-to-ceramic","text":"<p>In order to use a model at runtime in an application, it is important to ensure all the streams used by the model are present in the Ceramic network. This can be achieved by calling the <code>toPublished</code> method, which returns a published model object that can be used at runtime by a <code>DataModel</code> instance.</p> <pre><code>import { readFile, writeFile } from 'node:fs/promises'\nimport { CeramicClient } from '@ceramicnetwork/http-client'\nimport { ModelManager } from '@glazed/devtools'\n\n// The encoded model could be imported from the file system for example\nconst bytes = await readFile(new URL('encoded-model.json', import.meta.url))\nconst encodedModel = JSON.parse(bytes.toString())\n\nconst ceramic = new CeramicClient()\nconst manager = ModelManager.fromJSON(ceramic, encodedModel)\n\n// The published model could then itself be exported to be used at runtime\nconst publishedModel = await manager.toPublished()\nawait writeFile(new URL('published-model.json', import.meta.url), JSON.stringify(publishedModel))\n</code></pre>","title":"Publish a model to Ceramic"},{"location":"reference/glaze/modules/devtools/#use-existing-models","text":"<p>A model can be created by combining other models. For example, using the models for the CIP-19 \"Basic Profile\", CIP-21 \"Crypto Accounts\" and CIP-23 \"Also Known As\" specifications provided by the following packages:</p> <pre><code>npm install --dev @datamodels/identity-profile-basic @datamodels/identity-accounts-crypto @datamodels/identity-accounts-web\n</code></pre> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { ModelManager } from '@glazed/devtools'\nimport { model as basicProfileModel } from '@datamodels/identity-profile-basic'\nimport { model as cryptoAccountsModel } from '@datamodels/identity-accounts-crypto'\nimport { model as webAccountsModel } from '@datamodels/identity-accounts-web'\n\nconst ceramic = new CeramicClient()\nconst manager = new ModelManager(ceramic)\n\n// Add the imported models to the manager\nmanager.addJSONModel(basicProfileModel)\nmanager.addJSONModel(cryptoAccountsModel)\nmanager.addJSONModel(webAccountsModel)\n\n// Once published, the streams are available on the Ceramic node\nawait manager.toPublished()\n</code></pre>","title":"Use existing models"},{"location":"reference/glaze/modules/devtools/#classes","text":"<ul> <li>ModelManager</li> </ul>","title":"Classes"},{"location":"reference/glaze/modules/devtools/#type-aliases","text":"","title":"Type aliases"},{"location":"reference/glaze/modules/devtools/#addmodelschemaoptions","text":"<p>\u01ac AddModelSchemaOptions: <code>Object</code></p>","title":"AddModelSchemaOptions"},{"location":"reference/glaze/modules/devtools/#type-declaration","text":"Name Type     <code>name?</code> <code>string</code>   <code>owner?</code> <code>string</code>   <code>parent?</code> <code>string</code>","title":"Type declaration"},{"location":"reference/glaze/modules/devtools/#functions","text":"","title":"Functions"},{"location":"reference/glaze/modules/devtools/#issecureschema","text":"<p>\u25b8 isSecureSchema&lt;<code>T</code>&gt;(<code>schema</code>): <code>boolean</code></p>","title":"isSecureSchema"},{"location":"reference/glaze/modules/devtools/#type-parameters","text":"Name Type     <code>T</code> <code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;","title":"Type parameters"},{"location":"reference/glaze/modules/devtools/#parameters","text":"Name Type     <code>schema</code> <code>UncheckedJSONSchemaType</code>&lt;<code>T</code>, <code>false</code>&gt;","title":"Parameters"},{"location":"reference/glaze/modules/devtools/#returns","text":"<p><code>boolean</code></p>","title":"Returns"},{"location":"reference/glaze/modules/devtools/#publishencodedmodel","text":"<p>\u25b8 publishEncodedModel(<code>ceramic</code>, <code>model</code>): <code>Promise</code>&lt;<code>PublishedModel</code>&gt;</p>","title":"publishEncodedModel"},{"location":"reference/glaze/modules/devtools/#parameters_1","text":"Name Type     <code>ceramic</code> <code>CeramicApi</code>   <code>model</code> <code>EncodedManagedModel</code>","title":"Parameters"},{"location":"reference/glaze/modules/devtools/#returns_1","text":"<p><code>Promise</code>&lt;<code>PublishedModel</code>&gt;</p>","title":"Returns"},{"location":"reference/glaze/modules/devtools/#publishmodel","text":"<p>\u25b8 publishModel(<code>ceramic</code>, <code>model</code>): <code>Promise</code>&lt;<code>PublishedModel</code>&gt;</p>","title":"publishModel"},{"location":"reference/glaze/modules/devtools/#parameters_2","text":"Name Type     <code>ceramic</code> <code>CeramicApi</code>   <code>model</code> <code>ManagedModel</code>&lt;<code>DagJWSResult</code>&gt;","title":"Parameters"},{"location":"reference/glaze/modules/devtools/#returns_2","text":"<p><code>Promise</code>&lt;<code>PublishedModel</code>&gt;</p>","title":"Returns"},{"location":"reference/glaze/modules/did_datastore/","text":"<p>Associate data records to a DID.</p>","title":"Module: did-datastore"},{"location":"reference/glaze/modules/did_datastore/#purpose","text":"<p>The <code>did-datastore</code> module exports a <code>DIDDataStore</code> class allowing to associate Ceramic tiles to a DID in a deterministic way by implementing the Identity Index (IDX) protocol described in the CIP-11 specification.</p>","title":"Purpose"},{"location":"reference/glaze/modules/did_datastore/#installation","text":"<pre><code>npm install @glazed/did-datastore\n</code></pre>","title":"Installation"},{"location":"reference/glaze/modules/did_datastore/#common-use-cases","text":"","title":"Common use-cases"},{"location":"reference/glaze/modules/did_datastore/#read-the-contents-of-a-record","text":"<p>The <code>DIDDataStore</code> instance uses a <code>DataModel</code> instance to support aliases for definitions.</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { DataModel } from '@glazed/datamodel'\nimport { DIDDataStore } from '@glazed/did-datastore'\n\nconst ceramic = new CeramicClient()\nconst publishedModel = {\n schemas: {\n    MySchema: 'ceramic://k2...ab',\n  },\n  definitions: {\n    myDefinition: 'k2...ef',\n  },\n  tiles: {},\n}\nconst model = new DataModel({ ceramic, model: publishedModel })\nconst dataStore = new DIDDataStore({ ceramic, model })\n\nasync function getMyDefinitionRecord(did) {\n  return await dataStore.get('myDefinition', did)\n}\n</code></pre>","title":"Read the contents of a record"},{"location":"reference/glaze/modules/did_datastore/#use-a-published-model-object","text":"<p>Instead of using a <code>DataModel</code> instance, it is possible to provide a published model object directly.</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { DIDDataStore } from '@glazed/did-datastore'\n\nconst ceramic = new CeramicClient()\nconst publishedModel = {\n schemas: {\n    MySchema: 'ceramic://k2...ab',\n  },\n  definitions: {\n    myDefinition: 'k2...ef',\n  },\n  tiles: {},\n}\nconst dataStore = new DIDDataStore({ ceramic, model: publishedModel })\n\nasync function getMyDefinitionRecord(did) {\n  return await dataStore.get('myDefinition', did)\n}\n</code></pre>","title":"Use a published model object"},{"location":"reference/glaze/modules/did_datastore/#use-a-tileloader-instance","text":"<p>The <code>DIDDataStore</code> instance uses a <code>TileLoader</code> instance internally to batch queries. It is possible to provide an instance to use instead, for example to share it with other functions.</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { DIDDataStore } from '@glazed/did-datastore'\nimport { TileLoader } from '@glazed/tile-loader'\n\nconst ceramic = new CeramicClient()\nconst loader = new TileLoader({ ceramic })\nconst publishedModel = {\n schemas: {\n    MySchema: 'ceramic://k2...ab',\n  },\n  definitions: {\n    myDefinition: 'k2...ef',\n  },\n  tiles: {},\n}\nconst dataStore = new DIDDataStore({ ceramic, loader, model: publishedModel })\n\nasync function getMyDefinitionRecord(did) {\n  return await dataStore.get('myDefinition', did)\n}\n</code></pre>","title":"Use a TileLoader instance"},{"location":"reference/glaze/modules/did_datastore/#set-the-contents-of-a-record","text":"<p>It is possible to set the contents of a record when the Ceramic instance is authenticated using the <code>set</code> method.</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { DIDDataStore } from '@glazed/did-datastore'\n\nconst ceramic = new CeramicClient()\nconst publishedModel = {\n schemas: {\n    MySchema: 'ceramic://k2...ab',\n  },\n  definitions: {\n    myDefinition: 'k2...ef',\n  },\n  tiles: {},\n}\nconst dataStore = new DIDDataStore({ ceramic, model: publishedModel })\n\nasync function setMyDefinitionRecord(content) {\n  // This will throw an error if the Ceramic instance is not authenticated\n  return await dataStore.set('myDefinition', content)\n}\n</code></pre>","title":"Set the contents of a record"},{"location":"reference/glaze/modules/did_datastore/#merge-the-contents-of-a-record","text":"<p>Rather than completely replacing the contents of a record using the <code>set</code> method, the <code>merge</code> method can be used to only replace the specified fields.</p> <p>The <code>merge</code> method only applies a shallow (one level) replacement, if you need a deep merge or more complex logic, you should implement it directly using the <code>get</code> and <code>set</code> methods.</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { DIDDataStore } from '@glazed/did-datastore'\n\nconst ceramic = new CeramicClient()\nconst publishedModel = {\n schemas: {\n    MySchema: 'ceramic://k2...ab',\n  },\n  definitions: {\n    myDefinition: 'k2...ef',\n  },\n  tiles: {},\n}\nconst dataStore = new DIDDataStore({ ceramic, model: publishedModel })\n\nasync function setMyDefinitionRecord(content) {\n  // This will only replace the fields present in the input `content` object, other fields\n  // already present in the record will not be affected\n  return await dataStore.merge('myDefinition', content)\n}\n</code></pre>","title":"Merge the contents of a record"},{"location":"reference/glaze/modules/did_datastore/#classes","text":"<ul> <li>DIDDataStore</li> </ul>","title":"Classes"},{"location":"reference/glaze/modules/did_datastore/#type-aliases","text":"","title":"Type aliases"},{"location":"reference/glaze/modules/did_datastore/#createoptions","text":"<p>\u01ac CreateOptions: <code>Object</code></p>","title":"CreateOptions"},{"location":"reference/glaze/modules/did_datastore/#type-declaration","text":"Name Type Description     <code>controller?</code> <code>string</code> Optional controller for the record   <code>pin?</code> <code>boolean</code> Pin the created record stream (default)","title":"Type declaration"},{"location":"reference/glaze/modules/did_datastore/#diddatastoreparams","text":"<p>\u01ac DIDDataStoreParams&lt;<code>ModelTypes</code>&gt;: <code>Object</code></p>","title":"DIDDataStoreParams"},{"location":"reference/glaze/modules/did_datastore/#type-parameters","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code> = <code>ModelTypeAliases</code>","title":"Type parameters"},{"location":"reference/glaze/modules/did_datastore/#type-declaration_1","text":"Name Type Description     <code>autopin?</code> <code>boolean</code> Pin all created records streams (default)   <code>cache?</code> <code>TileCache</code> | <code>boolean</code> <code>TileLoader</code> cache parameter, only used if <code>loader</code> is not provided   <code>ceramic</code> <code>CeramicApi</code> A Ceramic client instance   <code>id?</code> <code>string</code> Fallback DID to use when not explicitly set in method calls   <code>loader?</code> <code>TileLoader</code> An optional <code>TileLoader</code> instance to use   <code>model</code> <code>DataModel</code>&lt;<code>ModelTypes</code>&gt; | <code>ModelTypesToAliases</code>&lt;<code>ModelTypes</code>&gt; A <code>DataModel</code> instance or runtime model aliases to use","title":"Type declaration"},{"location":"reference/glaze/modules/did_datastore/#definitioncontenttype","text":"<p>\u01ac DefinitionContentType&lt;<code>ModelTypes</code>, <code>Alias</code>&gt;: <code>ModelTypes</code>[<code>\"schemas\"</code>][<code>ModelTypes</code>[<code>\"definitions\"</code>][<code>Alias</code>]]</p>","title":"DefinitionContentType"},{"location":"reference/glaze/modules/did_datastore/#type-parameters_1","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code>   <code>Alias</code> extends keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]","title":"Type parameters"},{"location":"reference/glaze/modules/did_datastore/#definitionwithid","text":"<p>\u01ac DefinitionWithID&lt;<code>Config</code>&gt;: <code>Definition</code>&lt;<code>Config</code>&gt; &amp; { <code>id</code>: <code>StreamID</code>  }</p>","title":"DefinitionWithID"},{"location":"reference/glaze/modules/did_datastore/#type-parameters_2","text":"Name Type     <code>Config</code> extends <code>Record</code>&lt;<code>string</code>, <code>unknown</code>&gt; = <code>Record</code>&lt;<code>string</code>, <code>unknown</code>&gt;","title":"Type parameters"},{"location":"reference/glaze/modules/did_datastore/#definitionscontenttypes","text":"<p>\u01ac DefinitionsContentTypes&lt;<code>ModelTypes</code>, <code>Fallback</code>&gt;: <code>Object</code></p>","title":"DefinitionsContentTypes"},{"location":"reference/glaze/modules/did_datastore/#type-parameters_3","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code>   <code>Fallback</code> <code>Record</code>&lt;<code>string</code>, <code>unknown</code>&gt;","title":"Type parameters"},{"location":"reference/glaze/modules/did_datastore/#index-signature","text":"<p>\u25aa [Key: <code>string</code>]: typeof <code>Key</code> extends keyof <code>ModelTypes</code>[<code>\"definitions\"</code>] ? <code>DefinitionContentType</code>&lt;<code>ModelTypes</code>, typeof <code>Key</code>&gt; : <code>Fallback</code></p>","title":"Index signature"},{"location":"reference/glaze/modules/did_datastore/#entry","text":"<p>\u01ac Entry: <code>Object</code></p>","title":"Entry"},{"location":"reference/glaze/modules/did_datastore/#type-declaration_2","text":"Name Type Description     <code>id</code> <code>string</code> Record ID (Ceramic StreamID)   <code>key</code> <code>string</code> Key (definition ID) identifying the record ID in the index   <code>record</code> <code>unknown</code> Record contents","title":"Type declaration"},{"location":"reference/glaze/modules/tile_loader/","text":"<p>Batching and caching for Ceramic streams.</p>","title":"Module: tile-loader"},{"location":"reference/glaze/modules/tile_loader/#purpose","text":"<p>The <code>tile-loader</code> module exports a <code>TileLoader</code> class providing batching and caching for Tile load and creation in order to improve client-side performance.</p>","title":"Purpose"},{"location":"reference/glaze/modules/tile_loader/#installation","text":"<pre><code>npm install @glazed/tile-loader\n</code></pre>","title":"Installation"},{"location":"reference/glaze/modules/tile_loader/#common-use-cases","text":"","title":"Common use-cases"},{"location":"reference/glaze/modules/tile_loader/#batch-stream-loads","text":"<p>Batching consists in the process of combining multiple concurrent queries to a Ceramic node into a single one.</p> <p>Using a loader instance in the following example, the two streams will be loaded with a single request to the Ceramic node:</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { TileLoader } from '@glazed/tile-loader'\n\nconst ceramic = new CeramicClient()\nconst loader = new TileLoader({ ceramic })\n\nasync function loadStreams() {\n  const [stream1, stream2] = await Promise.all([\n    loader.load('k2...ab'),\n    loader.load('k2...cd'),\n  ])\n}\n</code></pre>","title":"Batch stream loads"},{"location":"reference/glaze/modules/tile_loader/#cache-loaded-streams","text":"<p>Caching consists in keeping track of streams loaded from a Ceramic node.</p> <p>Caching is disabled by default and may not be suited for your use-cases, make sure you carefully consider the trade-offs before enabling it. Streams loaded from the cache may be out of date from the state on the Ceramic network, so applications should be designed accordingly.</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { TileLoader } from '@glazed/tile-loader'\n\nconst ceramic = new CeramicClient()\nconst loader = new TileLoader({ ceramic, cache: true })\n\nasync function loadStream() {\n  // Load the stream at some point in your app\n  const stream = await loader.load('k2...ab')\n}\n\nasync function alsoLoadStream() {\n  // Maybe the same stream needs to be loaded at a different time or in another part of your app\n  const streamAgain = await loader.load('k2...ab')\n}\n</code></pre>","title":"Cache loaded streams"},{"location":"reference/glaze/modules/tile_loader/#use-a-custom-cache","text":"<p>When setting the <code>cache</code> option to <code>true</code> in the loader constructor, the cache will live as long as the loader instance. This means any individual stream will only ever get loaded once, and persist in memory until the loader instance is deleted.</p> <p>It is possible to provide a custom cache implementation in the loader constructor to customize this behavior, for example in order to limit memory usage by restricting the number of streams kept in the cache, or discarding loaded streams after a given period of time.</p> <p>A custom cache must implement a subset of the <code>Map</code> interface, defined by the <code>TileCache</code> interface.</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { TileLoader } from '@glazed/tile-loader'\n\nconst ceramic = new CeramicClient()\n// The cache must implement a subset of the Map interface\nconst cache = new Map()\nconst loader = new TileLoader({ ceramic, cache })\n\nasync function load(id) {\n  // The loader will cache the request as soon as the load() method is called, so the stored\n  // value is a Promise of a TileDocument\n  return await loader.load(id)\n}\n\nfunction getFromCache(id) {\n  return cache.get(id) // Promise&lt;TileDocument&gt;\n}\n</code></pre>","title":"Use a custom cache"},{"location":"reference/glaze/modules/tile_loader/#create-and-cache-a-stream","text":"<p>The <code>create</code> method adds the created stream to the internal cache of the loader. This has no effect if the cache is disabled.</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { TileLoader } from '@glazed/tile-loader'\n\nconst ceramic = new CeramicClient()\nconst loader = new TileLoader({ ceramic, cache: true })\n\nasync function createAndLoad() {\n  const stream = await loader.create({ hello: world })\n  // The following call will returne the stream from the cache\n  await loader.load(stream.id)\n}\n</code></pre>","title":"Create and cache a stream"},{"location":"reference/glaze/modules/tile_loader/#load-a-deterministic-stream","text":"<p>Using the <code>deterministic</code> method of a loader instance allows to load such streams while benefiting from the batching and caching functionalities of the loader.</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { TileLoader } from '@glazed/tile-loader'\n\nconst ceramic = new CeramicClient()\nconst loader = new TileLoader({ ceramic, cache: true })\n\nasync function load() {\n  // The following call will load the latest version of the stream based on its metadata\n  const stream = await loader.deterministic({ controllers: ['did:key:...'], family: 'test' })\n}\n</code></pre>","title":"Load a deterministic stream"},{"location":"reference/glaze/modules/tile_loader/#classes","text":"<ul> <li>TileLoader</li> </ul>","title":"Classes"},{"location":"reference/glaze/modules/tile_loader/#type-aliases","text":"","title":"Type aliases"},{"location":"reference/glaze/modules/tile_loader/#tilecache","text":"<p>\u01ac TileCache: <code>Object</code></p>","title":"TileCache"},{"location":"reference/glaze/modules/tile_loader/#type-declaration","text":"Name Type     <code>clear</code> () =&gt; <code>any</code>   <code>delete</code> (<code>id</code>: <code>string</code>) =&gt; <code>any</code>   <code>get</code> (<code>id</code>: <code>string</code>) =&gt; <code>void</code> | <code>Promise</code>&lt;<code>TileDocument</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;&gt;&gt;   <code>set</code> (<code>id</code>: <code>string</code>, <code>value</code>: <code>Promise</code>&lt;<code>TileDocument</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;&gt;&gt;) =&gt; <code>any</code>","title":"Type declaration"},{"location":"reference/glaze/modules/tile_loader/#tilekey","text":"<p>\u01ac TileKey: <code>CommitID</code> | <code>StreamID</code> | <code>TileQuery</code> | <code>string</code></p>","title":"TileKey"},{"location":"reference/glaze/modules/tile_loader/#tileloaderparams","text":"<p>\u01ac TileLoaderParams: <code>Object</code></p>","title":"TileLoaderParams"},{"location":"reference/glaze/modules/tile_loader/#type-declaration_1","text":"Name Type Description     <code>cache?</code> <code>TileCache</code> | <code>boolean</code> A supported cache implementation, <code>true</code> to use the default implementation or <code>false</code> to disable the cache (default)   <code>ceramic</code> <code>CeramicApi</code> A Ceramic client instance   <code>multiqueryTimeout?</code> <code>number</code> MultiQuery request timeout in milliseconds","title":"Type declaration"},{"location":"reference/glaze/modules/tile_loader/#tilequery","text":"<p>\u01ac TileQuery: <code>Omit</code>&lt;<code>MultiQuery</code>, <code>\"paths\"</code> | <code>\"atTime\"</code>&gt;</p> <p>Omit <code>path</code> and <code>atTime</code> from MultiQuery as the cache needs to be deterministic based on the ID.</p>","title":"TileQuery"},{"location":"reference/glaze/modules/tile_loader/#functions","text":"","title":"Functions"},{"location":"reference/glaze/modules/tile_loader/#getdeterministicquery","text":"<p>\u25b8 getDeterministicQuery(<code>metadata</code>): <code>Promise</code>&lt;<code>TileQuery</code>&gt;</p> <p>Create a <code>TileQuery</code> for a determinitic TileDocument based on its metadata.</p>","title":"getDeterministicQuery"},{"location":"reference/glaze/modules/tile_loader/#parameters","text":"Name Type     <code>metadata</code> <code>TileMetadataArgs</code>","title":"Parameters"},{"location":"reference/glaze/modules/tile_loader/#returns","text":"<p><code>Promise</code>&lt;<code>TileQuery</code>&gt;</p>","title":"Returns"},{"location":"reference/javascript/blockchain/","text":"<p>This document contains a guide on how to add support for a new blockchain to the <code>CAIP10Link</code> StreamType, and to use it for authentication in Ceramic.</p>","title":"Add support for a new blockchain"},{"location":"reference/javascript/blockchain/#ceramic-and-blockchain-accounts","text":"<p>Ceramic interacts with blockchain accounts in two ways: authentication and linking.</p>","title":"Ceramic and blockchain accounts"},{"location":"reference/javascript/blockchain/#authentication","text":"<p>3ID Connect (using <code>3id-did-provider</code>) creates <code>3id</code> (Ceramic flavour of DID) private keys based on an externally-provided entropy. It could be provided by a blockchain account by merely signing a well-known message. From a user's standpoint, it is authentication into Ceramic through her blockchain account, be it on Ethereum, Filecoin, EOS, Cosmos or something else. Same signature (=same entropy) generates same Ceramic DID.</p>","title":"Authentication"},{"location":"reference/javascript/blockchain/#linking","text":"<p>In addition to generating a DID a user could also link additional blockchain accounts to a Ceramic DID. It establishes a relation <code>blockchain account \u2192 DID</code> that allows one to discover a DID (and associated data like a social profile and data) based on just a blockchain account. Additionally, a link serves as a proof-of-ownership by DID over the blockchain account. This is useful for dApp personalization and UX: one sees familiar names instead of <code>0xgibberish</code>.</p> <p>Below one additional process is mentioned: validation. It checks if proof-of-ownership in the link is formally correct, i.e., a well-known payload is really signed by the account that is declared in the link.</p>","title":"Linking"},{"location":"reference/javascript/blockchain/#adding-a-new-blockchain","text":"<p>To add a new blockchain to Ceramic one has to implement both linking and validation. We use CAIP-10 to represent accounts in a blockchain agnostic way. If the blockchain you want to add isn't already part of the CAIP standards you should make sure to add it there.</p>","title":"Adding a new blockchain"},{"location":"reference/javascript/blockchain/#linking_1","text":"<p>To add a new blockchain, one has to implement a new class implementing AuthProvider, put it into the <code>@ceramicnetwork/blockchain-utils-linking</code> package and export it. The auth provider sits between 3id-connect (or 3ID DID Provider) and your blockchain account provider. In case of Ethereum, it might be MetaMask. It is responsible mainly for:</p> <ul> <li>authentication (<code>#authenticate</code>): provide deterministic entropy</li> <li>creating link (<code>#createLink</code>): create a LinkProof object which associates the specified AccountID with a DID</li> </ul> <p>The auth provider is expected to know which blockchain account it currently serves. It reports it via <code>#accountId</code>. To reuse the same internal settings, e.g. a connection to a blockchain provider, but with a different account, the auth provider should have a <code>#withAddress</code> method.</p> <p>Let's look at each method required to be implemented by the AuthProvider interface:</p>","title":"Linking"},{"location":"reference/javascript/blockchain/#authenticate","text":"<p>The <code>authenticate</code> function allows a blockchain account to be added as an authentication method (authMethod) to a 3ID. This means using your blockchain account you will always be able to access that 3ID and derive its 3ID Keychain for use, for example in 3ID Connect.</p>","title":"<code>authenticate()</code>"},{"location":"reference/javascript/blockchain/#parameters","text":"<ul> <li><code>message</code>: string, can be any string</li> <li><code>AccountID</code>: an instance of a CAIP-10 AccountID</li> <li><code>provider</code>: specific to your blockchain. This is any standard signer or provider defined for your blockchain. Ideally your ecosystem has a widely-accepted standard interface so that this module can support signing by most accounts.</li> </ul>","title":"Parameters"},{"location":"reference/javascript/blockchain/#returns","text":"<ul> <li><code>entropy</code>: a hex string representing 32 bytes of entropy, prefixed by <code>0x</code></li> </ul> <p>The entropy returned by a given AccountID must always be the same.</p>","title":"Returns"},{"location":"reference/javascript/blockchain/#createlink","text":"<p>The <code>createLink</code> function allows a blockchain account to create a verifiable link proof that publicly binds the blockchain account to a given DID. In Ceramic, these these link proofs can be used to create <code>CAIP10Link</code> streams which allow anyone to look up the DID linked to your blockchain account, and then resolve any other public info linked to your DID. The StreamIDs of your CAIP10Links can be stored in the IDX Crypto Accounts records for simple lookup.</p> <p>This function consumes similar arguments as described above. It also consumes the DID string that is being linked. This function is implemented such that when the given AccountID signs a message including the given DID with the given provider, a <code>LinkProof</code> is returned.</p>","title":"<code>createLink()</code>"},{"location":"reference/javascript/blockchain/#accountid","text":"<p>The <code>accountId</code> method should return currently used account in the CAIP-10 format.</p>","title":"<code>accountId()</code>"},{"location":"reference/javascript/blockchain/#withaccount","text":"<p>The <code>withAccount</code> method should return a new instance of the auth provider that serves a new account.</p>","title":"<code>withAccount()</code>"},{"location":"reference/javascript/blockchain/#validation","text":"<p>Validation is the counterpart of linking that checks if the signature contained in a <code>LinkProof</code> corresponds to the declared account.</p> <p>To add support for a new blockchain:</p> <ul> <li>add a new file named after your blockchain to <code>@ceramicnetwork/blockchain-utils-validation</code> package</li> <li>this file should expose an implementation of the <code>BlockchainHandler</code> interface, having:</li> <li>CAIP-2 <code>namespace</code> for your blockchain</li> <li>a <code>validateLink</code> function that checks if the linking signature was created by the account declared in the <code>LinkProof</code> argument</li> <li>add the newly created <code>BlockchainHandler</code> to the <code>handlers</code> list in index.ts</li> </ul>","title":"Validation"},{"location":"reference/javascript/blockchain/#validatelink","text":"<p>The <code>validateLink</code> function validates a given LinkProof. This allows anyone to easily verify LinkProofs and for Ceramic to validate CAIP10Links. The function consumes a LinkProof and returns the LinkProof if valid, otherwise it returns null. Valid typically means that the given signature in the LinkProof is valid over the given message and is created by the given account.</p> <p>Make sure that <code>validateLink</code> can validate links created by <code>AuthProvider#createLink</code>.</p>","title":"<code>validateLink()</code>"},{"location":"reference/javascript/blockchain/#currently-supported-blockchains","text":"<p>Below you can see a table which lists supported blockchains and their provider objects. If you add support for a new chain, please make a PR here.</p>    Blockchain CAIP-2 namespace Supported providers Notes     Cosmos cosmos @tendermint/sig The Cosmos wallet provider interface is still being standardized and is subject to change.   Ethereum eip155 MetaMask-like Ethereum provider    Filecoin fil Filecoin Wallet Provider    EOS eosio @smontero/eosio-local-provider    Polkadot polkadot @polkadot{.js} extention api Doesn't support the <code>authenticate</code> method yet.   Tezos tezos @taquito/taquito    Near near @near/near-api-js CAIP in draft form.","title":"Currently supported blockchains"},{"location":"reference/javascript/packages/","text":"<p>This page contains a list of all packages and modules included in the Ceramic TypeScript implementation. Click into individual packages for detailed documentation on its APIs and types.</p>","title":"JavaScript API References"},{"location":"reference/javascript/packages/#node","text":"","title":"Node"},{"location":"reference/javascript/packages/#core","text":"<p><code>@ceramicnetwork/core</code>: Implementation of the Ceramic protocol, exposed using a simple JS API.</p>","title":"Core"},{"location":"reference/javascript/packages/#common","text":"<p><code>@ceramicnetwork/common</code>: Common Ceramic types and utilities.</p>","title":"Common"},{"location":"reference/javascript/packages/#streamid","text":"<p><code>@ceramicnetwork/streamid</code>: Utility for encoding and decoding StreamIDs and CommitIDs.</p>","title":"StreamID"},{"location":"reference/javascript/packages/#streamtype-tile-handler","text":"<p><code>@ceramicnetwork/stream-tile-handler</code>: Handler implementation for the TileDocument StreamType.</p>","title":"StreamType: Tile Handler"},{"location":"reference/javascript/packages/#streamtype-caip10link-handler","text":"<p><code>@ceramicnetwork/stream-caip10-link-handler</code>: Handler implementation for the Caip10Link StreamType.</p>","title":"StreamType: Caip10Link Handler"},{"location":"reference/javascript/packages/#ipfs-daemon","text":"<p><code>@ceramicnetwork/ipfs-daemon</code>: JS-IPFS instance with DagJOSE codec.</p>","title":"IPFS Daemon"},{"location":"reference/javascript/packages/#ipfs-topology","text":"<p><code>@ceramicnetwork/ipfs-topology</code>: Bootstrap IPFS topology for Ceramic.</p>","title":"IPFS Topology"},{"location":"reference/javascript/packages/#pinning","text":"<p><code>@ceramicnetwork/pinning-aggregation</code>: Aggregation of backends for pinning stream content and state.</p>","title":"Pinning"},{"location":"reference/javascript/packages/#pinning-ipfs-backend","text":"<p><code>@ceramicnetwork/pinning-ipfs-backend</code>: Backend for pinning IPFS records on IPFS.</p>","title":"Pinning: IPFS Backend"},{"location":"reference/javascript/packages/#pinning-powergate-backend","text":"<p><code>@ceramicnetwork/pinning-powergate-backend</code>: Backend for pinning IPFS records on Filecoin via a Powergate service.</p>","title":"Pinning: Powergate Backend"},{"location":"reference/javascript/packages/#logger","text":"<p><code>@ceramicnetwork/logger</code>: Utilities for logging.</p>","title":"Logger"},{"location":"reference/javascript/packages/#clients","text":"","title":"Clients"},{"location":"reference/javascript/packages/#http-client","text":"<p><code>@ceramicnetwork/http-client</code>: HTTP client for Ceramic.</p>","title":"HTTP Client"},{"location":"reference/javascript/packages/#cli","text":"<p><code>@ceramicnetwork/cli</code>: Command line interface for Ceramic.</p>","title":"CLI"},{"location":"reference/javascript/packages/#streamtype-tile","text":"<p><code>@ceramicnetwork/stream-tile</code>: Implementation of the TileDocument StreamType.</p>","title":"StreamType: Tile"},{"location":"reference/javascript/packages/#streamtype-caip10link","text":"<p><code>@ceramicnetwork/stream-caip10-link</code>: Implementation of the Caip10Link StreamType.</p>","title":"StreamType: Caip10Link"},{"location":"reference/javascript/packages/#dids","text":"","title":"DIDs"},{"location":"reference/javascript/packages/#js-did","text":"<p><code>js-did</code>: Interface for interacting with DIDs.</p>","title":"JS DID"},{"location":"reference/javascript/packages/#3id-did-resolver","text":"<p><code>@ceramicnetwork/3id-did-resolver</code>: Resolver for the 3ID DID method.</p>","title":"3ID DID Resolver"},{"location":"reference/javascript/packages/#key-did-resolver","text":"<p><code>key-did-resolver</code>: Resolver for the Key DID method.</p>","title":"Key DID Resolver"},{"location":"reference/javascript/packages/#blockchain-utils-linking","text":"<p><code>@ceramicnetwork/blockchain-utils-linking</code>: Utility functions for linking blockchain accounts to DIDs.</p>","title":"Blockchain Utils: Linking"},{"location":"reference/javascript/packages/#blockchain-utils-validation","text":"<p><code>@ceramicnetwork/blockchain-utils-validation</code>: Utility functions to validate links of blockchain accounts linked a DID</p>","title":"Blockchain Utils: Validation"},{"location":"reference/self-id/","text":"<p>Self.ID is a framework that makes it easy to build Web3 applications with Ethereum-based authentication and composable, user-centric data storage and retrieval.</p>","title":"Self.ID SDK"},{"location":"reference/self-id/#why-selfid","text":"<p>\u2705 One library, easy setup</p> <p>Self.ID is a single library with minimal configuration that provides access to the full Ceramic stack with support for popular environments such as <code>React</code> and <code>web</code>. The Self.ID SDK uses Glaze suite middleware, 3ID DID accounts, 3ID Connect authentication, and Ceramic HTTP client and DID JSON-RPC client.</p> <p>\u2705 Login with Web3</p> <p>Self.ID is compatible with Ethereum accounts and EVM-based wallet authentication, so users don't have to install new wallets or create new accounts in order to use Ceramic. Users can even connect multiple wallet accounts to their Ceramic account, if they like.</p> <p>\u2705 Composable, user-centric data management</p> <p>The SDK includes some of the most popular Ceramic data models out-of-the-box, such as user profiles, linked crypto accounts, and linked Web2 accounts, giving your application automatic storage and retrieval composability with a rich set of existing users and data to bootstrap your application.</p> <p>\u2705 Extensible data models</p> <p>You're not limited to just the data models provided by Self.ID! You can create new data models or import ones from the Data Models Registry to add additional data features to your application.</p>","title":"Why Self.ID?"},{"location":"reference/self-id/#sdk-overview","text":"<p>The Self.ID SDK contains modules organized in the following manner:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  framework                  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502    react    \u2502 \u2502  multiauth  \u2502 \u2502 image-utils \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     web     \u2502 \u2502     ui      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502    core     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>","title":"SDK overview"},{"location":"reference/self-id/#building-with-react","text":"","title":"Building with React"},{"location":"reference/self-id/#using-the-framework","text":"<p>The Framework is the highest-level abstraction provided by the Self.ID SDK, designed specifically to power React applications. It leverages most other packages of the Self.ID SDK, and in most cases is the module you should use if you're building with React.</p>","title":"Using the Framework \u2192"},{"location":"reference/self-id/#building-with-javascript","text":"","title":"Building with JavaScript"},{"location":"reference/self-id/#using-the-web-module","text":"<p>The Web module provides user authentication, data storage, and retrieval for browser-based web applications.</p>","title":"Using the Web module \u2192"},{"location":"reference/self-id/#using-the-core-module","text":"<p>The Core module only provides data retrieval for Node and browser-based applications.</p>","title":"Using the Core module \u2192"},{"location":"reference/self-id/classes/core.Core/","text":"<p>core.Core</p> <pre><code>import { Core } from '@self.id/core'\n</code></pre>","title":"Class: Core&lt;ModelTypes, Alias&gt;"},{"location":"reference/self-id/classes/core.Core/#type-parameters","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code> = <code>CoreModelTypes</code>   <code>Alias</code> extends keyof <code>ModelTypes</code>[<code>\"definitions\"</code>] = keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]","title":"Type parameters"},{"location":"reference/self-id/classes/core.Core/#constructors","text":"","title":"Constructors"},{"location":"reference/self-id/classes/core.Core/#constructor","text":"<p>\u2022 new Core&lt;<code>ModelTypes</code>, <code>Alias</code>&gt;(<code>params</code>)</p>","title":"constructor"},{"location":"reference/self-id/classes/core.Core/#type-parameters_1","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt; = <code>CoreModelTypes</code>   <code>Alias</code> extends <code>string</code> | <code>number</code> | <code>symbol</code> = keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]","title":"Type parameters"},{"location":"reference/self-id/classes/core.Core/#parameters","text":"Name Type     <code>params</code> <code>CoreParams</code>&lt;<code>ModelTypes</code>&gt;","title":"Parameters"},{"location":"reference/self-id/classes/core.Core/#accessors","text":"","title":"Accessors"},{"location":"reference/self-id/classes/core.Core/#ceramic","text":"<p>\u2022 <code>get</code> ceramic(): <code>CeramicClient</code></p>","title":"ceramic"},{"location":"reference/self-id/classes/core.Core/#returns","text":"<p><code>CeramicClient</code></p>","title":"Returns"},{"location":"reference/self-id/classes/core.Core/#datamodel","text":"<p>\u2022 <code>get</code> dataModel(): <code>DataModel</code>&lt;<code>ModelTypes</code>, <code>ModelTypesToAliases</code>&lt;<code>ModelTypes</code>&gt;&gt;</p>","title":"dataModel"},{"location":"reference/self-id/classes/core.Core/#returns_1","text":"<p><code>DataModel</code>&lt;<code>ModelTypes</code>, <code>ModelTypesToAliases</code>&lt;<code>ModelTypes</code>&gt;&gt;</p>","title":"Returns"},{"location":"reference/self-id/classes/core.Core/#datastore","text":"<p>\u2022 <code>get</code> dataStore(): <code>DIDDataStore</code>&lt;<code>ModelTypes</code>, keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]&gt;</p>","title":"dataStore"},{"location":"reference/self-id/classes/core.Core/#returns_2","text":"<p><code>DIDDataStore</code>&lt;<code>ModelTypes</code>, keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]&gt;</p>","title":"Returns"},{"location":"reference/self-id/classes/core.Core/#resolver","text":"<p>\u2022 <code>get</code> resolver(): <code>Resolver</code></p>","title":"resolver"},{"location":"reference/self-id/classes/core.Core/#returns_3","text":"<p><code>Resolver</code></p>","title":"Returns"},{"location":"reference/self-id/classes/core.Core/#tileloader","text":"<p>\u2022 <code>get</code> tileLoader(): <code>TileLoader</code></p>","title":"tileLoader"},{"location":"reference/self-id/classes/core.Core/#returns_4","text":"<p><code>TileLoader</code></p>","title":"Returns"},{"location":"reference/self-id/classes/core.Core/#methods","text":"","title":"Methods"},{"location":"reference/self-id/classes/core.Core/#get","text":"<p>\u25b8 get&lt;<code>Key</code>, <code>ContentType</code>&gt;(<code>key</code>, <code>id</code>): <code>Promise</code>&lt;<code>null</code> | <code>ContentType</code>&gt;</p>","title":"get"},{"location":"reference/self-id/classes/core.Core/#type-parameters_2","text":"Name Type     <code>Key</code> extends <code>string</code> | <code>number</code> | <code>symbol</code>   <code>ContentType</code> <code>DefinitionContentType</code>&lt;<code>ModelTypes</code>, <code>Key</code>&gt;","title":"Type parameters"},{"location":"reference/self-id/classes/core.Core/#parameters_1","text":"Name Type     <code>key</code> <code>Key</code>   <code>id</code> <code>string</code>","title":"Parameters"},{"location":"reference/self-id/classes/core.Core/#returns_5","text":"<p><code>Promise</code>&lt;<code>null</code> | <code>ContentType</code>&gt;</p>","title":"Returns"},{"location":"reference/self-id/classes/core.Core/#getaccountdid","text":"<p>\u25b8 getAccountDID(<code>account</code>): <code>Promise</code>&lt;<code>string</code>&gt;</p>","title":"getAccountDID"},{"location":"reference/self-id/classes/core.Core/#parameters_2","text":"Name Type     <code>account</code> <code>string</code>","title":"Parameters"},{"location":"reference/self-id/classes/core.Core/#returns_6","text":"<p><code>Promise</code>&lt;<code>string</code>&gt;</p>","title":"Returns"},{"location":"reference/self-id/classes/core.Core/#todid","text":"<p>\u25b8 toDID(<code>accountOrDID</code>): <code>Promise</code>&lt;<code>string</code>&gt;</p>","title":"toDID"},{"location":"reference/self-id/classes/core.Core/#parameters_3","text":"Name Type     <code>accountOrDID</code> <code>string</code>","title":"Parameters"},{"location":"reference/self-id/classes/core.Core/#returns_7","text":"<p><code>Promise</code>&lt;<code>string</code>&gt;</p>","title":"Returns"},{"location":"reference/self-id/classes/core.PublicID/","text":"<p>core.PublicID</p> <pre><code>import { PublicID } from '@self.id/core'\n</code></pre>","title":"Class: PublicID&lt;ModelTypes, Alias&gt;"},{"location":"reference/self-id/classes/core.PublicID/#type-parameters","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code> = <code>CoreModelTypes</code>   <code>Alias</code> extends keyof <code>ModelTypes</code>[<code>\"definitions\"</code>] = keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]","title":"Type parameters"},{"location":"reference/self-id/classes/core.PublicID/#constructors","text":"","title":"Constructors"},{"location":"reference/self-id/classes/core.PublicID/#constructor","text":"<p>\u2022 new PublicID&lt;<code>ModelTypes</code>, <code>Alias</code>&gt;(<code>params</code>)</p>","title":"constructor"},{"location":"reference/self-id/classes/core.PublicID/#type-parameters_1","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt; = <code>CoreModelTypes</code>   <code>Alias</code> extends <code>string</code> | <code>number</code> | <code>symbol</code> = keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]","title":"Type parameters"},{"location":"reference/self-id/classes/core.PublicID/#parameters","text":"Name Type     <code>params</code> <code>PublicIDParams</code>&lt;<code>ModelTypes</code>&gt;","title":"Parameters"},{"location":"reference/self-id/classes/core.PublicID/#accessors","text":"","title":"Accessors"},{"location":"reference/self-id/classes/core.PublicID/#id","text":"<p>\u2022 <code>get</code> id(): <code>string</code></p>","title":"id"},{"location":"reference/self-id/classes/core.PublicID/#returns","text":"<p><code>string</code></p>","title":"Returns"},{"location":"reference/self-id/classes/core.PublicID/#methods","text":"","title":"Methods"},{"location":"reference/self-id/classes/core.PublicID/#get","text":"<p>\u25b8 get&lt;<code>Key</code>, <code>ContentType</code>&gt;(<code>key</code>): <code>Promise</code>&lt;<code>null</code> | <code>ContentType</code>&gt;</p>","title":"get"},{"location":"reference/self-id/classes/core.PublicID/#type-parameters_2","text":"Name Type     <code>Key</code> extends <code>string</code> | <code>number</code> | <code>symbol</code>   <code>ContentType</code> <code>DefinitionContentType</code>&lt;<code>ModelTypes</code>, <code>Key</code>&gt;","title":"Type parameters"},{"location":"reference/self-id/classes/core.PublicID/#parameters_1","text":"Name Type     <code>key</code> <code>Key</code>","title":"Parameters"},{"location":"reference/self-id/classes/core.PublicID/#returns_1","text":"<p><code>Promise</code>&lt;<code>null</code> | <code>ContentType</code>&gt;</p>","title":"Returns"},{"location":"reference/self-id/classes/react.RequestClient/","text":"<p>react.RequestClient</p> <p>Extends <code>core.Core</code></p> <pre><code>import { RequestClient } from '@self.id/react'\n</code></pre>","title":"Class: RequestClient&lt;ModelTypes, Alias&gt;"},{"location":"reference/self-id/classes/react.RequestClient/#type-parameters","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code> = <code>CoreModelTypes</code>   <code>Alias</code> extends keyof <code>ModelTypes</code>[<code>\"definitions\"</code>] = keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]","title":"Type parameters"},{"location":"reference/self-id/classes/react.RequestClient/#hierarchy","text":"<ul> <li><code>Core</code>&lt;<code>ModelTypes</code>&gt;</li> </ul> <p>\u21b3 <code>RequestClient</code></p>","title":"Hierarchy"},{"location":"reference/self-id/classes/react.RequestClient/#constructors","text":"","title":"Constructors"},{"location":"reference/self-id/classes/react.RequestClient/#constructor","text":"<p>\u2022 new RequestClient&lt;<code>ModelTypes</code>, <code>Alias</code>&gt;(<code>params</code>)</p>","title":"constructor"},{"location":"reference/self-id/classes/react.RequestClient/#type-parameters_1","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt; = <code>ModelTypes</code>   <code>Alias</code> extends <code>string</code> | <code>number</code> | <code>symbol</code> = keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]","title":"Type parameters"},{"location":"reference/self-id/classes/react.RequestClient/#parameters","text":"Name Type     <code>params</code> <code>RequestClientParams</code>&lt;<code>ModelTypes</code>&gt;","title":"Parameters"},{"location":"reference/self-id/classes/react.RequestClient/#overrides","text":"<p>Core&lt;ModelTypes\\&gt;.constructor</p>","title":"Overrides"},{"location":"reference/self-id/classes/react.RequestClient/#accessors","text":"","title":"Accessors"},{"location":"reference/self-id/classes/react.RequestClient/#ceramic","text":"<p>\u2022 <code>get</code> ceramic(): <code>CeramicClient</code></p>","title":"ceramic"},{"location":"reference/self-id/classes/react.RequestClient/#returns","text":"<p><code>CeramicClient</code></p>","title":"Returns"},{"location":"reference/self-id/classes/react.RequestClient/#inherited-from","text":"<p>Core.ceramic</p>","title":"Inherited from"},{"location":"reference/self-id/classes/react.RequestClient/#datamodel","text":"<p>\u2022 <code>get</code> dataModel(): <code>DataModel</code>&lt;<code>ModelTypes</code>, <code>ModelTypesToAliases</code>&lt;<code>ModelTypes</code>&gt;&gt;</p>","title":"dataModel"},{"location":"reference/self-id/classes/react.RequestClient/#returns_1","text":"<p><code>DataModel</code>&lt;<code>ModelTypes</code>, <code>ModelTypesToAliases</code>&lt;<code>ModelTypes</code>&gt;&gt;</p>","title":"Returns"},{"location":"reference/self-id/classes/react.RequestClient/#inherited-from_1","text":"<p>Core.dataModel</p>","title":"Inherited from"},{"location":"reference/self-id/classes/react.RequestClient/#datastore","text":"<p>\u2022 <code>get</code> dataStore(): <code>DIDDataStore</code>&lt;<code>ModelTypes</code>, keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]&gt;</p>","title":"dataStore"},{"location":"reference/self-id/classes/react.RequestClient/#returns_2","text":"<p><code>DIDDataStore</code>&lt;<code>ModelTypes</code>, keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]&gt;</p>","title":"Returns"},{"location":"reference/self-id/classes/react.RequestClient/#inherited-from_2","text":"<p>Core.dataStore</p>","title":"Inherited from"},{"location":"reference/self-id/classes/react.RequestClient/#resolver","text":"<p>\u2022 <code>get</code> resolver(): <code>Resolver</code></p>","title":"resolver"},{"location":"reference/self-id/classes/react.RequestClient/#returns_3","text":"<p><code>Resolver</code></p>","title":"Returns"},{"location":"reference/self-id/classes/react.RequestClient/#inherited-from_3","text":"<p>Core.resolver</p>","title":"Inherited from"},{"location":"reference/self-id/classes/react.RequestClient/#tileloader","text":"<p>\u2022 <code>get</code> tileLoader(): <code>TileLoader</code></p>","title":"tileLoader"},{"location":"reference/self-id/classes/react.RequestClient/#returns_4","text":"<p><code>TileLoader</code></p>","title":"Returns"},{"location":"reference/self-id/classes/react.RequestClient/#inherited-from_4","text":"<p>Core.tileLoader</p>","title":"Inherited from"},{"location":"reference/self-id/classes/react.RequestClient/#viewerid","text":"<p>\u2022 <code>get</code> viewerID(): <code>null</code> | <code>string</code></p>","title":"viewerID"},{"location":"reference/self-id/classes/react.RequestClient/#returns_5","text":"<p><code>null</code> | <code>string</code></p>","title":"Returns"},{"location":"reference/self-id/classes/react.RequestClient/#methods","text":"","title":"Methods"},{"location":"reference/self-id/classes/react.RequestClient/#get","text":"<p>\u25b8 get&lt;<code>Key</code>, <code>ContentType</code>&gt;(<code>key</code>, <code>id</code>): <code>Promise</code>&lt;<code>null</code> | <code>ContentType</code>&gt;</p>","title":"get"},{"location":"reference/self-id/classes/react.RequestClient/#type-parameters_2","text":"Name Type     <code>Key</code> extends <code>string</code> | <code>number</code> | <code>symbol</code>   <code>ContentType</code> <code>DefinitionContentType</code>&lt;<code>ModelTypes</code>, <code>Key</code>&gt;","title":"Type parameters"},{"location":"reference/self-id/classes/react.RequestClient/#parameters_1","text":"Name Type     <code>key</code> <code>Key</code>   <code>id</code> <code>string</code>","title":"Parameters"},{"location":"reference/self-id/classes/react.RequestClient/#returns_6","text":"<p><code>Promise</code>&lt;<code>null</code> | <code>ContentType</code>&gt;</p>","title":"Returns"},{"location":"reference/self-id/classes/react.RequestClient/#inherited-from_5","text":"<p>Core.get</p>","title":"Inherited from"},{"location":"reference/self-id/classes/react.RequestClient/#getaccountdid","text":"<p>\u25b8 getAccountDID(<code>account</code>): <code>Promise</code>&lt;<code>string</code>&gt;</p>","title":"getAccountDID"},{"location":"reference/self-id/classes/react.RequestClient/#parameters_2","text":"Name Type     <code>account</code> <code>string</code>","title":"Parameters"},{"location":"reference/self-id/classes/react.RequestClient/#returns_7","text":"<p><code>Promise</code>&lt;<code>string</code>&gt;</p>","title":"Returns"},{"location":"reference/self-id/classes/react.RequestClient/#inherited-from_6","text":"<p>Core.getAccountDID</p>","title":"Inherited from"},{"location":"reference/self-id/classes/react.RequestClient/#getstate","text":"<p>\u25b8 getState(): <code>RequestState</code></p>","title":"getState"},{"location":"reference/self-id/classes/react.RequestClient/#returns_8","text":"<p><code>RequestState</code></p>","title":"Returns"},{"location":"reference/self-id/classes/react.RequestClient/#prefetch","text":"<p>\u25b8 prefetch&lt;<code>Key</code>&gt;(<code>key</code>, <code>id?</code>): <code>Promise</code>&lt;<code>boolean</code>&gt;</p>","title":"prefetch"},{"location":"reference/self-id/classes/react.RequestClient/#type-parameters_3","text":"Name Type     <code>Key</code> extends <code>string</code> | <code>number</code> | <code>symbol</code>","title":"Type parameters"},{"location":"reference/self-id/classes/react.RequestClient/#parameters_3","text":"Name Type     <code>key</code> <code>Key</code>   <code>id</code> <code>null</code> | <code>string</code>","title":"Parameters"},{"location":"reference/self-id/classes/react.RequestClient/#returns_9","text":"<p><code>Promise</code>&lt;<code>boolean</code>&gt;</p>","title":"Returns"},{"location":"reference/self-id/classes/react.RequestClient/#todid","text":"<p>\u25b8 toDID(<code>accountOrDID</code>): <code>Promise</code>&lt;<code>string</code>&gt;</p>","title":"toDID"},{"location":"reference/self-id/classes/react.RequestClient/#parameters_4","text":"Name Type     <code>accountOrDID</code> <code>string</code>","title":"Parameters"},{"location":"reference/self-id/classes/react.RequestClient/#returns_10","text":"<p><code>Promise</code>&lt;<code>string</code>&gt;</p>","title":"Returns"},{"location":"reference/self-id/classes/react.RequestClient/#inherited-from_7","text":"<p>Core.toDID</p>","title":"Inherited from"},{"location":"reference/self-id/classes/web.SelfID/","text":"<p>web.SelfID</p> <pre><code>import { SelfID } from '@self.id/web'\n</code></pre>","title":"Class: SelfID&lt;ModelTypes, Alias&gt;"},{"location":"reference/self-id/classes/web.SelfID/#type-parameters","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code> = <code>CoreModelTypes</code>   <code>Alias</code> extends keyof <code>ModelTypes</code>[<code>\"definitions\"</code>] = keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]","title":"Type parameters"},{"location":"reference/self-id/classes/web.SelfID/#constructors","text":"","title":"Constructors"},{"location":"reference/self-id/classes/web.SelfID/#constructor","text":"<p>\u2022 new SelfID&lt;<code>ModelTypes</code>, <code>Alias</code>&gt;(<code>params</code>)</p>","title":"constructor"},{"location":"reference/self-id/classes/web.SelfID/#type-parameters_1","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt; = <code>ModelTypes</code>   <code>Alias</code> extends <code>string</code> | <code>number</code> | <code>symbol</code> = keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]","title":"Type parameters"},{"location":"reference/self-id/classes/web.SelfID/#parameters","text":"Name Type     <code>params</code> <code>SelfIDParams</code>&lt;<code>ModelTypes</code>&gt;","title":"Parameters"},{"location":"reference/self-id/classes/web.SelfID/#accessors","text":"","title":"Accessors"},{"location":"reference/self-id/classes/web.SelfID/#client","text":"<p>\u2022 <code>get</code> client(): <code>WebClient</code>&lt;<code>ModelTypes</code>&gt;</p>","title":"client"},{"location":"reference/self-id/classes/web.SelfID/#returns","text":"<p><code>WebClient</code>&lt;<code>ModelTypes</code>&gt;</p>","title":"Returns"},{"location":"reference/self-id/classes/web.SelfID/#did","text":"<p>\u2022 <code>get</code> did(): <code>DID</code></p>","title":"did"},{"location":"reference/self-id/classes/web.SelfID/#returns_1","text":"<p><code>DID</code></p>","title":"Returns"},{"location":"reference/self-id/classes/web.SelfID/#id","text":"<p>\u2022 <code>get</code> id(): <code>string</code></p>","title":"id"},{"location":"reference/self-id/classes/web.SelfID/#returns_2","text":"<p><code>string</code></p>","title":"Returns"},{"location":"reference/self-id/classes/web.SelfID/#methods","text":"","title":"Methods"},{"location":"reference/self-id/classes/web.SelfID/#get","text":"<p>\u25b8 get&lt;<code>Key</code>, <code>ContentType</code>&gt;(<code>key</code>): <code>Promise</code>&lt;<code>null</code> | <code>ContentType</code>&gt;</p>","title":"get"},{"location":"reference/self-id/classes/web.SelfID/#type-parameters_2","text":"Name Type     <code>Key</code> extends <code>string</code> | <code>number</code> | <code>symbol</code>   <code>ContentType</code> <code>DefinitionContentType</code>&lt;<code>ModelTypes</code>, <code>Key</code>&gt;","title":"Type parameters"},{"location":"reference/self-id/classes/web.SelfID/#parameters_1","text":"Name Type     <code>key</code> <code>Key</code>","title":"Parameters"},{"location":"reference/self-id/classes/web.SelfID/#returns_3","text":"<p><code>Promise</code>&lt;<code>null</code> | <code>ContentType</code>&gt;</p>","title":"Returns"},{"location":"reference/self-id/classes/web.SelfID/#merge","text":"<p>\u25b8 merge&lt;<code>Key</code>, <code>ContentType</code>&gt;(<code>key</code>, <code>content</code>): <code>Promise</code>&lt;<code>StreamID</code>&gt;</p>","title":"merge"},{"location":"reference/self-id/classes/web.SelfID/#type-parameters_3","text":"Name Type     <code>Key</code> extends <code>string</code> | <code>number</code> | <code>symbol</code>   <code>ContentType</code> <code>DefinitionContentType</code>&lt;<code>ModelTypes</code>, <code>Key</code>&gt;","title":"Type parameters"},{"location":"reference/self-id/classes/web.SelfID/#parameters_2","text":"Name Type     <code>key</code> <code>Key</code>   <code>content</code> <code>ContentType</code>","title":"Parameters"},{"location":"reference/self-id/classes/web.SelfID/#returns_4","text":"<p><code>Promise</code>&lt;<code>StreamID</code>&gt;</p>","title":"Returns"},{"location":"reference/self-id/classes/web.SelfID/#set","text":"<p>\u25b8 set&lt;<code>Key</code>, <code>ContentType</code>&gt;(<code>key</code>, <code>content</code>): <code>Promise</code>&lt;<code>StreamID</code>&gt;</p>","title":"set"},{"location":"reference/self-id/classes/web.SelfID/#type-parameters_4","text":"Name Type     <code>Key</code> extends <code>string</code> | <code>number</code> | <code>symbol</code>   <code>ContentType</code> <code>DefinitionContentType</code>&lt;<code>ModelTypes</code>, <code>Key</code>&gt;","title":"Type parameters"},{"location":"reference/self-id/classes/web.SelfID/#parameters_3","text":"Name Type     <code>key</code> <code>Key</code>   <code>content</code> <code>ContentType</code>","title":"Parameters"},{"location":"reference/self-id/classes/web.SelfID/#returns_5","text":"<p><code>Promise</code>&lt;<code>StreamID</code>&gt;</p>","title":"Returns"},{"location":"reference/self-id/classes/web.SelfID/#authenticate","text":"<p>\u25b8 <code>Static</code> authenticate&lt;<code>ModelTypes</code>&gt;(<code>params</code>): <code>Promise</code>&lt;<code>SelfID</code>&lt;<code>ModelTypes</code>, keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]&gt;&gt;</p>","title":"authenticate"},{"location":"reference/self-id/classes/web.SelfID/#type-parameters_5","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt; = <code>ModelTypes</code>","title":"Type parameters"},{"location":"reference/self-id/classes/web.SelfID/#parameters_4","text":"Name Type     <code>params</code> <code>AuthenticateParams</code>&lt;<code>ModelTypes</code>&gt;","title":"Parameters"},{"location":"reference/self-id/classes/web.SelfID/#returns_6","text":"<p><code>Promise</code>&lt;<code>SelfID</code>&lt;<code>ModelTypes</code>, keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]&gt;&gt;</p>","title":"Returns"},{"location":"reference/self-id/classes/web.WebClient/","text":"<p>web.WebClient</p> <p>Extends <code>core.Core</code></p> <pre><code>import { WebClient } from '@self.id/web'\n</code></pre>","title":"Class: WebClient&lt;ModelTypes&gt;"},{"location":"reference/self-id/classes/web.WebClient/#type-parameters","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code> = <code>CoreModelTypes</code>","title":"Type parameters"},{"location":"reference/self-id/classes/web.WebClient/#hierarchy","text":"<ul> <li><code>Core</code>&lt;<code>ModelTypes</code>&gt;</li> </ul> <p>\u21b3 <code>WebClient</code></p>","title":"Hierarchy"},{"location":"reference/self-id/classes/web.WebClient/#constructors","text":"","title":"Constructors"},{"location":"reference/self-id/classes/web.WebClient/#constructor","text":"<p>\u2022 new WebClient&lt;<code>ModelTypes</code>&gt;(<code>params</code>)</p>","title":"constructor"},{"location":"reference/self-id/classes/web.WebClient/#type-parameters_1","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt; = <code>ModelTypes</code>","title":"Type parameters"},{"location":"reference/self-id/classes/web.WebClient/#parameters","text":"Name Type     <code>params</code> <code>WebClientParams</code>&lt;<code>ModelTypes</code>&gt;","title":"Parameters"},{"location":"reference/self-id/classes/web.WebClient/#overrides","text":"<p>Core&lt;ModelTypes\\&gt;.constructor</p>","title":"Overrides"},{"location":"reference/self-id/classes/web.WebClient/#accessors","text":"","title":"Accessors"},{"location":"reference/self-id/classes/web.WebClient/#ceramic","text":"<p>\u2022 <code>get</code> ceramic(): <code>CeramicClient</code></p>","title":"ceramic"},{"location":"reference/self-id/classes/web.WebClient/#returns","text":"<p><code>CeramicClient</code></p>","title":"Returns"},{"location":"reference/self-id/classes/web.WebClient/#inherited-from","text":"<p>Core.ceramic</p>","title":"Inherited from"},{"location":"reference/self-id/classes/web.WebClient/#datamodel","text":"<p>\u2022 <code>get</code> dataModel(): <code>DataModel</code>&lt;<code>ModelTypes</code>, <code>ModelTypesToAliases</code>&lt;<code>ModelTypes</code>&gt;&gt;</p>","title":"dataModel"},{"location":"reference/self-id/classes/web.WebClient/#returns_1","text":"<p><code>DataModel</code>&lt;<code>ModelTypes</code>, <code>ModelTypesToAliases</code>&lt;<code>ModelTypes</code>&gt;&gt;</p>","title":"Returns"},{"location":"reference/self-id/classes/web.WebClient/#inherited-from_1","text":"<p>Core.dataModel</p>","title":"Inherited from"},{"location":"reference/self-id/classes/web.WebClient/#datastore","text":"<p>\u2022 <code>get</code> dataStore(): <code>DIDDataStore</code>&lt;<code>ModelTypes</code>, keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]&gt;</p>","title":"dataStore"},{"location":"reference/self-id/classes/web.WebClient/#returns_2","text":"<p><code>DIDDataStore</code>&lt;<code>ModelTypes</code>, keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]&gt;</p>","title":"Returns"},{"location":"reference/self-id/classes/web.WebClient/#inherited-from_2","text":"<p>Core.dataStore</p>","title":"Inherited from"},{"location":"reference/self-id/classes/web.WebClient/#resolver","text":"<p>\u2022 <code>get</code> resolver(): <code>Resolver</code></p>","title":"resolver"},{"location":"reference/self-id/classes/web.WebClient/#returns_3","text":"<p><code>Resolver</code></p>","title":"Returns"},{"location":"reference/self-id/classes/web.WebClient/#inherited-from_3","text":"<p>Core.resolver</p>","title":"Inherited from"},{"location":"reference/self-id/classes/web.WebClient/#threeid","text":"<p>\u2022 <code>get</code> threeId(): <code>ThreeIdConnect</code></p>","title":"threeId"},{"location":"reference/self-id/classes/web.WebClient/#returns_4","text":"<p><code>ThreeIdConnect</code></p>","title":"Returns"},{"location":"reference/self-id/classes/web.WebClient/#tileloader","text":"<p>\u2022 <code>get</code> tileLoader(): <code>TileLoader</code></p>","title":"tileLoader"},{"location":"reference/self-id/classes/web.WebClient/#returns_5","text":"<p><code>TileLoader</code></p>","title":"Returns"},{"location":"reference/self-id/classes/web.WebClient/#inherited-from_4","text":"<p>Core.tileLoader</p>","title":"Inherited from"},{"location":"reference/self-id/classes/web.WebClient/#methods","text":"","title":"Methods"},{"location":"reference/self-id/classes/web.WebClient/#authenticate","text":"<p>\u25b8 authenticate(<code>authProvider</code>, <code>attachToCeramic?</code>): <code>Promise</code>&lt;<code>DID</code>&gt;</p>","title":"authenticate"},{"location":"reference/self-id/classes/web.WebClient/#parameters_1","text":"Name Type Default value     <code>authProvider</code> <code>EthereumAuthProvider</code> <code>undefined</code>   <code>attachToCeramic</code> <code>boolean</code> <code>true</code>","title":"Parameters"},{"location":"reference/self-id/classes/web.WebClient/#returns_6","text":"<p><code>Promise</code>&lt;<code>DID</code>&gt;</p>","title":"Returns"},{"location":"reference/self-id/classes/web.WebClient/#connect","text":"<p>\u25b8 connect(<code>authProvider</code>): <code>Promise</code>&lt;<code>DID</code>&gt;</p>","title":"connect"},{"location":"reference/self-id/classes/web.WebClient/#parameters_2","text":"Name Type     <code>authProvider</code> <code>EthereumAuthProvider</code>","title":"Parameters"},{"location":"reference/self-id/classes/web.WebClient/#returns_7","text":"<p><code>Promise</code>&lt;<code>DID</code>&gt;</p>","title":"Returns"},{"location":"reference/self-id/classes/web.WebClient/#get","text":"<p>\u25b8 get&lt;<code>Key</code>, <code>ContentType</code>&gt;(<code>key</code>, <code>id</code>): <code>Promise</code>&lt;<code>null</code> | <code>ContentType</code>&gt;</p>","title":"get"},{"location":"reference/self-id/classes/web.WebClient/#type-parameters_2","text":"Name Type     <code>Key</code> extends <code>string</code> | <code>number</code> | <code>symbol</code>   <code>ContentType</code> <code>DefinitionContentType</code>&lt;<code>ModelTypes</code>, <code>Key</code>&gt;","title":"Type parameters"},{"location":"reference/self-id/classes/web.WebClient/#parameters_3","text":"Name Type     <code>key</code> <code>Key</code>   <code>id</code> <code>string</code>","title":"Parameters"},{"location":"reference/self-id/classes/web.WebClient/#returns_8","text":"<p><code>Promise</code>&lt;<code>null</code> | <code>ContentType</code>&gt;</p>","title":"Returns"},{"location":"reference/self-id/classes/web.WebClient/#inherited-from_5","text":"<p>Core.get</p>","title":"Inherited from"},{"location":"reference/self-id/classes/web.WebClient/#getaccountdid","text":"<p>\u25b8 getAccountDID(<code>account</code>): <code>Promise</code>&lt;<code>string</code>&gt;</p>","title":"getAccountDID"},{"location":"reference/self-id/classes/web.WebClient/#parameters_4","text":"Name Type     <code>account</code> <code>string</code>","title":"Parameters"},{"location":"reference/self-id/classes/web.WebClient/#returns_9","text":"<p><code>Promise</code>&lt;<code>string</code>&gt;</p>","title":"Returns"},{"location":"reference/self-id/classes/web.WebClient/#inherited-from_6","text":"<p>Core.getAccountDID</p>","title":"Inherited from"},{"location":"reference/self-id/classes/web.WebClient/#todid","text":"<p>\u25b8 toDID(<code>accountOrDID</code>): <code>Promise</code>&lt;<code>string</code>&gt;</p>","title":"toDID"},{"location":"reference/self-id/classes/web.WebClient/#parameters_5","text":"Name Type     <code>accountOrDID</code> <code>string</code>","title":"Parameters"},{"location":"reference/self-id/classes/web.WebClient/#returns_10","text":"<p><code>Promise</code>&lt;<code>string</code>&gt;</p>","title":"Returns"},{"location":"reference/self-id/classes/web.WebClient/#inherited-from_7","text":"<p>Core.toDID</p>","title":"Inherited from"},{"location":"reference/self-id/modules/3box_legacy/","text":"<p>Load legacy 3Box profiles.</p>","title":"Module: 3box-legacy"},{"location":"reference/self-id/modules/3box_legacy/#purpose","text":"<p>The<code>3box-legacy</code> module provides utility functions to load legacy 3Box profiles.</p>","title":"Purpose"},{"location":"reference/self-id/modules/3box_legacy/#installation","text":"<pre><code>npm install @self.id/3box-legacy\n</code></pre>","title":"Installation"},{"location":"reference/self-id/modules/3box_legacy/#common-use-cases","text":"","title":"Common use-cases"},{"location":"reference/self-id/modules/3box_legacy/#load-a-legacy-3box-profile-as-a-selfid-basic-profile","text":"<pre><code>import { getLegacy3BoxProfileAsBasicProfile } from '@self.id/3box-legacy'\n\nasync function getProfile() {\n  // Ethereum address to load the profile of\n  const address = '0x123efad...'\n  return await getLegacy3BoxProfileAsBasicProfile(address)\n}\n</code></pre>","title":"Load a legacy 3Box profile as a Self.ID basic profile"},{"location":"reference/self-id/modules/3box_legacy/#functions","text":"","title":"Functions"},{"location":"reference/self-id/modules/3box_legacy/#getlegacy3boxprofileasbasicprofile","text":"<p>\u25b8 getLegacy3BoxProfileAsBasicProfile(<code>address</code>): <code>Promise</code>&lt;<code>BasicProfile</code> | <code>null</code>&gt;</p>","title":"getLegacy3BoxProfileAsBasicProfile"},{"location":"reference/self-id/modules/3box_legacy/#parameters","text":"Name Type     <code>address</code> <code>string</code>","title":"Parameters"},{"location":"reference/self-id/modules/3box_legacy/#returns","text":"<p><code>Promise</code>&lt;<code>BasicProfile</code> | <code>null</code>&gt;</p>","title":"Returns"},{"location":"reference/self-id/modules/3box_legacy/#loadlegacy3boxprofile","text":"<p>\u25b8 loadLegacy3BoxProfile&lt;<code>T</code>&gt;(<code>address</code>): <code>Promise</code>&lt;<code>T</code> | <code>null</code>&gt;</p>","title":"loadLegacy3BoxProfile"},{"location":"reference/self-id/modules/3box_legacy/#type-parameters","text":"Name Type     <code>T</code> <code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;","title":"Type parameters"},{"location":"reference/self-id/modules/3box_legacy/#parameters_1","text":"Name Type     <code>address</code> <code>string</code>","title":"Parameters"},{"location":"reference/self-id/modules/3box_legacy/#returns_1","text":"<p><code>Promise</code>&lt;<code>T</code> | <code>null</code>&gt;</p>","title":"Returns"},{"location":"reference/self-id/modules/3box_legacy/#transformprofile","text":"<p>\u25b8 <code>Const</code> transformProfile(<code>profile</code>): <code>BasicProfile</code></p>","title":"transformProfile"},{"location":"reference/self-id/modules/3box_legacy/#parameters_2","text":"Name Type     <code>profile</code> <code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;","title":"Parameters"},{"location":"reference/self-id/modules/3box_legacy/#returns_2","text":"<p><code>BasicProfile</code></p>","title":"Returns"},{"location":"reference/self-id/modules/core/","text":"<p>Read public records in Node and browsers environments.</p>","title":"Module: core"},{"location":"reference/self-id/modules/core/#purpose","text":"<p>The <code>core</code> module of the Self.ID SDK exports the <code>Core</code> and <code>PublicID</code> classes to provide APIs for reading public records in Node and browsers environments.</p> <p>It can therefore be used both client-side and server-side by applications wanting to access records associated to a DID on a Ceramic network.</p>","title":"Purpose"},{"location":"reference/self-id/modules/core/#installation","text":"<pre><code>npm install @self.id/core\n</code></pre>","title":"Installation"},{"location":"reference/self-id/modules/core/#common-use-cases","text":"","title":"Common use-cases"},{"location":"reference/self-id/modules/core/#read-the-basic-profile-of-a-known-did","text":"<pre><code>import { Core } from '@self.id/core'\n\nconst core = new Core({ ceramic: 'testnet-clay' })\n\nasync function getProfile() {\n  // Replace by the wanted DID string\n  const did = 'did:3:...'\n  return await core.get('basicProfile', did)\n}\n</code></pre>","title":"Read the basic profile of a known DID"},{"location":"reference/self-id/modules/core/#connect-to-a-custom-ceramic-node","text":"<pre><code>import { Core } from '@self.id/core'\n\n// You can provide the URL of a custom node as the `ceramic` parameter\nconst core = new Core({ ceramic: 'https://ceramic-clay.3boxlabs.com' })\n</code></pre>","title":"Connect to a custom Ceramic node"},{"location":"reference/self-id/modules/core/#use-a-custom-data-model","text":"<pre><code>import { Core } from '@self.id/core'\n\nconst model = {\n  definitions: {\n    basicProfile: 'kjzl6cwe1jw145cjbeko9kil8g9bxszjhyde21ob8epxuxkaon1izyqsu8wgcic',\n    notes: 'kjzl6cwe1jw14688v7zhf5eo1uiblt0thkgdedb5gaiq99isj224g6v8uza2r4m',\n  },\n  schemas: {\n    BasicProfile: 'ceramic://k3y52l7qbv1frxt706gqfzmq6cbqdkptzk8uudaryhlkf6ly9vx21hqu4r6k1jqio',\n    Note: 'ceramic://k3y52l7qbv1fryg3uy4gz50pj3ivni18h6younsgd2kb5u7mivx3h258m01tkwk5c',\n    Notes: 'ceramic://k3y52l7qbv1frxk024s7ds2456qo3rwa02k31uf98loz8lm1lodlgv3eeqh4cxgjk',\n  },\n  tiles: {\n    placeholderNote: 'kjzl6cwe1jw148snra9bmyf32y5pj2ysnvenqx59k7n2lz3gnri72axvp25fo1v',\n  },\n}\nconst core = new Core({ ceramic: 'testnet-clay', model })\n\nasync function getNotes(did) {\n  return await core.get('notes', did)\n}\n</code></pre>","title":"Use a custom data model"},{"location":"reference/self-id/modules/core/#use-a-publicid-instance","text":"<pre><code>import { Core, PublicID } from '@self.id/core'\n\nconst core = new Core({ ceramic: 'testnet-clay' })\n// Replace the `id` parameter by the wanted DID string\nconst currentUser = new PublicID({ core, id: 'did:3:...' })\n\nasync function getCurrentUserProfile() {\n  return await currentUser.get('basicProfile')\n}\n</code></pre>","title":"Use a PublicID instance"},{"location":"reference/self-id/modules/core/#classes","text":"<ul> <li>Core</li> <li>PublicID</li> </ul>","title":"Classes"},{"location":"reference/self-id/modules/core/#type-aliases","text":"","title":"Type aliases"},{"location":"reference/self-id/modules/core/#ceramicnetwork","text":"<p>\u01ac CeramicNetwork: <code>\"local\"</code> | <code>\"mainnet-gateway\"</code> | <code>\"testnet-clay\"</code> | <code>\"testnet-clay-gateway\"</code></p>","title":"CeramicNetwork"},{"location":"reference/self-id/modules/core/#coremodeltypes","text":"<p>\u01ac CoreModelTypes: <code>ModelTypeAliases</code>&lt;{ <code>AlsoKnownAs</code>: <code>AlsoKnownAs</code> ; <code>BasicProfile</code>: <code>BasicProfile</code> ; <code>CryptoAccounts</code>: <code>CryptoAccountLinks</code>  }, { <code>alsoKnownAs</code>: <code>\"AlsoKnownAs\"</code> ; <code>basicProfile</code>: <code>\"BasicProfile\"</code> ; <code>cryptoAccounts</code>: <code>\"CryptoAccounts\"</code>  }&gt;</p>","title":"CoreModelTypes"},{"location":"reference/self-id/modules/core/#coreparams","text":"<p>\u01ac CoreParams&lt;<code>ModelTypes</code>&gt;: <code>Object</code></p>","title":"CoreParams"},{"location":"reference/self-id/modules/core/#type-parameters","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code> = <code>CoreModelTypes</code>","title":"Type parameters"},{"location":"reference/self-id/modules/core/#type-declaration","text":"Name Type     <code>cache?</code> <code>TileCache</code> | <code>boolean</code>   <code>ceramic</code> <code>CeramicNetwork</code> | <code>string</code>   <code>loader?</code> <code>TileLoader</code>   <code>model?</code> <code>ModelTypesToAliases</code>&lt;<code>ModelTypes</code>&gt;","title":"Type declaration"},{"location":"reference/self-id/modules/core/#publicidparams","text":"<p>\u01ac PublicIDParams&lt;<code>ModelTypes</code>&gt;: <code>Object</code></p>","title":"PublicIDParams"},{"location":"reference/self-id/modules/core/#type-parameters_1","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code> = <code>CoreModelTypes</code>","title":"Type parameters"},{"location":"reference/self-id/modules/core/#type-declaration_1","text":"Name Type     <code>core</code> <code>Core</code>&lt;<code>ModelTypes</code>&gt;   <code>id</code> <code>string</code>","title":"Type declaration"},{"location":"reference/self-id/modules/framework/","text":"<p>React framework for decentralized apps.</p>","title":"Module: framework"},{"location":"reference/self-id/modules/framework/#purpose","text":"<p>The <code>framework</code> module is the highest-level abstraction provided by the Self.ID SDK, aimed at helping developers to quickly get started with building decentralized apps using Ceramic with React.</p> <p>The framework is built on top of the <code>core</code>, <code>web</code>, <code>react</code>, <code>ui</code> and <code>multiauth</code> modules to provide APIs and UI components to easily authenticate users based on Wallet providers, keep track of the current user and interact with both public (read-only) and user-owned (mutable) records.</p>","title":"Purpose"},{"location":"reference/self-id/modules/framework/#installation","text":"<pre><code>npm install @self.id/framework\n</code></pre>","title":"Installation"},{"location":"reference/self-id/modules/framework/#common-use-cases","text":"","title":"Common use-cases"},{"location":"reference/self-id/modules/framework/#configure-the-provider","text":"<p>The <code>Provider</code> component must be added at the root of the application tree in order to use the hooks described below. It can be used to provide a custom configuration for the Self.ID clients, authentication, state and UI options.</p> <pre><code>import { Provider } from '@self.id/framework'\n\nfunction App({ children }) {\n  return &lt;Provider client={{ ceramic: 'testnet-clay' }}&gt;{children}&lt;/Provider&gt;\n}\n</code></pre>","title":"Configure the Provider"},{"location":"reference/self-id/modules/framework/#authenticate-the-user","text":"<p>The framework provides a React hook to easily initiate an authentication flow for the Viewer (the \"current user\" of the app). This flow is made of the following steps:</p> <ol> <li>A modal prompts the user to select a Wallet to connect with</li> <li>Selecting a Wallet initiates the connection to access the Ethereum provider</li> <li>An <code>EthereumAuthProvider</code> instance is created using the Ethereum provider</li> <li>The authentication flow with 3ID Connect starts, using the <code>EthereumAuthProvider</code> instance</li> <li>A <code>SelfID</code> instance is created and stored in the application state</li> </ol> <p>Once this flow is successfully applied, the Viewer's cookie is set to the authenticated DID and writing records associated to the Viewer becomes possible.</p> <pre><code>import { useConnection } from '@self.id/framework'\n\n// A simple button to initiate the connection flow. A Provider must be present at a higher level\n// in the component tree for the `useConnection()` hook to work.\nfunction ConnectButton() {\n  const [connection, connect, disconnect] = useConnection()\n\n  return connection.status === 'connected' ? (\n    &lt;button\n      onClick={() =&gt; {\n        disconnect()\n      }}&gt;\n      Disconnect ({connection.selfID.id})\n    &lt;/button&gt;\n  ) : 'ethereum' in window ? (\n    &lt;button\n      disabled={connection.status === 'connecting'}\n      onClick={() =&gt; {\n        connect()\n      }}&gt;\n      Connect\n    &lt;/button&gt;\n  ) : (\n    &lt;p&gt;\n      An injected Ethereum provider such as{' '}\n      &lt;a href=\"https://metamask.io/\"&gt;MetaMask&lt;/a&gt; is needed to authenticate.\n    &lt;/p&gt;\n  )\n}\n</code></pre>","title":"Authenticate the user"},{"location":"reference/self-id/modules/framework/#read-a-viewer-record","text":"<p>The <code>useViewerRecord</code> hook loads the record for a given definition in the index of the current viewer, with the following variants:</p> <ul> <li>If no viewer is set, no record can be loaded</li> <li>If the viewer is not authenticated, the record gets loaded but cannot be mutated</li> <li>If the viewer is authenticated, the record gets loaded and be mutated</li> </ul> <pre><code>import { useViewerRecord } from '@self.id/framework'\n\nfunction ShowViewerName() {\n  const record = useViewerRecord('basicProfile')\n\n  const text = record.isLoading\n    ? 'Loading...'\n    : record.content\n    ? `Hello ${record.content.name || 'stranger'}`\n    : 'No profile to load'\n  return &lt;p&gt;{text}&lt;/p&gt;\n}\n</code></pre>","title":"Read a viewer record"},{"location":"reference/self-id/modules/framework/#read-a-public-record","text":"<p>The <code>usePublicRecord</code> hook is similar to the <code>useViewerRecord</code> hook described above, but reading from the index of an explicitly provided account rather than the viewer. Public records are read-only, <code>useViewerRecord</code> must be used in  case mutations are needed.</p> <pre><code>import { usePublicRecord } from '@self.id/framework'\n\nfunction ShowProfileName({ did }) {\n  const record = usePublicRecord('basicProfile', did)\n\n  const text = record.isLoading\n    ? 'Loading...'\n    : record.content\n    ? `Hello ${record.content.name || 'stranger'}`\n    : 'No profile to load'\n  return &lt;p&gt;{text}&lt;/p&gt;\n}\n</code></pre>","title":"Read a public record"},{"location":"reference/self-id/modules/framework/#server-side-prefetching","text":"<p>Server-side rendering can be used to improve the user experience for the first load of an app or page. The framework exports a <code>RequestClient</code> class from the <code>@self.id/react</code> package that can be used to fetch wanted records on the server in order to have them immediately available by the <code>usePublicRecord</code> and <code>useViewerRecord</code> hooks.</p> <p>The following example shows how this can be used in a Next.js page, using the <code>ShowViewerName</code> component created in the previous example:</p> <pre><code>import { Provider, RequestClient } from '@self.id/framework'\n\nexport const getServerSideProps = async (ctx) =&gt; {\n  const client = new RequestClient({\n    ceramic: 'testnet-clay',\n    // Inject the cookie from the request headers to parse the viewerID\n    cookie: ctx.req.headers.cookie,\n  })\n  if (client.viewerID != null) {\n    // If the viewerID is set, fetch its profile\n    await client.prefetch('basicProfile', client.viewerID)\n  }\n  return { props: { state: client.getState() } }\n}\n\n// Use the state prop injected by the server\nexport default function Home({ state }) {\n  return (\n    &lt;Provider state={state}&gt;\n      &lt;ShowViewerName /&gt;\n    &lt;/Provider&gt;\n  )\n}\n</code></pre>","title":"Server-side prefetching"},{"location":"reference/self-id/modules/framework/#re-exported-classes","text":"<ul> <li><code>core.Core</code></li> <li><code>core.PublicID</code></li> <li><code>react.RequestClient</code></li> <li><code>web.SelfID</code></li> <li><code>EthereumAuthProvider</code> from 3ID Connect</li> </ul>","title":"Re-exported classes"},{"location":"reference/self-id/modules/framework/#re-exported-components","text":"<ul> <li><code>ui.AvatarPlaceholder</code></li> </ul>","title":"Re-exported components"},{"location":"reference/self-id/modules/framework/#type-aliases","text":"","title":"Type aliases"},{"location":"reference/self-id/modules/framework/#colortype","text":"<p>\u01ac ColorType: <code>string</code> | { <code>dark?</code>: <code>string</code> ; <code>light?</code>: <code>string</code>  } | <code>undefined</code></p>","title":"ColorType"},{"location":"reference/self-id/modules/framework/#colors","text":"<p>\u01ac Colors: <code>Record</code>&lt;<code>string</code>, <code>ColorType</code>&gt;</p>","title":"Colors"},{"location":"reference/self-id/modules/framework/#connectnetwork","text":"<p>\u01ac ConnectNetwork: <code>\"dev-unstable\"</code> | <code>\"mainnet\"</code> | <code>\"testnet-clay\"</code></p>","title":"ConnectNetwork"},{"location":"reference/self-id/modules/framework/#connectoptions","text":"<p>\u01ac ConnectOptions: <code>Object</code></p>","title":"ConnectOptions"},{"location":"reference/self-id/modules/framework/#type-declaration","text":"Name Type     <code>switchAccount?</code> <code>boolean</code>","title":"Type declaration"},{"location":"reference/self-id/modules/framework/#connectedcontainerprops","text":"<p>\u01ac ConnectedContainerProps: <code>Object</code></p>","title":"ConnectedContainerProps"},{"location":"reference/self-id/modules/framework/#type-declaration_1","text":"Name Type     <code>children</code> <code>ReactNode</code>   <code>renderFallback?</code> (<code>connectionState</code>: <code>ConnectionState</code>&lt;<code>ModelTypes</code>&gt;) =&gt; <code>null</code> | <code>Element</code>","title":"Type declaration"},{"location":"reference/self-id/modules/framework/#connectionstate","text":"<p>\u01ac ConnectionState&lt;<code>ModelTypes</code>&gt;: { <code>status</code>: <code>\"disconnected\"</code>  } | { <code>status</code>: <code>\"connecting\"</code>  } | { <code>selfID</code>: <code>SelfID</code>&lt;<code>ModelTypes</code>&gt; ; <code>status</code>: <code>\"connected\"</code>  } | { <code>error?</code>: <code>Error</code> ; <code>status</code>: <code>\"failed\"</code>  }</p>","title":"ConnectionState"},{"location":"reference/self-id/modules/framework/#type-parameters","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code> = <code>CoreModelTypes</code>","title":"Type parameters"},{"location":"reference/self-id/modules/framework/#dimensions","text":"<p>\u01ac Dimensions: <code>Object</code></p>","title":"Dimensions"},{"location":"reference/self-id/modules/framework/#type-declaration_2","text":"Name Type     <code>height</code> <code>number</code>   <code>width</code> <code>number</code>","title":"Type declaration"},{"location":"reference/self-id/modules/framework/#providerprops","text":"<p>\u01ac ProviderProps&lt;<code>ModelTypes</code>&gt;: <code>ReactProviderProps</code>&lt;<code>ModelTypes</code>&gt; &amp; { <code>auth?</code>: <code>MultiAuthProviderConfig</code> ; <code>ui?</code>: <code>UIProviderProps</code>  }</p>","title":"ProviderProps"},{"location":"reference/self-id/modules/framework/#type-parameters_1","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code> = <code>CoreModelTypes</code>","title":"Type parameters"},{"location":"reference/self-id/modules/framework/#publicrecord","text":"<p>\u01ac PublicRecord&lt;<code>ContentType</code>&gt;: <code>Object</code></p>","title":"PublicRecord"},{"location":"reference/self-id/modules/framework/#type-parameters_2","text":"Name     <code>ContentType</code>","title":"Type parameters"},{"location":"reference/self-id/modules/framework/#type-declaration_3","text":"Name Type     <code>content?</code> <code>ContentType</code>   <code>error?</code> <code>unknown</code>   <code>isError</code> <code>boolean</code>   <code>isLoading</code> <code>boolean</code>","title":"Type declaration"},{"location":"reference/self-id/modules/framework/#requestclientparams","text":"<p>\u01ac RequestClientParams&lt;<code>ModelTypes</code>&gt;: <code>CoreParams</code>&lt;<code>ModelTypes</code>&gt; &amp; { <code>cookie?</code>: <code>string</code>  }</p>","title":"RequestClientParams"},{"location":"reference/self-id/modules/framework/#type-parameters_3","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code> = <code>CoreModelTypes</code>","title":"Type parameters"},{"location":"reference/self-id/modules/framework/#requeststate","text":"<p>\u01ac RequestState: <code>Object</code></p>","title":"RequestState"},{"location":"reference/self-id/modules/framework/#type-declaration_4","text":"Name Type     <code>hydrate?</code> <code>DehydratedState</code>   <code>viewerID?</code> <code>string</code> | <code>null</code>","title":"Type declaration"},{"location":"reference/self-id/modules/framework/#viewerrecord","text":"<p>\u01ac ViewerRecord&lt;<code>ContentType</code>&gt;: { <code>content?</code>: <code>never</code> ; <code>error?</code>: <code>never</code> ; <code>isError</code>: <code>false</code> ; <code>isLoadable</code>: <code>false</code> ; <code>isLoading</code>: <code>false</code> ; <code>isMutable</code>: <code>false</code> ; <code>isMutating</code>: <code>false</code> ; <code>merge?</code>: <code>never</code> ; <code>set?</code>: <code>never</code>  } | { <code>content?</code>: <code>ContentType</code> ; <code>error?</code>: <code>unknown</code> ; <code>isError</code>: <code>boolean</code> ; <code>isLoadable</code>: <code>true</code> ; <code>isLoading</code>: <code>boolean</code> ; <code>isMutable</code>: <code>boolean</code> ; <code>isMutating</code>: <code>boolean</code> ; <code>merge</code>: (<code>content</code>: <code>ContentType</code>) =&gt; <code>Promise</code>&lt;<code>void</code>&gt; ; <code>set</code>: (<code>content</code>: <code>ContentType</code>) =&gt; <code>Promise</code>&lt;<code>void</code>&gt;  }</p>","title":"ViewerRecord"},{"location":"reference/self-id/modules/framework/#type-parameters_4","text":"Name     <code>ContentType</code>","title":"Type parameters"},{"location":"reference/self-id/modules/framework/#variables","text":"","title":"Variables"},{"location":"reference/self-id/modules/framework/#colors_1","text":"<p>\u2022 colors: <code>Colors</code></p>","title":"colors"},{"location":"reference/self-id/modules/framework/#theme","text":"<p>\u2022 theme: <code>ThemeType</code></p>","title":"theme"},{"location":"reference/self-id/modules/framework/#functions","text":"","title":"Functions"},{"location":"reference/self-id/modules/framework/#avatarplaceholder","text":"<p>\u25b8 AvatarPlaceholder(<code>props</code>): <code>JSX.Element</code></p>","title":"AvatarPlaceholder"},{"location":"reference/self-id/modules/framework/#parameters","text":"Name Type     <code>props</code> <code>AvatarPlaceholderProps</code>","title":"Parameters"},{"location":"reference/self-id/modules/framework/#returns","text":"<p><code>JSX.Element</code></p>","title":"Returns"},{"location":"reference/self-id/modules/framework/#connectedcontainer","text":"<p>\u25b8 ConnectedContainer(<code>props</code>): <code>JSX.Element</code> | <code>null</code></p>","title":"ConnectedContainer"},{"location":"reference/self-id/modules/framework/#parameters_1","text":"Name Type     <code>props</code> <code>ConnectedContainerProps</code>","title":"Parameters"},{"location":"reference/self-id/modules/framework/#returns_1","text":"<p><code>JSX.Element</code> | <code>null</code></p>","title":"Returns"},{"location":"reference/self-id/modules/framework/#provider","text":"<p>\u25b8 Provider&lt;<code>ModelTypes</code>&gt;(<code>props</code>): <code>JSX.Element</code></p>","title":"Provider"},{"location":"reference/self-id/modules/framework/#type-parameters_5","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt; = <code>ModelTypes</code>","title":"Type parameters"},{"location":"reference/self-id/modules/framework/#parameters_2","text":"Name Type     <code>props</code> <code>ProviderProps</code>&lt;<code>ModelTypes</code>&gt;","title":"Parameters"},{"location":"reference/self-id/modules/framework/#returns_2","text":"<p><code>JSX.Element</code></p>","title":"Returns"},{"location":"reference/self-id/modules/framework/#formatdid","text":"<p>\u25b8 formatDID(<code>did</code>, <code>maxLength?</code>): <code>string</code></p>","title":"formatDID"},{"location":"reference/self-id/modules/framework/#parameters_3","text":"Name Type Default value     <code>did</code> <code>string</code> <code>undefined</code>   <code>maxLength</code> <code>number</code> <code>20</code>","title":"Parameters"},{"location":"reference/self-id/modules/framework/#returns_3","text":"<p><code>string</code></p>","title":"Returns"},{"location":"reference/self-id/modules/framework/#getimageurl","text":"<p>\u25b8 getImageURL(<code>ipfsPrefix</code>, <code>sources</code>, <code>dimensions</code>): <code>string</code> | <code>undefined</code></p>","title":"getImageURL"},{"location":"reference/self-id/modules/framework/#parameters_4","text":"Name Type     <code>ipfsPrefix</code> <code>string</code>   <code>sources</code> <code>undefined</code> | <code>ImageSources</code>   <code>dimensions</code> <code>Dimensions</code>","title":"Parameters"},{"location":"reference/self-id/modules/framework/#returns_4","text":"<p><code>string</code> | <code>undefined</code></p>","title":"Returns"},{"location":"reference/self-id/modules/framework/#selectimagesource","text":"<p>\u25b8 selectImageSource(<code>sources</code>, <code>dimensions</code>, <code>mode?</code>): <code>ImageMetadata</code></p>","title":"selectImageSource"},{"location":"reference/self-id/modules/framework/#parameters_5","text":"Name Type     <code>sources</code> <code>ImageSources</code>   <code>dimensions</code> <code>Dimensions</code>   <code>mode?</code> <code>SizeMode</code>","title":"Parameters"},{"location":"reference/self-id/modules/framework/#returns_5","text":"<p><code>ImageMetadata</code></p>","title":"Returns"},{"location":"reference/self-id/modules/framework/#uploadimage","text":"<p>\u25b8 uploadImage(<code>url</code>, <code>file</code>, <code>sizes?</code>): <code>Promise</code>&lt;<code>ImageSources</code>&gt;</p>","title":"uploadImage"},{"location":"reference/self-id/modules/framework/#parameters_6","text":"Name Type     <code>url</code> <code>string</code>   <code>file</code> <code>File</code>   <code>sizes?</code> <code>Dimensions</code>[]","title":"Parameters"},{"location":"reference/self-id/modules/framework/#returns_6","text":"<p><code>Promise</code>&lt;<code>ImageSources</code>&gt;</p>","title":"Returns"},{"location":"reference/self-id/modules/framework/#useconnection","text":"<p>\u25b8 useConnection&lt;<code>ModelTypes</code>&gt;(): [<code>ConnectionState</code>&lt;<code>ModelTypes</code>&gt;, (<code>options?</code>: <code>ConnectOptions</code>) =&gt; <code>Promise</code>&lt;<code>SelfID</code>&lt;<code>ModelTypes</code>&gt; | <code>null</code>&gt;, () =&gt; <code>void</code>]</p>","title":"useConnection"},{"location":"reference/self-id/modules/framework/#type-parameters_6","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt; = <code>ModelTypes</code>","title":"Type parameters"},{"location":"reference/self-id/modules/framework/#returns_7","text":"<p>[<code>ConnectionState</code>&lt;<code>ModelTypes</code>&gt;, (<code>options?</code>: <code>ConnectOptions</code>) =&gt; <code>Promise</code>&lt;<code>SelfID</code>&lt;<code>ModelTypes</code>&gt; | <code>null</code>&gt;, () =&gt; <code>void</code>]</p>","title":"Returns"},{"location":"reference/self-id/modules/framework/#usecore","text":"<p>\u25b8 useCore&lt;<code>ModelTypes</code>&gt;(): <code>Core</code>&lt;<code>ModelTypes</code>&gt;</p>","title":"useCore"},{"location":"reference/self-id/modules/framework/#type-parameters_7","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt; = <code>ModelTypes</code>","title":"Type parameters"},{"location":"reference/self-id/modules/framework/#returns_8","text":"<p><code>Core</code>&lt;<code>ModelTypes</code>&gt;</p>","title":"Returns"},{"location":"reference/self-id/modules/framework/#usepublicrecord","text":"<p>\u25b8 usePublicRecord&lt;<code>ModelTypes</code>, <code>Alias</code>, <code>ContentType</code>&gt;(<code>alias</code>, <code>id</code>): <code>PublicRecord</code>&lt;<code>ContentType</code> | <code>null</code>&gt;</p>","title":"usePublicRecord"},{"location":"reference/self-id/modules/framework/#type-parameters_8","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt; = <code>ModelTypes</code>   <code>Alias</code> extends <code>string</code> | <code>number</code> | <code>symbol</code> = keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]   <code>ContentType</code> <code>DefinitionContentType</code>&lt;<code>ModelTypes</code>, <code>Alias</code>&gt;","title":"Type parameters"},{"location":"reference/self-id/modules/framework/#parameters_7","text":"Name Type     <code>alias</code> <code>Alias</code>   <code>id</code> <code>string</code>","title":"Parameters"},{"location":"reference/self-id/modules/framework/#returns_9","text":"<p><code>PublicRecord</code>&lt;<code>ContentType</code> | <code>null</code>&gt;</p>","title":"Returns"},{"location":"reference/self-id/modules/framework/#useviewerid","text":"<p>\u25b8 useViewerID&lt;<code>ModelTypes</code>&gt;(): <code>ViewerID</code>&lt;<code>ModelTypes</code>&gt; | <code>null</code></p>","title":"useViewerID"},{"location":"reference/self-id/modules/framework/#type-parameters_9","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt; = <code>ModelTypes</code>","title":"Type parameters"},{"location":"reference/self-id/modules/framework/#returns_10","text":"<p><code>ViewerID</code>&lt;<code>ModelTypes</code>&gt; | <code>null</code></p>","title":"Returns"},{"location":"reference/self-id/modules/framework/#useviewerrecord","text":"<p>\u25b8 useViewerRecord&lt;<code>ModelTypes</code>, <code>Alias</code>, <code>ContentType</code>&gt;(<code>alias</code>): <code>ViewerRecord</code>&lt;<code>ContentType</code> | <code>null</code>&gt;</p>","title":"useViewerRecord"},{"location":"reference/self-id/modules/framework/#type-parameters_10","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt; = <code>ModelTypes</code>   <code>Alias</code> extends <code>string</code> | <code>number</code> | <code>symbol</code> = keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]   <code>ContentType</code> <code>DefinitionContentType</code>&lt;<code>ModelTypes</code>, <code>Alias</code>&gt;","title":"Type parameters"},{"location":"reference/self-id/modules/framework/#parameters_8","text":"Name Type     <code>alias</code> <code>Alias</code>","title":"Parameters"},{"location":"reference/self-id/modules/framework/#returns_11","text":"<p><code>ViewerRecord</code>&lt;<code>ContentType</code> | <code>null</code>&gt;</p>","title":"Returns"},{"location":"reference/self-id/modules/image_utils/","text":"<p>Image utilities for Self.ID profiles.</p>","title":"Module: image-utils"},{"location":"reference/self-id/modules/image_utils/#purpose","text":"<p>The <code>image-utils</code> module provides various utility functions for images, such as selecting the most suitable format among sources, resizing and uploading, and is mostly meant to be used in a Web browser context.</p>","title":"Purpose"},{"location":"reference/self-id/modules/image_utils/#installation","text":"<pre><code>npm install @self.id/image-utils\n</code></pre>","title":"Installation"},{"location":"reference/self-id/modules/image_utils/#common-use-cases","text":"","title":"Common use-cases"},{"location":"reference/self-id/modules/image_utils/#resize-and-upload-an-image-to-multiple-dimensions","text":"<p>Using a <code>SelfID</code> instance from the <code>web</code> module.</p> <pre><code>import { uploadImage } from '@self.id/image-utils'\n\n// The `file` argument must implement the File interface from\n// https://developer.mozilla.org/en-US/docs/Web/API/File\nasync function setProfileImage(selfID, file) {\n  const imageSources = await uploadFile(\n    'https://ipfs.infura.io:5001/api/v0',\n    file,\n    [{ width: 60, height: 60 }, { width: 200, height: 200 }],\n  )\n  // Here `selfID` must be an instance of `SelfID` from the `web` module\n  await selfID.merge({ image: imageSources })\n}\n</code></pre>","title":"Resize and upload an image to multiple dimensions"},{"location":"reference/self-id/modules/image_utils/#get-the-most-suitable-image-source-for-given-dimensions","text":"<p>Using a <code>Core</code> instance from the <code>core</code> module.</p> <pre><code>import { Core } from '@self.id/core'\nimport { selectImageSource } from '@self.id/image-utils'\n\nconst core = new Core({ ceramic: 'testnet-clay' })\n\nasync function getAvatarSource(did) {\n  const profile = await core.get('basicProfile', did)\n  return profile?.image ? selectImageSource(profile.image, { width: 60, height: 60 }) : null\n}\n</code></pre>","title":"Get the most suitable image source for given dimensions"},{"location":"reference/self-id/modules/image_utils/#type-aliases","text":"","title":"Type aliases"},{"location":"reference/self-id/modules/image_utils/#dimensions","text":"<p>\u01ac Dimensions: <code>Object</code></p>","title":"Dimensions"},{"location":"reference/self-id/modules/image_utils/#type-declaration","text":"Name Type     <code>height</code> <code>number</code>   <code>width</code> <code>number</code>","title":"Type declaration"},{"location":"reference/self-id/modules/image_utils/#linkdata","text":"<p>\u01ac LinkData: <code>Object</code></p>","title":"LinkData"},{"location":"reference/self-id/modules/image_utils/#type-declaration_1","text":"Name Type     <code>Hash</code> <code>string</code>   <code>Name</code> <code>string</code>   <code>Size</code> <code>number</code>","title":"Type declaration"},{"location":"reference/self-id/modules/image_utils/#sizemode","text":"<p>\u01ac SizeMode: <code>\"contain\"</code> | <code>\"cover\"</code></p>","title":"SizeMode"},{"location":"reference/self-id/modules/image_utils/#sizedimage","text":"<p>\u01ac SizedImage: <code>Dimensions</code> &amp; { <code>blob</code>: <code>Blob</code>  }</p>","title":"SizedImage"},{"location":"reference/self-id/modules/image_utils/#functions","text":"","title":"Functions"},{"location":"reference/self-id/modules/image_utils/#getdimensions","text":"<p>\u25b8 getDimensions(<code>image</code>, <code>dimensions?</code>, <code>mode?</code>): <code>Dimensions</code></p>","title":"getDimensions"},{"location":"reference/self-id/modules/image_utils/#parameters","text":"Name Type Default value     <code>image</code> <code>HTMLImageElement</code> <code>undefined</code>   <code>dimensions</code> <code>Dimensions</code> <code>DEFAULT_DIMENSIONS</code>   <code>mode</code> <code>SizeMode</code> <code>'cover'</code>","title":"Parameters"},{"location":"reference/self-id/modules/image_utils/#returns","text":"<p><code>Dimensions</code></p>","title":"Returns"},{"location":"reference/self-id/modules/image_utils/#loadimage","text":"<p>\u25b8 loadImage(<code>blob</code>): <code>Promise</code>&lt;<code>HTMLImageElement</code>&gt;</p>","title":"loadImage"},{"location":"reference/self-id/modules/image_utils/#parameters_1","text":"Name Type     <code>blob</code> <code>Blob</code>","title":"Parameters"},{"location":"reference/self-id/modules/image_utils/#returns_1","text":"<p><code>Promise</code>&lt;<code>HTMLImageElement</code>&gt;</p>","title":"Returns"},{"location":"reference/self-id/modules/image_utils/#resizeimageelement","text":"<p>\u25b8 resizeImageElement(<code>type</code>, <code>image</code>, <code>dimensions?</code>, <code>mode?</code>): <code>Promise</code>&lt;<code>SizedImage</code>&gt;</p>","title":"resizeImageElement"},{"location":"reference/self-id/modules/image_utils/#parameters_2","text":"Name Type     <code>type</code> <code>string</code>   <code>image</code> <code>HTMLImageElement</code>   <code>dimensions?</code> <code>Dimensions</code>   <code>mode?</code> <code>SizeMode</code>","title":"Parameters"},{"location":"reference/self-id/modules/image_utils/#returns_2","text":"<p><code>Promise</code>&lt;<code>SizedImage</code>&gt;</p>","title":"Returns"},{"location":"reference/self-id/modules/image_utils/#selectimagesource","text":"<p>\u25b8 selectImageSource(<code>sources</code>, <code>dimensions</code>, <code>mode?</code>): <code>ImageMetadata</code></p>","title":"selectImageSource"},{"location":"reference/self-id/modules/image_utils/#parameters_3","text":"Name Type Default value     <code>sources</code> <code>ImageSources</code> <code>undefined</code>   <code>dimensions</code> <code>Dimensions</code> <code>undefined</code>   <code>mode</code> <code>SizeMode</code> <code>'cover'</code>","title":"Parameters"},{"location":"reference/self-id/modules/image_utils/#returns_3","text":"<p><code>ImageMetadata</code></p>","title":"Returns"},{"location":"reference/self-id/modules/image_utils/#uploadfile","text":"<p>\u25b8 uploadFile(<code>url</code>, <code>blob</code>, <code>fileName?</code>): <code>Promise</code>&lt;<code>string</code>&gt;</p>","title":"uploadFile"},{"location":"reference/self-id/modules/image_utils/#parameters_4","text":"Name Type     <code>url</code> <code>string</code>   <code>blob</code> <code>Blob</code>   <code>fileName?</code> <code>string</code>","title":"Parameters"},{"location":"reference/self-id/modules/image_utils/#returns_4","text":"<p><code>Promise</code>&lt;<code>string</code>&gt;</p>","title":"Returns"},{"location":"reference/self-id/modules/image_utils/#uploadimage","text":"<p>\u25b8 uploadImage(<code>url</code>, <code>file</code>, <code>sizes?</code>): <code>Promise</code>&lt;<code>ImageSources</code>&gt;</p>","title":"uploadImage"},{"location":"reference/self-id/modules/image_utils/#parameters_5","text":"Name Type Default value     <code>url</code> <code>string</code> <code>undefined</code>   <code>file</code> <code>File</code> <code>undefined</code>   <code>sizes</code> <code>Dimensions</code>[] <code>[]</code>","title":"Parameters"},{"location":"reference/self-id/modules/image_utils/#returns_5","text":"<p><code>Promise</code>&lt;<code>ImageSources</code>&gt;</p>","title":"Returns"},{"location":"reference/self-id/modules/image_utils/#uploadresizedimage","text":"<p>\u25b8 uploadResizedImage(<code>url</code>, <code>type</code>, <code>image</code>, <code>dimensions?</code>): <code>Promise</code>&lt;<code>ImageMetadata</code>&gt;</p>","title":"uploadResizedImage"},{"location":"reference/self-id/modules/image_utils/#parameters_6","text":"Name Type     <code>url</code> <code>string</code>   <code>type</code> <code>string</code>   <code>image</code> <code>HTMLImageElement</code>   <code>dimensions?</code> <code>Dimensions</code>","title":"Parameters"},{"location":"reference/self-id/modules/image_utils/#returns_6","text":"<p><code>Promise</code>&lt;<code>ImageMetadata</code>&gt;</p>","title":"Returns"},{"location":"reference/self-id/modules/multiauth/","text":"<p>Blockchain authentication for React apps.</p>","title":"Module: multiauth"},{"location":"reference/self-id/modules/multiauth/#purpose","text":"<p>The <code>multiauth</code> module provides a React Provider component and hook to access a Wallet provider from a given Wallet, notably useful in order to authenticate a DID for creating a <code>SelfID</code> instance.</p>","title":"Purpose"},{"location":"reference/self-id/modules/multiauth/#installation","text":"<p>The <code>multiauth</code> module uses components from the Grommet library, that needs to be explicitly installed along <code>@self.id/multiauth</code>:</p> <pre><code>npm install @self.id/multiauth grommet\n</code></pre>","title":"Installation"},{"location":"reference/self-id/modules/multiauth/#common-use-cases","text":"","title":"Common use-cases"},{"location":"reference/self-id/modules/multiauth/#add-the-provider-to-your-component-tree","text":"<p>As the <code>multiauth</code> module uses components from the Grommet library, a top-level container must be added as a parent of the <code>multiauth.Provider</code> component.</p> <p>The <code>Provider</code> component from the <code>ui</code> module can be used to inject this container with a theme matching the Self.ID application. In such cases, the <code>@self.id/ui</code> module needs to also be installed.</p> <pre><code>import { Provider as AuthProvider } from '@self.id/multiauth'\nimport { Provider as UIProvider } from '@self.id/ui'\n\nconst networks = [\n  {\n    key: 'ethereum',\n    connectors: [\n      { key: 'injected' },\n      { key: 'fortmatic', params: { apiKey: fortmaticApiKey }},\n    ],\n  },\n]\n\nfunction App({ children }) {\n  return (\n    &lt;UIProvider&gt;\n      &lt;AuthProvider networks={networks}&gt;{children}&lt;/AuthProvider&gt;\n    &lt;/UIProvider&gt;\n  )\n}\n</code></pre>","title":"Add the Provider to your component tree"},{"location":"reference/self-id/modules/multiauth/#access-the-authentication-state","text":"<pre><code>import { useMultiAuth } from '@self.id/multiauth'\n\nfunction useWallet() {\n  const [authState, authenticate] = useMultiAuth()\n  return [authState.status === 'authenticated' ? authState.auth : null, authenticate]\n}\n</code></pre>","title":"Access the authentication state"},{"location":"reference/self-id/modules/multiauth/#type-aliases","text":"","title":"Type aliases"},{"location":"reference/self-id/modules/multiauth/#authaccount","text":"<p>\u01ac AuthAccount&lt;<code>Key</code>&gt;: <code>Object</code></p>","title":"AuthAccount"},{"location":"reference/self-id/modules/multiauth/#type-parameters","text":"Name Type     <code>Key</code> extends <code>ProviderKey</code> = <code>ProviderKey</code>","title":"Type parameters"},{"location":"reference/self-id/modules/multiauth/#type-declaration","text":"Name Type     <code>accountID</code> <code>AccountID</code>   <code>method</code> <code>AuthMethod</code>   <code>state</code> <code>AuthenticatedState</code>&lt;<code>Key</code>&gt;","title":"Type declaration"},{"location":"reference/self-id/modules/multiauth/#authmethod","text":"<p>\u01ac AuthMethod&lt;<code>Key</code>&gt;: <code>Object</code></p>","title":"AuthMethod"},{"location":"reference/self-id/modules/multiauth/#type-parameters_1","text":"Name Type     <code>Key</code> extends <code>NetworkKey</code> = <code>NetworkKey</code>","title":"Type parameters"},{"location":"reference/self-id/modules/multiauth/#type-declaration_1","text":"Name Type     <code>connector</code> <code>ConnectorConfig</code>   <code>key</code> <code>Key</code>","title":"Type declaration"},{"location":"reference/self-id/modules/multiauth/#authstate","text":"<p>\u01ac AuthState&lt;<code>Key</code>, <code>Provider</code>&gt;: { <code>status</code>: <code>\"idle\"</code>  } | { <code>method?</code>: <code>AuthMethod</code>&lt;<code>Key</code>&gt; ; <code>modal</code>: <code>boolean</code> ; <code>promise</code>: <code>Deferred</code>&lt;<code>AuthAccount</code>&lt;<code>Provider</code>&gt; | <code>null</code>&gt; ; <code>status</code>: <code>\"authenticating\"</code>  } | { <code>auth</code>: <code>AuthAccount</code>&lt;<code>Provider</code>&gt; ; <code>status</code>: <code>\"authenticated\"</code>  } | { <code>error?</code>: <code>Error</code> ; <code>status</code>: <code>\"failed\"</code>  }</p>","title":"AuthState"},{"location":"reference/self-id/modules/multiauth/#type-parameters_2","text":"Name Type     <code>Key</code> extends <code>NetworkKey</code> = <code>NetworkKey</code>   <code>Provider</code> extends <code>NetworkProvider</code>&lt;<code>Key</code>&gt; = <code>NetworkProvider</code>&lt;<code>Key</code>&gt;","title":"Type parameters"},{"location":"reference/self-id/modules/multiauth/#authenticatemode","text":"<p>\u01ac AuthenticateMode: <code>\"select\"</code> | <code>\"reset\"</code> | <code>\"reuse\"</code></p>","title":"AuthenticateMode"},{"location":"reference/self-id/modules/multiauth/#authenticateoptions","text":"<p>\u01ac AuthenticateOptions: <code>Object</code></p>","title":"AuthenticateOptions"},{"location":"reference/self-id/modules/multiauth/#type-declaration_2","text":"Name Type     <code>mode?</code> <code>AuthenticateMode</code>   <code>showModal?</code> <code>boolean</code>","title":"Type declaration"},{"location":"reference/self-id/modules/multiauth/#authenticatedstate","text":"<p>\u01ac AuthenticatedState&lt;<code>Key</code>&gt;: <code>NetworkState</code>&lt;<code>Key</code>&gt; &amp; { <code>account</code>: <code>string</code>  }</p>","title":"AuthenticatedState"},{"location":"reference/self-id/modules/multiauth/#type-parameters_3","text":"Name Type     <code>Key</code> extends <code>ProviderKey</code> = <code>ProviderKey</code>","title":"Type parameters"},{"location":"reference/self-id/modules/multiauth/#config","text":"<p>\u01ac Config: <code>Object</code></p>","title":"Config"},{"location":"reference/self-id/modules/multiauth/#type-declaration_3","text":"Name Type     <code>networks</code> <code>NetworkConfig</code>[]","title":"Type declaration"},{"location":"reference/self-id/modules/multiauth/#connectorconfig","text":"<p>\u01ac ConnectorConfig&lt;<code>Key</code>&gt;: <code>ConnectorConfigDefaults</code> &amp; { <code>key</code>: <code>Key</code> ; <code>providerKey</code>: <code>ProviderKey</code>  }</p>","title":"ConnectorConfig"},{"location":"reference/self-id/modules/multiauth/#type-parameters_4","text":"Name Type     <code>Key</code> extends <code>ConnectorKey</code> = <code>ConnectorKey</code>","title":"Type parameters"},{"location":"reference/self-id/modules/multiauth/#connectorconfigdefaults","text":"<p>\u01ac ConnectorConfigDefaults: <code>DisplayDefaults</code> &amp; { <code>params?</code>: <code>unknown</code> ; <code>getNetworkProvider</code>: (<code>network</code>: <code>Key</code>, <code>params?</code>: <code>unknown</code>) =&gt; <code>null</code> | <code>NetworkProvider</code>&lt;<code>Key</code>&gt; ; <code>getProvider</code>: (<code>key</code>: <code>Key</code>, <code>params?</code>: <code>unknown</code>) =&gt; <code>Promise</code>&lt;<code>ProviderTypes</code>[<code>Key</code>]&gt;  }","title":"ConnectorConfigDefaults"},{"location":"reference/self-id/modules/multiauth/#connectorkey","text":"<p>\u01ac ConnectorKey: <code>\"fortmatic\"</code> | <code>\"injected\"</code> | <code>\"portis\"</code> | <code>\"torus\"</code> | <code>\"walletConnect\"</code></p>","title":"ConnectorKey"},{"location":"reference/self-id/modules/multiauth/#displaydefaults","text":"<p>\u01ac DisplayDefaults: <code>Object</code></p>","title":"DisplayDefaults"},{"location":"reference/self-id/modules/multiauth/#type-declaration_4","text":"Name Type     <code>label</code> <code>string</code>   <code>logo</code> <code>string</code>","title":"Type declaration"},{"location":"reference/self-id/modules/multiauth/#eip1193provider","text":"<p>\u01ac EIP1193Provider: <code>Object</code></p>","title":"EIP1193Provider"},{"location":"reference/self-id/modules/multiauth/#type-declaration_5","text":"Name Type     <code>request</code> (<code>req</code>: \u0002klzzwxh:0529\u0003) =&gt; <code>Promise</code>&lt;<code>Result</code>&gt;","title":"Type declaration"},{"location":"reference/self-id/modules/multiauth/#getnetworkstate","text":"<p>\u01ac GetNetworkState&lt;<code>Key</code>&gt;: (<code>providerKey</code>: <code>Key</code>, <code>provider</code>: <code>ProviderType</code>&lt;<code>Key</code>&gt;, <code>params?</code>: <code>NetworkStateParams</code>) =&gt; <code>Promise</code>&lt;<code>NetworkState</code>&lt;<code>Key</code>&gt;&gt;</p>","title":"GetNetworkState"},{"location":"reference/self-id/modules/multiauth/#type-parameters_5","text":"Name Type     <code>Key</code> extends <code>ProviderKey</code> = <code>ProviderKey</code>","title":"Type parameters"},{"location":"reference/self-id/modules/multiauth/#type-declaration_6","text":"<p>\u25b8 (<code>providerKey</code>, <code>provider</code>, <code>params?</code>): <code>Promise</code>&lt;<code>NetworkState</code>&lt;<code>Key</code>&gt;&gt;</p>","title":"Type declaration"},{"location":"reference/self-id/modules/multiauth/#parameters","text":"Name Type     <code>providerKey</code> <code>Key</code>   <code>provider</code> <code>ProviderType</code>&lt;<code>Key</code>&gt;   <code>params?</code> <code>NetworkStateParams</code>","title":"Parameters"},{"location":"reference/self-id/modules/multiauth/#returns","text":"<p><code>Promise</code>&lt;<code>NetworkState</code>&lt;<code>Key</code>&gt;&gt;</p>","title":"Returns"},{"location":"reference/self-id/modules/multiauth/#jsonrpcresponse","text":"<p>\u01ac JSONRPCResponse&lt;<code>Result</code>&gt;: <code>Object</code></p>","title":"JSONRPCResponse"},{"location":"reference/self-id/modules/multiauth/#type-parameters_6","text":"Name Type     <code>Result</code> <code>unknown</code>","title":"Type parameters"},{"location":"reference/self-id/modules/multiauth/#type-declaration_7","text":"Name Type     <code>error?</code> <code>Error</code>   <code>id</code> <code>string</code> | <code>undefined</code>   <code>jsonrpc</code> <code>\"2.0\"</code>   <code>method</code> <code>string</code>   <code>result?</code> <code>Result</code>","title":"Type declaration"},{"location":"reference/self-id/modules/multiauth/#modalconfig","text":"<p>\u01ac ModalConfig: <code>Object</code></p>","title":"ModalConfig"},{"location":"reference/self-id/modules/multiauth/#type-declaration_8","text":"Name Type     <code>closeIcon?</code> <code>string</code> | <code>ReactElement</code>   <code>selectedIcon?</code> <code>string</code> | <code>ReactElement</code>   <code>text?</code> <code>string</code>   <code>title?</code> <code>string</code>","title":"Type declaration"},{"location":"reference/self-id/modules/multiauth/#multiauthproviderconfig","text":"<p>\u01ac MultiAuthProviderConfig: <code>Object</code></p>","title":"MultiAuthProviderConfig"},{"location":"reference/self-id/modules/multiauth/#type-declaration_9","text":"Name Type     <code>modal?</code> <code>ModalConfig</code>   <code>networks?</code> <code>PartialNetworkConfig</code>[]","title":"Type declaration"},{"location":"reference/self-id/modules/multiauth/#networkconfig","text":"<p>\u01ac NetworkConfig&lt;<code>Key</code>&gt;: <code>DisplayDefaults</code> &amp; { <code>connectors</code>: <code>ConnectorConfig</code>[] ; <code>getState</code>: <code>GetNetworkState</code>&lt;<code>NetworkProvider</code>&lt;<code>Key</code>&gt;&gt; ; <code>key</code>: <code>Key</code>  }</p>","title":"NetworkConfig"},{"location":"reference/self-id/modules/multiauth/#type-parameters_7","text":"Name Type     <code>Key</code> extends <code>NetworkKey</code> = <code>NetworkKey</code>","title":"Type parameters"},{"location":"reference/self-id/modules/multiauth/#networkconfigdefaults","text":"<p>\u01ac NetworkConfigDefaults: <code>DisplayDefaults</code> &amp; { <code>connectors</code>: <code>ConnectorKey</code>[] ; <code>getState</code>: <code>GetNetworkState</code>&lt;<code>ProviderKey</code>&gt;  }</p>","title":"NetworkConfigDefaults"},{"location":"reference/self-id/modules/multiauth/#networkkey","text":"<p>\u01ac NetworkKey: keyof <code>Networks</code></p>","title":"NetworkKey"},{"location":"reference/self-id/modules/multiauth/#networkprovider","text":"<p>\u01ac NetworkProvider&lt;<code>Key</code>&gt;: <code>Networks</code>[<code>Key</code>]</p>","title":"NetworkProvider"},{"location":"reference/self-id/modules/multiauth/#type-parameters_8","text":"Name Type     <code>Key</code> extends <code>NetworkKey</code>","title":"Type parameters"},{"location":"reference/self-id/modules/multiauth/#networkstate","text":"<p>\u01ac NetworkState&lt;<code>Key</code>&gt;: <code>Object</code></p>","title":"NetworkState"},{"location":"reference/self-id/modules/multiauth/#type-parameters_9","text":"Name Type     <code>Key</code> extends <code>ProviderKey</code>","title":"Type parameters"},{"location":"reference/self-id/modules/multiauth/#type-declaration_10","text":"Name Type     <code>account</code> <code>string</code> | <code>null</code>   <code>chainID</code> <code>ChainID</code>   <code>provider</code> <code>ProviderType</code>&lt;<code>Key</code>&gt;   <code>providerKey</code> <code>Key</code>","title":"Type declaration"},{"location":"reference/self-id/modules/multiauth/#networkstateparams","text":"<p>\u01ac NetworkStateParams: <code>Object</code></p>","title":"NetworkStateParams"},{"location":"reference/self-id/modules/multiauth/#type-declaration_11","text":"Name Type     <code>account?</code> <code>string</code>   <code>chainID?</code> <code>ChainID</code> | <code>ChainIDParams</code> | <code>string</code> | <code>number</code>","title":"Type declaration"},{"location":"reference/self-id/modules/multiauth/#networks","text":"<p>\u01ac Networks: <code>Object</code></p>","title":"Networks"},{"location":"reference/self-id/modules/multiauth/#type-declaration_12","text":"Name Type     <code>ethereum</code> <code>\"eip1193\"</code> | <code>\"web3\"</code>","title":"Type declaration"},{"location":"reference/self-id/modules/multiauth/#partialconfig","text":"<p>\u01ac PartialConfig: <code>Object</code></p>","title":"PartialConfig"},{"location":"reference/self-id/modules/multiauth/#type-declaration_13","text":"Name Type     <code>networks?</code> <code>PartialNetworkConfig</code>[]","title":"Type declaration"},{"location":"reference/self-id/modules/multiauth/#partialconnectorconfig","text":"<p>\u01ac PartialConnectorConfig&lt;<code>Key</code>&gt;: <code>Key</code> | <code>Partial</code>&lt;<code>ConnectorConfigDefaults</code>&gt; &amp; { <code>key</code>: <code>Key</code>  }</p>","title":"PartialConnectorConfig"},{"location":"reference/self-id/modules/multiauth/#type-parameters_10","text":"Name Type     <code>Key</code> extends <code>ConnectorKey</code> = <code>ConnectorKey</code>","title":"Type parameters"},{"location":"reference/self-id/modules/multiauth/#partialnetworkconfig","text":"<p>\u01ac PartialNetworkConfig&lt;<code>Key</code>&gt;: <code>Key</code> | <code>Partial</code>&lt;<code>DisplayDefaults</code>&gt; &amp; { <code>connectors?</code>: <code>PartialConnectorConfig</code>[] ; <code>key</code>: <code>Key</code>  }</p>","title":"PartialNetworkConfig"},{"location":"reference/self-id/modules/multiauth/#type-parameters_11","text":"Name Type     <code>Key</code> extends <code>NetworkKey</code> = <code>NetworkKey</code>","title":"Type parameters"},{"location":"reference/self-id/modules/multiauth/#providerkey","text":"<p>\u01ac ProviderKey: keyof <code>ProviderTypes</code></p>","title":"ProviderKey"},{"location":"reference/self-id/modules/multiauth/#providerprops","text":"<p>\u01ac ProviderProps: <code>MultiAuthProviderConfig</code> &amp; { <code>children</code>: <code>ReactNode</code>  }</p>","title":"ProviderProps"},{"location":"reference/self-id/modules/multiauth/#providertype","text":"<p>\u01ac ProviderType&lt;<code>Key</code>&gt;: <code>ProviderTypes</code>[<code>Key</code>]</p>","title":"ProviderType"},{"location":"reference/self-id/modules/multiauth/#type-parameters_12","text":"Name Type     <code>Key</code> extends <code>ProviderKey</code>","title":"Type parameters"},{"location":"reference/self-id/modules/multiauth/#providertypes","text":"<p>\u01ac ProviderTypes: <code>Object</code></p>","title":"ProviderTypes"},{"location":"reference/self-id/modules/multiauth/#type-declaration_14","text":"Name Type     <code>eip1193</code> <code>EIP1193Provider</code>   <code>web3</code> <code>Web3Provider</code>","title":"Type declaration"},{"location":"reference/self-id/modules/multiauth/#requestarguments","text":"<p>\u01ac RequestArguments: <code>Object</code></p>","title":"RequestArguments"},{"location":"reference/self-id/modules/multiauth/#type-declaration_15","text":"Name Type     <code>method</code> <code>string</code>   <code>params?</code> <code>unknown</code>[] | <code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;","title":"Type declaration"},{"location":"reference/self-id/modules/multiauth/#web3provider","text":"<p>\u01ac Web3Provider: <code>Object</code></p>","title":"Web3Provider"},{"location":"reference/self-id/modules/multiauth/#type-declaration_16","text":"Name Type     <code>enable</code> () =&gt; <code>Promise</code>&lt;<code>string</code>[]&gt;   <code>sendAsync</code> &lt;Result&gt;(<code>req</code>: <code>RequestArguments</code>, <code>callback</code>: <code>Web3ProviderSendCallback</code>&lt;<code>Result</code>&gt;) =&gt; <code>void</code>","title":"Type declaration"},{"location":"reference/self-id/modules/multiauth/#web3providersendcallback","text":"<p>\u01ac Web3ProviderSendCallback&lt;<code>Result</code>&gt;: (<code>err?</code>: <code>Error</code>, <code>response?</code>: <code>JSONRPCResponse</code>&lt;<code>Result</code>&gt;) =&gt; <code>void</code></p>","title":"Web3ProviderSendCallback"},{"location":"reference/self-id/modules/multiauth/#type-parameters_13","text":"Name Type     <code>Result</code> <code>unknown</code>","title":"Type parameters"},{"location":"reference/self-id/modules/multiauth/#type-declaration_17","text":"<p>\u25b8 (<code>err?</code>, <code>response?</code>): <code>void</code></p>","title":"Type declaration"},{"location":"reference/self-id/modules/multiauth/#parameters_1","text":"Name Type     <code>err?</code> <code>Error</code>   <code>response?</code> <code>JSONRPCResponse</code>&lt;<code>Result</code>&gt;","title":"Parameters"},{"location":"reference/self-id/modules/multiauth/#returns_1","text":"<p><code>void</code></p>","title":"Returns"},{"location":"reference/self-id/modules/multiauth/#functions","text":"","title":"Functions"},{"location":"reference/self-id/modules/multiauth/#provider","text":"<p>\u25b8 Provider(<code>props</code>): <code>ReactElement</code></p>","title":"Provider"},{"location":"reference/self-id/modules/multiauth/#parameters_2","text":"Name Type     <code>props</code> <code>ProviderProps</code>","title":"Parameters"},{"location":"reference/self-id/modules/multiauth/#returns_2","text":"<p><code>ReactElement</code></p>","title":"Returns"},{"location":"reference/self-id/modules/multiauth/#getconnectorconfig","text":"<p>\u25b8 getConnectorConfig&lt;<code>Key</code>&gt;(<code>network</code>, <code>connector</code>): <code>ConnectorConfig</code>&lt;<code>Key</code>&gt;</p>","title":"getConnectorConfig"},{"location":"reference/self-id/modules/multiauth/#type-parameters_14","text":"Name Type     <code>Key</code> extends <code>ConnectorKey</code>","title":"Type parameters"},{"location":"reference/self-id/modules/multiauth/#parameters_3","text":"Name Type     <code>network</code> <code>\"ethereum\"</code>   <code>connector</code> <code>PartialConnectorConfig</code>&lt;<code>Key</code>&gt;","title":"Parameters"},{"location":"reference/self-id/modules/multiauth/#returns_3","text":"<p><code>ConnectorConfig</code>&lt;<code>Key</code>&gt;</p>","title":"Returns"},{"location":"reference/self-id/modules/multiauth/#getconnectorsconfig","text":"<p>\u25b8 getConnectorsConfig(<code>network</code>, <code>connectors</code>): <code>ConnectorConfig</code>[]</p>","title":"getConnectorsConfig"},{"location":"reference/self-id/modules/multiauth/#parameters_4","text":"Name Type     <code>network</code> <code>\"ethereum\"</code>   <code>connectors</code> <code>PartialConnectorConfig</code>&lt;<code>ConnectorKey</code>&gt;[]","title":"Parameters"},{"location":"reference/self-id/modules/multiauth/#returns_4","text":"<p><code>ConnectorConfig</code>[]</p>","title":"Returns"},{"location":"reference/self-id/modules/multiauth/#getnetworkconfig","text":"<p>\u25b8 getNetworkConfig&lt;<code>Key</code>&gt;(<code>network</code>): <code>NetworkConfig</code>&lt;<code>Key</code>&gt;</p>","title":"getNetworkConfig"},{"location":"reference/self-id/modules/multiauth/#type-parameters_15","text":"Name Type     <code>Key</code> extends <code>\"ethereum\"</code>","title":"Type parameters"},{"location":"reference/self-id/modules/multiauth/#parameters_5","text":"Name Type     <code>network</code> <code>PartialNetworkConfig</code>&lt;<code>Key</code>&gt;","title":"Parameters"},{"location":"reference/self-id/modules/multiauth/#returns_5","text":"<p><code>NetworkConfig</code>&lt;<code>Key</code>&gt;</p>","title":"Returns"},{"location":"reference/self-id/modules/multiauth/#getnetworksconfig","text":"<p>\u25b8 getNetworksConfig(<code>providers</code>): <code>NetworkConfig</code>[]</p>","title":"getNetworksConfig"},{"location":"reference/self-id/modules/multiauth/#parameters_6","text":"Name Type     <code>providers</code> <code>PartialNetworkConfig</code>&lt;<code>\"ethereum\"</code>&gt;[]","title":"Parameters"},{"location":"reference/self-id/modules/multiauth/#returns_6","text":"<p><code>NetworkConfig</code>[]</p>","title":"Returns"},{"location":"reference/self-id/modules/multiauth/#usemultiauth","text":"<p>\u25b8 useMultiAuth(): [<code>AuthState</code>, (<code>options?</code>: <code>AuthenticateOptions</code>) =&gt; <code>Promise</code>&lt;<code>AuthAccount</code> | <code>null</code>&gt;, () =&gt; <code>void</code>]</p>","title":"useMultiAuth"},{"location":"reference/self-id/modules/multiauth/#returns_7","text":"<p>[<code>AuthState</code>, (<code>options?</code>: <code>AuthenticateOptions</code>) =&gt; <code>Promise</code>&lt;<code>AuthAccount</code> | <code>null</code>&gt;, () =&gt; <code>void</code>]</p>","title":"Returns"},{"location":"reference/self-id/modules/react/","text":"<p>React hooks and utilities for authentication and records interactions.</p>","title":"Module: react"},{"location":"reference/self-id/modules/react/#purpose","text":"<p>The <code>react</code> module provides React components, hooks and related utility functions to help manage authentication and interactions with records, similar to the <code>web</code> module but designed specifically to be used with React.</p>","title":"Purpose"},{"location":"reference/self-id/modules/react/#installation","text":"<pre><code>npm install @self.id/react\n</code></pre>","title":"Installation"},{"location":"reference/self-id/modules/react/#common-use-cases","text":"","title":"Common use-cases"},{"location":"reference/self-id/modules/react/#configure-the-provider","text":"<p>The <code>Provider</code> component must be added at the root of the application tree in order to use the hooks described below. It can be used to provide a custom configuration for the Self.ID clients and queries, as well as initial state.</p> <pre><code>import { Provider } from '@self.id/react'\n\nfunction App({ children }) {\n  return &lt;Provider client={{ ceramic: 'testnet-clay' }}&gt;{children}&lt;/Provider&gt;\n}\n</code></pre>","title":"Configure the Provider"},{"location":"reference/self-id/modules/react/#authenticate-the-user","text":"<p>The module provides a React hook to easily initiate an authentication flow for the Viewer (the \"current user\" of the app) using an <code>EthereumAuthProvider</code> instance, notably exported by the <code>web</code> module. Once authenticated, the Viewer's cookie is set to the authenticated DID and writing records associated to the Viewer becomes possible.</p> <pre><code>import { useViewerConnection } from '@self.id/react'\nimport { EthereumAuthProvider } from '@self.id/web'\n\nasync function createAuthProvider() {\n  // The following assumes there is an injected `window.ethereum` provider\n  const addresses = await window.ethereum.request({ method: 'eth_requestAccounts' })\n  return new EthereumAuthProvider(window.ethereum, addresses[0])\n}\n\n// A simple button to initiate the connection flow. A Provider must be present at a higher level\n// in the component tree for the `useViewerConnection()` hook to work.\nfunction ConnectButton() {\n  const [connection, connect, disconnect] = useViewerConnection()\n\n  return connection.status === 'connected' ? (\n    &lt;button\n      onClick={() =&gt; {\n        disconnect()\n      }}&gt;\n      Disconnect ({connection.selfID.id})\n    &lt;/button&gt;\n  ) : 'ethereum' in window ? (\n    &lt;button\n      disabled={connection.status === 'connecting'}\n      onClick={() =&gt; {\n        createAuthProvider().then(connect)\n      }}&gt;\n      Connect\n    &lt;/button&gt;\n  ) : (\n    &lt;p&gt;\n      An injected Ethereum provider such as{' '}\n      &lt;a href=\"https://metamask.io/\"&gt;MetaMask&lt;/a&gt; is needed to authenticate.\n    &lt;/p&gt;\n  )\n}\n</code></pre>","title":"Authenticate the user"},{"location":"reference/self-id/modules/react/#read-a-viewer-record","text":"<p>The <code>useViewerRecord</code> hook loads the record for a given definition in the index of the current viewer, with the following variants:</p> <ul> <li>If no viewer is set, no record can be loaded</li> <li>If the viewer is not authenticated, the record gets loaded but cannot be mutated</li> <li>If the viewer is authenticated, the record gets loaded and be mutated</li> </ul> <pre><code>import { useViewerRecord } from '@self.id/react'\n\nfunction ShowViewerName() {\n  const record = useViewerRecord('basicProfile')\n\n  const text = record.isLoading\n    ? 'Loading...'\n    : record.content\n    ? `Hello ${record.content.name || 'stranger'}`\n    : 'No profile to load'\n  return &lt;p&gt;{text}&lt;/p&gt;\n}\n</code></pre>","title":"Read a viewer record"},{"location":"reference/self-id/modules/react/#read-a-public-record","text":"<p>The <code>usePublicRecord</code> hook is similar to the <code>useViewerRecord</code> hook described above, but reading from the index of an explicitly provided account rather than the viewer. Public records are read-only, <code>useViewerRecord</code> must be used in  case mutations are needed.</p> <pre><code>import { usePublicRecord } from '@self.id/react'\n\nfunction ShowProfileName({ did }) {\n  const record = usePublicRecord('basicProfile', did)\n\n  const text = record.isLoading\n    ? 'Loading...'\n    : record.content\n    ? `Hello ${record.content.name || 'stranger'}`\n    : 'No profile to load'\n  return &lt;p&gt;{text}&lt;/p&gt;\n}\n</code></pre>","title":"Read a public record"},{"location":"reference/self-id/modules/react/#server-side-prefetching","text":"<p>Server-side rendering can be used to improve the user experience for the first load of an app or page. The module exports a <code>RequestClient</code> class that can be used to fetch wanted records on the server in order to have them immediately available by the <code>usePublicRecord</code> and <code>useViewerRecord</code> hooks.</p> <p>The following example shows how this can be used in a Next.js page, using the <code>ShowViewerName</code> component created in the previous example:</p> <pre><code>import { Provider, RequestClient } from '@self.id/react'\n\nexport const getServerSideProps = async (ctx) =&gt; {\n  const client = new RequestClient({\n    ceramic: 'testnet-clay',\n    // Inject the cookie from the request headers to parse the viewerID\n    cookie: ctx.req.headers.cookie,\n  })\n  if (client.viewerID != null) {\n    // If the viewerID is set, fetch its profile\n    await client.prefetch('basicProfile', client.viewerID)\n  }\n  return { props: { state: client.getState() } }\n}\n\n// Use the state prop injected by the server\nexport default function Home({ state }) {\n  return (\n    &lt;Provider state={state}&gt;\n      &lt;ShowViewerName /&gt;\n    &lt;/Provider&gt;\n  )\n}\n</code></pre>","title":"Server-side prefetching"},{"location":"reference/self-id/modules/react/#classes","text":"<ul> <li>RequestClient</li> </ul>","title":"Classes"},{"location":"reference/self-id/modules/react/#type-aliases","text":"","title":"Type aliases"},{"location":"reference/self-id/modules/react/#providerconfig","text":"<p>\u01ac ProviderConfig&lt;<code>ModelTypes</code>&gt;: <code>Object</code></p>","title":"ProviderConfig"},{"location":"reference/self-id/modules/react/#type-parameters","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code> = <code>CoreModelTypes</code>","title":"Type parameters"},{"location":"reference/self-id/modules/react/#type-declaration","text":"Name Type     <code>client?</code> <code>WebClientParams</code>&lt;<code>ModelTypes</code>&gt;   <code>queryOptions?</code> <code>QueryObserverOptions</code>   <code>state?</code> <code>RequestState</code>","title":"Type declaration"},{"location":"reference/self-id/modules/react/#providerprops","text":"<p>\u01ac ProviderProps&lt;<code>ModelTypes</code>&gt;: <code>ProviderConfig</code>&lt;<code>ModelTypes</code>&gt; &amp; { <code>children</code>: <code>ReactNode</code>  }</p>","title":"ProviderProps"},{"location":"reference/self-id/modules/react/#type-parameters_1","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code> = <code>CoreModelTypes</code>","title":"Type parameters"},{"location":"reference/self-id/modules/react/#publicrecord","text":"<p>\u01ac PublicRecord&lt;<code>ContentType</code>&gt;: <code>Object</code></p>","title":"PublicRecord"},{"location":"reference/self-id/modules/react/#type-parameters_2","text":"Name     <code>ContentType</code>","title":"Type parameters"},{"location":"reference/self-id/modules/react/#type-declaration_1","text":"Name Type     <code>content?</code> <code>ContentType</code>   <code>error?</code> <code>unknown</code>   <code>isError</code> <code>boolean</code>   <code>isLoading</code> <code>boolean</code>","title":"Type declaration"},{"location":"reference/self-id/modules/react/#requestclientparams","text":"<p>\u01ac RequestClientParams&lt;<code>ModelTypes</code>&gt;: <code>CoreParams</code>&lt;<code>ModelTypes</code>&gt; &amp; { <code>cookie?</code>: <code>string</code>  }</p>","title":"RequestClientParams"},{"location":"reference/self-id/modules/react/#type-parameters_3","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code> = <code>CoreModelTypes</code>","title":"Type parameters"},{"location":"reference/self-id/modules/react/#requeststate","text":"<p>\u01ac RequestState: <code>Object</code></p>","title":"RequestState"},{"location":"reference/self-id/modules/react/#type-declaration_2","text":"Name Type     <code>hydrate?</code> <code>DehydratedState</code>   <code>viewerID?</code> <code>string</code> | <code>null</code>","title":"Type declaration"},{"location":"reference/self-id/modules/react/#viewerconnectedcontainerprops","text":"<p>\u01ac ViewerConnectedContainerProps: <code>Object</code></p>","title":"ViewerConnectedContainerProps"},{"location":"reference/self-id/modules/react/#type-declaration_3","text":"Name Type     <code>children</code> <code>ReactNode</code>   <code>renderFallback?</code> (<code>connectionState</code>: <code>ViewerConnectionState</code>&lt;<code>ModelTypes</code>&gt;) =&gt; <code>null</code> | <code>Element</code>","title":"Type declaration"},{"location":"reference/self-id/modules/react/#viewerconnectionstate","text":"<p>\u01ac ViewerConnectionState&lt;<code>ModelTypes</code>&gt;: { <code>status</code>: <code>\"idle\"</code>  } | { <code>promise</code>: <code>Abortable</code>&lt;<code>SelfID</code>&lt;<code>ModelTypes</code>&gt; | <code>null</code>&gt; ; <code>provider</code>: <code>EthereumAuthProvider</code> ; <code>status</code>: <code>\"connecting\"</code>  } | { <code>selfID</code>: <code>SelfID</code>&lt;<code>ModelTypes</code>&gt; ; <code>status</code>: <code>\"connected\"</code>  } | { <code>error</code>: <code>Error</code> ; <code>status</code>: <code>\"failed\"</code>  }</p>","title":"ViewerConnectionState"},{"location":"reference/self-id/modules/react/#type-parameters_4","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code> = <code>CoreModelTypes</code>","title":"Type parameters"},{"location":"reference/self-id/modules/react/#viewerid","text":"<p>\u01ac ViewerID&lt;<code>ModelTypes</code>&gt;: <code>PublicID</code>&lt;<code>ModelTypes</code>&gt; | <code>SelfID</code>&lt;<code>ModelTypes</code>&gt;</p>","title":"ViewerID"},{"location":"reference/self-id/modules/react/#type-parameters_5","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code>","title":"Type parameters"},{"location":"reference/self-id/modules/react/#viewerrecord","text":"<p>\u01ac ViewerRecord&lt;<code>ContentType</code>&gt;: { <code>content?</code>: <code>never</code> ; <code>error?</code>: <code>never</code> ; <code>isError</code>: <code>false</code> ; <code>isLoadable</code>: <code>false</code> ; <code>isLoading</code>: <code>false</code> ; <code>isMutable</code>: <code>false</code> ; <code>isMutating</code>: <code>false</code> ; <code>merge?</code>: <code>never</code> ; <code>set?</code>: <code>never</code>  } | { <code>content?</code>: <code>ContentType</code> ; <code>error?</code>: <code>unknown</code> ; <code>isError</code>: <code>boolean</code> ; <code>isLoadable</code>: <code>true</code> ; <code>isLoading</code>: <code>boolean</code> ; <code>isMutable</code>: <code>boolean</code> ; <code>isMutating</code>: <code>boolean</code> ; <code>merge</code>: (<code>content</code>: <code>ContentType</code>) =&gt; <code>Promise</code>&lt;<code>void</code>&gt; ; <code>set</code>: (<code>content</code>: <code>ContentType</code>) =&gt; <code>Promise</code>&lt;<code>void</code>&gt;  }</p>","title":"ViewerRecord"},{"location":"reference/self-id/modules/react/#type-parameters_6","text":"Name     <code>ContentType</code>","title":"Type parameters"},{"location":"reference/self-id/modules/react/#functions","text":"","title":"Functions"},{"location":"reference/self-id/modules/react/#provider","text":"<p>\u25b8 Provider&lt;<code>ModelTypes</code>&gt;(<code>props</code>): <code>JSX.Element</code></p>","title":"Provider"},{"location":"reference/self-id/modules/react/#type-parameters_7","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt; = <code>ModelTypes</code>","title":"Type parameters"},{"location":"reference/self-id/modules/react/#parameters","text":"Name Type     <code>props</code> <code>ProviderProps</code>&lt;<code>ModelTypes</code>&gt;","title":"Parameters"},{"location":"reference/self-id/modules/react/#returns","text":"<p><code>JSX.Element</code></p>","title":"Returns"},{"location":"reference/self-id/modules/react/#viewerconnectedcontainer","text":"<p>\u25b8 ViewerConnectedContainer(<code>props</code>): <code>JSX.Element</code> | <code>null</code></p>","title":"ViewerConnectedContainer"},{"location":"reference/self-id/modules/react/#parameters_1","text":"Name Type     <code>props</code> <code>ViewerConnectedContainerProps</code>","title":"Parameters"},{"location":"reference/self-id/modules/react/#returns_1","text":"<p><code>JSX.Element</code> | <code>null</code></p>","title":"Returns"},{"location":"reference/self-id/modules/react/#getcookieviewerid","text":"<p>\u25b8 getCookieViewerID(<code>cookie?</code>): <code>string</code> | <code>null</code></p>","title":"getCookieViewerID"},{"location":"reference/self-id/modules/react/#parameters_2","text":"Name Type     <code>cookie?</code> <code>string</code>","title":"Parameters"},{"location":"reference/self-id/modules/react/#returns_2","text":"<p><code>string</code> | <code>null</code></p>","title":"Returns"},{"location":"reference/self-id/modules/react/#usecore","text":"<p>\u25b8 useCore&lt;<code>ModelTypes</code>&gt;(): <code>Core</code>&lt;<code>ModelTypes</code>&gt;</p>","title":"useCore"},{"location":"reference/self-id/modules/react/#type-parameters_8","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt; = <code>ModelTypes</code>","title":"Type parameters"},{"location":"reference/self-id/modules/react/#returns_3","text":"<p><code>Core</code>&lt;<code>ModelTypes</code>&gt;</p>","title":"Returns"},{"location":"reference/self-id/modules/react/#usepublicrecord","text":"<p>\u25b8 usePublicRecord&lt;<code>ModelTypes</code>, <code>Alias</code>, <code>ContentType</code>&gt;(<code>alias</code>, <code>id</code>): <code>PublicRecord</code>&lt;<code>ContentType</code> | <code>null</code>&gt;</p>","title":"usePublicRecord"},{"location":"reference/self-id/modules/react/#type-parameters_9","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt; = <code>ModelTypes</code>   <code>Alias</code> extends <code>string</code> | <code>number</code> | <code>symbol</code> = keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]   <code>ContentType</code> <code>DefinitionContentType</code>&lt;<code>ModelTypes</code>, <code>Alias</code>&gt;","title":"Type parameters"},{"location":"reference/self-id/modules/react/#parameters_3","text":"Name Type     <code>alias</code> <code>Alias</code>   <code>id</code> <code>string</code>","title":"Parameters"},{"location":"reference/self-id/modules/react/#returns_4","text":"<p><code>PublicRecord</code>&lt;<code>ContentType</code> | <code>null</code>&gt;</p>","title":"Returns"},{"location":"reference/self-id/modules/react/#useviewerconnection","text":"<p>\u25b8 useViewerConnection&lt;<code>ModelTypes</code>&gt;(): [<code>ViewerConnectionState</code>, (<code>provider</code>: <code>EthereumAuthProvider</code>) =&gt; <code>Promise</code>&lt;<code>SelfID</code>&lt;<code>ModelTypes</code>&gt; | <code>null</code>&gt;, () =&gt; <code>void</code>]</p>","title":"useViewerConnection"},{"location":"reference/self-id/modules/react/#type-parameters_10","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt; = <code>ModelTypes</code>","title":"Type parameters"},{"location":"reference/self-id/modules/react/#returns_5","text":"<p>[<code>ViewerConnectionState</code>, (<code>provider</code>: <code>EthereumAuthProvider</code>) =&gt; <code>Promise</code>&lt;<code>SelfID</code>&lt;<code>ModelTypes</code>&gt; | <code>null</code>&gt;, () =&gt; <code>void</code>]</p>","title":"Returns"},{"location":"reference/self-id/modules/react/#useviewerid","text":"<p>\u25b8 useViewerID&lt;<code>ModelTypes</code>&gt;(): <code>ViewerID</code>&lt;<code>ModelTypes</code>&gt; | <code>null</code></p>","title":"useViewerID"},{"location":"reference/self-id/modules/react/#type-parameters_11","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt; = <code>ModelTypes</code>","title":"Type parameters"},{"location":"reference/self-id/modules/react/#returns_6","text":"<p><code>ViewerID</code>&lt;<code>ModelTypes</code>&gt; | <code>null</code></p>","title":"Returns"},{"location":"reference/self-id/modules/react/#useviewerrecord","text":"<p>\u25b8 useViewerRecord&lt;<code>ModelTypes</code>, <code>Alias</code>, <code>ContentType</code>&gt;(<code>alias</code>): <code>ViewerRecord</code>&lt;<code>ContentType</code> | <code>null</code>&gt;</p>","title":"useViewerRecord"},{"location":"reference/self-id/modules/react/#type-parameters_12","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code>&lt;<code>Record</code>&lt;<code>string</code>, <code>any</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;, <code>Record</code>&lt;<code>string</code>, <code>string</code>&gt;&gt; = <code>ModelTypes</code>   <code>Alias</code> extends <code>string</code> | <code>number</code> | <code>symbol</code> = keyof <code>ModelTypes</code>[<code>\"definitions\"</code>]   <code>ContentType</code> <code>DefinitionContentType</code>&lt;<code>ModelTypes</code>, <code>Alias</code>&gt;","title":"Type parameters"},{"location":"reference/self-id/modules/react/#parameters_4","text":"Name Type     <code>alias</code> <code>Alias</code>","title":"Parameters"},{"location":"reference/self-id/modules/react/#returns_7","text":"<p><code>ViewerRecord</code>&lt;<code>ContentType</code> | <code>null</code>&gt;</p>","title":"Returns"},{"location":"reference/self-id/modules/ui/","text":"<p>React UI theme and components.</p>","title":"Module: ui"},{"location":"reference/self-id/modules/ui/#purpose","text":"<p>This module provides a shared theme and basic components based on the Grommet library. It is used by other modules of the SDK as well as the Self.ID reference application, and can be used by other applications to implement a similar UI.</p>","title":"Purpose"},{"location":"reference/self-id/modules/ui/#installation","text":"<pre><code>npm install @self.id/ui\n</code></pre>","title":"Installation"},{"location":"reference/self-id/modules/ui/#common-use-cases","text":"","title":"Common use-cases"},{"location":"reference/self-id/modules/ui/#configure-the-provider","text":"<p>The <code>Provider</code> component must be added at the root of the application tree in order to use the other component described below.</p> <pre><code>import { Provider } from '@self.id/ui'\n\nfunction App({ children }) {\n  return &lt;Provider&gt;{children}&lt;/Provider&gt;\n}\n</code></pre>","title":"Configure the Provider"},{"location":"reference/self-id/modules/ui/#avatar-placeholder","text":"<p>The <code>AvatarPlaceholder</code> component is based on Boring Avatars and used in the Self.ID application to display a fallback placeholder for profiles without a defined image.</p> <pre><code>import { AvatarPlaceholder } from '@self.id/ui'\n\nexport function Avatar({ did }) {\n  return &lt;AvatarPlaceholder did={did} size={40} /&gt;\n}\n</code></pre>","title":"Avatar placeholder"},{"location":"reference/self-id/modules/ui/#type-aliases","text":"","title":"Type aliases"},{"location":"reference/self-id/modules/ui/#avatarplaceholderprops","text":"<p>\u01ac AvatarPlaceholderProps: <code>Object</code></p>","title":"AvatarPlaceholderProps"},{"location":"reference/self-id/modules/ui/#type-declaration","text":"Name Type     <code>did?</code> <code>string</code> | <code>null</code>   <code>size</code> <code>number</code> | <code>string</code>","title":"Type declaration"},{"location":"reference/self-id/modules/ui/#colortype","text":"<p>\u01ac ColorType: <code>string</code> | { <code>dark?</code>: <code>string</code> ; <code>light?</code>: <code>string</code>  } | <code>undefined</code></p>","title":"ColorType"},{"location":"reference/self-id/modules/ui/#colors","text":"<p>\u01ac Colors: <code>Record</code>&lt;<code>string</code>, <code>ColorType</code>&gt;</p>","title":"Colors"},{"location":"reference/self-id/modules/ui/#providerprops","text":"<p>\u01ac ProviderProps: <code>GrommetExtendedProps</code></p>","title":"ProviderProps"},{"location":"reference/self-id/modules/ui/#variables","text":"","title":"Variables"},{"location":"reference/self-id/modules/ui/#colors_1","text":"<p>\u2022 colors: <code>Colors</code></p>","title":"colors"},{"location":"reference/self-id/modules/ui/#theme","text":"<p>\u2022 theme: <code>ThemeType</code></p>","title":"theme"},{"location":"reference/self-id/modules/ui/#functions","text":"","title":"Functions"},{"location":"reference/self-id/modules/ui/#avatarplaceholder","text":"<p>\u25b8 AvatarPlaceholder(<code>props</code>): <code>JSX.Element</code></p>","title":"AvatarPlaceholder"},{"location":"reference/self-id/modules/ui/#parameters","text":"Name Type     <code>props</code> <code>AvatarPlaceholderProps</code>","title":"Parameters"},{"location":"reference/self-id/modules/ui/#returns","text":"<p><code>JSX.Element</code></p>","title":"Returns"},{"location":"reference/self-id/modules/ui/#provider","text":"<p>\u25b8 Provider(<code>props</code>): <code>JSX.Element</code></p>","title":"Provider"},{"location":"reference/self-id/modules/ui/#parameters_1","text":"Name Type     <code>props</code> <code>GrommetExtendedProps</code>","title":"Parameters"},{"location":"reference/self-id/modules/ui/#returns_1","text":"<p><code>JSX.Element</code></p>","title":"Returns"},{"location":"reference/self-id/modules/web/","text":"<p>Read and write records in browsers environments.</p>","title":"Module: web"},{"location":"reference/self-id/modules/web/#purpose","text":"<p>The <code>web</code> module of the Self.ID SDK exports the <code>WebClient</code> and <code>SelfID</code> classes to provide APIs for authenticating a DID to allow writing records, in addition to reading them.</p> <p>DID authentication leverages 3ID Connect, which only works in browsers, therefore the <code>web</code> module can only be used in browsers. The <code>core</code> module can be used to read public records in browsers as well as Node environments.</p>","title":"Purpose"},{"location":"reference/self-id/modules/web/#installation","text":"<pre><code>npm install @self.id/web\n</code></pre>","title":"Installation"},{"location":"reference/self-id/modules/web/#common-use-cases","text":"","title":"Common use-cases"},{"location":"reference/self-id/modules/web/#authenticate-and-write-a-record","text":"<pre><code>import { EthereumAuthProvider, SelfID } from '@self.id/web'\n\nasync function createSelfID() {\n  // The following assumes there is an injected `window.ethereum` provider\n  const addresses = await window.ethereum.request({ method: 'eth_requestAccounts' })\n\n  return await SelfID.authenticate({\n    authProvider: new EthereumAuthProvider(window.ethereum, addresses[0]),\n    ceramic: 'testnet-clay',\n    // Make sure the `ceramic` and `connectNetwork` parameter connect to the same network\n    connectNetwork: 'testnet-clay',\n  })\n}\n\nasync function setBasicProfile(selfID) {\n  // Use the SelfID instance created by the `createSelfID()` function\n  await selfID.set('basicProfile', { name: 'Alice' })\n}\n</code></pre>","title":"Authenticate and write a record"},{"location":"reference/self-id/modules/web/#re-exported-classes","text":"<ul> <li><code>EthereumAuthProvider</code> from 3ID Connect</li> </ul>","title":"Re-exported classes"},{"location":"reference/self-id/modules/web/#classes","text":"<ul> <li>SelfID</li> <li>WebClient</li> </ul>","title":"Classes"},{"location":"reference/self-id/modules/web/#type-aliases","text":"","title":"Type aliases"},{"location":"reference/self-id/modules/web/#authenticateparams","text":"<p>\u01ac AuthenticateParams&lt;<code>ModelTypes</code>&gt;: <code>WebClientParams</code>&lt;<code>ModelTypes</code>&gt; &amp; { <code>authProvider</code>: <code>EthereumAuthProvider</code>  }</p>","title":"AuthenticateParams"},{"location":"reference/self-id/modules/web/#type-parameters","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code> = <code>CoreModelTypes</code>","title":"Type parameters"},{"location":"reference/self-id/modules/web/#connectnetwork","text":"<p>\u01ac ConnectNetwork: <code>\"dev-unstable\"</code> | <code>\"mainnet\"</code> | <code>\"testnet-clay\"</code></p>","title":"ConnectNetwork"},{"location":"reference/self-id/modules/web/#selfidparams","text":"<p>\u01ac SelfIDParams&lt;<code>ModelTypes</code>&gt;: <code>Object</code></p>","title":"SelfIDParams"},{"location":"reference/self-id/modules/web/#type-parameters_1","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code> = <code>CoreModelTypes</code>","title":"Type parameters"},{"location":"reference/self-id/modules/web/#type-declaration","text":"Name Type     <code>client</code> <code>WebClient</code>&lt;<code>ModelTypes</code>&gt;","title":"Type declaration"},{"location":"reference/self-id/modules/web/#webclientparams","text":"<p>\u01ac WebClientParams&lt;<code>ModelTypes</code>&gt;: <code>CoreParams</code>&lt;<code>ModelTypes</code>&gt; &amp; { <code>connectNetwork?</code>: <code>ConnectNetwork</code>  }</p>","title":"WebClientParams"},{"location":"reference/self-id/modules/web/#type-parameters_2","text":"Name Type     <code>ModelTypes</code> extends <code>ModelTypeAliases</code> = <code>CoreModelTypes</code>","title":"Type parameters"},{"location":"reference/stream-programs/caip10-link/","text":"<p>A CAIP-10 Link is a stream that stores a proof that links a blockchain address to a Ceramic account (DID), using the CAIP-10 standard to represent blockchain addresses.</p> <p>The <code>stream-caip10-link</code> module export a <code>Caip10Link</code> class used to link and unlink a DID to a CAIP-10 address using the CIP-7 \"CAIP-10 Link\" program.</p>","title":"CAIP-10 Link client"},{"location":"reference/stream-programs/caip10-link/#installation","text":"<pre><code>npm install @ceramicnetwork/stream-caip10-link\n</code></pre>","title":"Installation"},{"location":"reference/stream-programs/caip10-link/#additional-requirements","text":"<ul> <li>In order to load CAIP-10 Links, a Ceramic client instance must be available</li> <li>To add/remove links, the client must also have an authenticated DID</li> <li>An authentication provider is needed to sign the payload for the given CAIP-10 account, using the <code>blockchain-utils-linking</code> module that should be installed as needed:</li> </ul> <pre><code>npm install @ceramicnetwork/blockchain-utils-linking\n</code></pre>","title":"Additional requirements"},{"location":"reference/stream-programs/caip10-link/#common-usage","text":"","title":"Common usage"},{"location":"reference/stream-programs/caip10-link/#load-a-link","text":"<p>In this example we load a Caip10Link for the account <code>0x054...7cb8</code> on the Ethereum mainnet blockchain (<code>eip155:1</code>).</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { Caip10Link } from '@ceramicnetwork/stream-caip10-link'\n\nconst ceramic = new CeramicClient()\n\nasync function getLinkedDID() {\n  // Using the Ceramic client instance, we can load the link for a given CAIP-10 account\n  const link = await Caip10Link.fromAccount(\n    ceramic,\n    'eip155:1:0x0544dcf4fce959c6c4f3b7530190cb5e1bd67cb8',\n  )\n  // The `did` property of the loaded link will contain the DID string value if set\n  return link.did\n}\n</code></pre>","title":"Load a link"},{"location":"reference/stream-programs/caip10-link/#create-a-link","text":"<p>Here we can see the full flow of getting a user's Ethereum address, creating a link, and adding the users' DID account.</p> <p>In this example we create a Caip10Link for the account <code>0x054...7cb8</code> on the Ethereum mainnet blockchain (<code>eip155:1</code>) and then associate it with the DID <code>did:3:k2t6...ydki</code>.</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { Caip10Link } from '@ceramicnetwork/stream-caip10-link'\nimport { EthereumAuthProvider } from '@ceramicnetwork/blockchain-utils-linking'\n\nconst ceramic = new CeramicClient()\n\nasync function linkCurrentAddress() {\n  // First, we need to create an EthereumAuthProvider with the account currently selected\n  // The following assumes there is an injected `window.ethereum` provider\n  const addresses = await window.ethereum.request({\n    method: 'eth_requestAccounts',\n  })\n  const authProvider = new EthereumAuthProvider(window.ethereum, addresses[0])\n\n  // Retrieve the CAIP-10 account from the EthereumAuthProvider instance\n  const accountId = await authProvider.accountId()\n\n  // Load the account link based on the account ID\n  const accountLink = await Caip10Link.fromAccount(\n    ceramic,\n    accountId.toString(),\n  )\n\n  // Finally, link the DID to the account using the EthereumAuthProvider instance\n  await accountLink.setDid(\n    'did:3:k2t6wyfsu4pg0t2n4j8ms3s33xsgqjhtto04mvq8w5a2v5xo48idyz38l7ydki',\n    authProvider,\n  )\n}\n</code></pre>","title":"Create a link"},{"location":"reference/stream-programs/caip10-link/#remove-a-link","text":"<p>Removing a link involves a similar flow to setting the DID, but using the <code>clearDid</code> method instead of <code>setDid</code>:</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { Caip10Link } from '@ceramicnetwork/stream-caip10-link'\nimport { EthereumAuthProvider } from '@ceramicnetwork/blockchain-utils-linking'\n\nconst ceramic = new CeramicClient()\n\nasync function unlinkCurrentAddress() {\n  // First, we need to create an EthereumAuthProvider with the account currently selected\n  // The following assumes there is an injected `window.ethereum` provider\n  const addresses = await window.ethereum.request({\n    method: 'eth_requestAccounts',\n  })\n  const authProvider = new EthereumAuthProvider(window.ethereum, addresses[0])\n\n  // Retrieve the CAIP-10 account from the EthereumAuthProvider instance\n  const accountId = await authProvider.accountId()\n\n  // Load the account link based on the account ID\n  const accountLink = await Caip10Link.fromAccount(\n    ceramic,\n    accountId.toString(),\n  )\n\n  // Finally, unlink the DID from the account using the EthereumAuthProvider instance\n  await accountLink.clearDid(authProvider)\n}\n</code></pre>","title":"Remove a link"},{"location":"reference/stream-programs/tile-document/","text":"<p>The <code>stream-tile</code> module exports a <code>TileDocument</code> class used to store and load JSON documents using the CIP-8 \"Tile Document\" streamcode, as well a provide accessors to the contents and metadata of a given version of the stream.</p>","title":"TileDocument client"},{"location":"reference/stream-programs/tile-document/#installation","text":"<pre><code>npm install @ceramicnetwork/stream-tile\n</code></pre>","title":"Installation"},{"location":"reference/stream-programs/tile-document/#additional-requirements","text":"<ul> <li>In order to load Tile documents, a Ceramic client instance must be available</li> <li>To create/update documents, the client must have an authenticated DID</li> </ul>","title":"Additional requirements"},{"location":"reference/stream-programs/tile-document/#common-usage","text":"","title":"Common usage"},{"location":"reference/stream-programs/tile-document/#load-a-document","text":"<pre><code>// Import the Ceramic and Tile document clients\nimport { CeramicClient } from '@ceramicnetwork/http-client'\nimport { TileDocument } from '@ceramicnetwork/stream-tile'\n\n// Connect to a Ceramic node\nconst ceramic = new CeramicClient()\n\n// The `id` argument can be a stream ID (to load the latest version)\n// or a commit ID (to load a specific version)\nasync function load(id) {\n  return await TileDocument.load(ceramic, id)\n}\n</code></pre>","title":"Load a document"},{"location":"reference/stream-programs/tile-document/#create-a-document","text":"<p>In order to create a document, an authenticated DID needs to be attached to the Ceramic client instance to enable transactions (signing commits).</p> <p>The following example uses the ed25519 Key DID provider for simplicity, but creating documents can be done using any supported DID provider.</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { TileDocument } from '@ceramicnetwork/stream-tile'\nimport { DID } from 'dids'\nimport { Ed25519Provider } from 'key-did-provider-ed25519'\nimport { getResolver } from 'key-did-resolver'\n\nconst ceramic = new CeramicClient()\n\n// `seed` must be a 32-byte long Uint8Array\nasync function authenticateCeramic(seed) {\n  const provider = new Ed25519Provider(seed)\n  const did = new DID({ provider, resolver: getResolver() })\n  // Authenticate the DID with the provider\n  await did.authenticate()\n  // The Ceramic client can create and update streams using the authenticated DID\n  ceramic.did = did\n}\n\nasync function createDocument(content) {\n  // The following call will fail if the Ceramic instance does not have an authenticated DID\n  const doc = await TileDocument.create(ceramic, content)\n  // The stream ID of the created document can then be accessed as the `id` property\n  return doc.id\n}\n</code></pre> <p>In addition to the stream <code>content</code>, the following <code>metadata</code> can be set</p>","title":"Create a document"},{"location":"reference/stream-programs/tile-document/#update-a-document","text":"<p>In order to update a document, an authenticated DID needs to be attached to the Ceramic client instance to enable transactions (signing commits).</p> <p>The following example uses the ed25519 Key DID provider for simplicity, but creating documents can be done using any supported DID provider.</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { TileDocument } from '@ceramicnetwork/stream-tile'\nimport { DID } from 'dids'\nimport { Ed25519Provider } from 'key-did-provider-ed25519'\nimport { getResolver } from 'key-did-resolver'\n\nconst ceramic = new CeramicClient()\n\n// `seed` must be a 32-byte long Uint8Array\nasync function authenticateCeramic(seed) {\n  const provider = new Ed25519Provider(seed)\n  const did = new DID({ provider, resolver: getResolver() })\n  // Authenticate the DID with the provider\n  await did.authenticate()\n  // The Ceramic client can create and update streams using the authenticated DID\n  ceramic.did = did\n}\n\nasync function updateDocument(id, content) {\n  // First, we need to load the document\n  const doc = await TileDocument.load(id)\n  // The following call will fail if the Ceramic instance does not have an authenticated DID\n  await doc.update(content)\n}\n</code></pre>","title":"Update a document"},{"location":"reference/stream-programs/tile-document/#use-json-schema-validation","text":"<p>Ceramic nodes support validation of documents using JSON schemas. In order for a document to get validated, a Tile document containing the contents of the JSON schema must be created on the node and referenced in metadata.</p> <p>In this example, we use the <code>commitID</code> of the created schema document rather than the stream ID in order to get an immutable reference to the specific version on the schema. This is particularly useful when using schemas that are controlled by external entities, as using the latest version of the schema (using a stream ID as reference) could lead to breaking changes. For example, the schema document could be updated such as <code>name</code> would be replaced by <code>firstName</code> and <code>lastName</code>, but apps having logic implementing setting the <code>name</code> would no longer pass validation. By using the <code>commitID</code> of the schema document, apps are guaranteed that documents will be validated against this exact version of the schema.</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { TileDocument } from '@ceramicnetwork/stream-tile'\nimport { DID } from 'dids'\nimport { Ed25519Provider } from 'key-did-provider-ed25519'\nimport { getResolver } from 'key-did-resolver'\n\nconst ceramic = new CeramicClient()\n\n// `seed` must be a 32-byte long Uint8Array\nasync function authenticateCeramic(seed) {\n  const provider = new Ed25519Provider(seed)\n  const did = new DID({ provider, resolver: getResolver() })\n  // Authenticate the DID with the provider\n  await did.authenticate()\n  // The Ceramic client can create and update streams using the authenticated DID\n  ceramic.did = did\n}\n\n// This function will create the schema document and return the commit ID of the schema,\n// providing an immutable reference to the created version of the schema\nasync function createSchemaDocument() {\n  // The following call will fail if the Ceramic instance does not have an authenticated DID\n  const doc = await TileDocument.create(ceramic, {\n    $schema: 'http://json-schema.org/draft-07/schema#',\n    title: 'MySchema',\n    type: 'object',\n    properties: {\n      name: {\n        type: 'string',\n        maxLength: 150,\n      },\n    },\n    required: ['name'],\n  })\n  // The stream ID of the created document can then be accessed as the `id` property\n  return doc.commitId\n}\n\nasync function createDocument(content, schema) {\n  // The following call will fail if the Ceramic instance does not have an authenticated DID\n  const doc = await TileDocument.create(ceramic, content, { schema })\n  // The stream ID of the created document can then be accessed as the `id` property\n  return doc.id\n}\n\n// The following example flow creates the schema and the document using the schema with the same\n// DID, in practice it is likely the schemas are created by developers earlier in the development\n// flow and the commit IDs of the schemas are referenced by applications at runtime\nasync function run(seed) {\n  await authenticateCeramic(seed)\n  const schemaID = await createSchemaDocument()\n  const docID = await createDocument({ name: 'Alice' }, schemaID)\n}\n</code></pre>","title":"Use JSON schema validation"},{"location":"reference/stream-programs/tile-document/#access-a-deterministic-document","text":"<p>Related standard</p> <p>The CIP-11 \"Identity Index\" (IDX) standard leverages deterministic documents to associate records to a DID and is implemented by the DID DataStore library.</p>  <p>Ceramic allows the creation and load of documents based on their metadata. This is useful to identify documents based on their controller and family or tags rather than having to know their stream IDs.</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { TileDocument } from '@ceramicnetwork/stream-tile'\nimport { DID } from 'dids'\nimport { Ed25519Provider } from 'key-did-provider-ed25519'\nimport { getResolver } from 'key-did-resolver'\n\nconst ceramic = new CeramicClient()\n\n// `seed` must be a 32-byte long Uint8Array\nasync function authenticateCeramic(seed) {\n  const provider = new Ed25519Provider(seed)\n  const did = new DID({ provider, resolver: getResolver() })\n  // Authenticate the DID with the provider\n  await did.authenticate()\n  // The Ceramic client can create and update streams using the authenticated DID\n  ceramic.did = did\n}\n\n// Load (or create) a determinitic document for a given controller\nasync function loadDocumentByController(controller) {\n  return await TileDocument.deterministic(ceramic, {\n    // A single controller must be provided to reference a deterministic document\n    controllers: [controller],\n    // A family or tag must be provided in addition to the controller\n    family: 'myFamily',\n    tags: ['foo'],\n  })\n}\n\n// The following flow authenticates a DID based on the provided seed and create a deterministic\n// document associated to it\nasync function setMyDocument(seed) {\n  await authenticateCeramic(seed)\n  // Load the document controlled the authenticated DID\n  const doc = await loadDocumentByController(ceramic.did.id)\n  // The document has no content as it's created based on metadata only...\n  if (doc.content == null) {\n    // ... but it can be updated by its controller to set content like any other document\n    await doc.update({ hello: 'world' })\n  }\n}\n</code></pre>","title":"Access a deterministic document"},{"location":"run/","text":"<p>Ceramic node operators are responsible for hosting the various Ceramic networks. Ceramic clients need to connect to nodes in order to access the network.</p>","title":"Run nodes"},{"location":"run/#who-needs-to-run-a-node","text":"<p>Applications developers can get started building by launching a local node or by connecting their clients to one of the nodes hosted by community members, but before moving to production you will need to run a node for your application.</p>  <p>We're working with commercial node provides to offer production Ceramic nodes-as-a-service. We will update this page as those become available.</p>","title":"Who needs to run a node?"},{"location":"run/#launching-a-node","text":"","title":"Launching a node"},{"location":"run/#run-ceramic-locally","text":"<p>Set up a local Ceramic node for development and testing purposes.</p>","title":"Run Ceramic locally \u2192"},{"location":"run/#run-ceramic-in-the-cloud","text":"<p>Run a reliable, performant, highly-available Ceramic node in the cloud for use by production applications.</p>","title":"Run Ceramic in the cloud \u2192"},{"location":"run/cas/cas/","text":"<p>This guide describes how to spin up and run a hosted Ceramic Anchor Service (CAS) in JavaScript that generates anchor commits for streams in batches. You can find the JavaScript CAS implementation here.</p>  <p>It is currently not possible to run your own CAS. By default, every Ceramic node automatically uses a free community-operated CAS. You do not need any additional setup. In the future, nodes will be able to specify which CAS they use. Once that is enabled, documentation will be added to this page.</p>","title":"Hosting an anchor service"},{"location":"run/cas/community-cas/","text":"<p>This page contains a list of free Ceramic Anchor Services (CAS) hosted by 3Box Labs and made available for the community. The CAS referenced below are hardcoded into every Ceramic node and will be automatically used depending on the node's network configuration; no additional setup is needed.</p> <p>At this time it is not possible to run your own CAS, however this functionality will be available in the near future.</p>","title":"Community CAS"},{"location":"run/cas/community-cas/#mainnet-cas","text":"<p>Nodes connected to Mainnet will automatically use this CAS which generates anchor commits using the Ethereum Mainnet blockchain (<code>eip155:1</code>) and communicates over the <code>/ceramic/mainnet</code> libp2p topic.</p>  <p>Mainnet usage is currently restricted to projects in the Early Launch program (ELP). Sign up for the ELP waitlist here.</p>  <p>ETH Mainnet Address:</p> <pre><code>0xaf65E45F4C0BD388F91EeB23cFCd52F4fCdd6Ee2\n</code></pre> <p>To view Mainnet CAS transactions, see Etherscan.</p>","title":"Mainnet CAS"},{"location":"run/cas/community-cas/#clay-testnet-cas","text":"<p>Nodes connected to Clay Testnet will automatically use this CAS which generates anchor commits using the Ethereum Ropsten blockchain and communicates over the <code>/ceramic/testnet-clay</code> libp2p topic.</p> <p>ETH Ropsten Address:</p> <pre><code>0x1C124c86f7fc22e67974337E889a513b16a5703f\n</code></pre> <p>To view Clay Testnet CAS transactions, see Etherscan.</p>","title":"Clay Testnet CAS"},{"location":"run/cas/community-cas/#dev-unstable-cas","text":"<p>Nodes connected to the Dev Unstable network will use this CAS which generates anchor commits using the Ethereum Rinkeby blockchain and communicates over the <code>/ceramic/dev-unstable</code> libp2p topic.</p> <p>ETH Rinkeby Address:</p> <pre><code>0x41Ee0C359D95970A83229D8e9801cc2672390217\n</code></pre> <p>To view Dev Unstable CAS transactions, see Etherscan.</p>","title":"Dev Unstable CAS"},{"location":"run/nodes/available/","text":"<p>To build an application on Ceramic, you don't necessarily have to run your own node. The community provides a set of nodes that can be used for application testing and development. These nodes are periodically wiped, so don't depend on them for long-term data availability.</p>    Network Implementation Mode URL Host     Mainnet JS Ceramic Read-only https://gateway.ceramic.network 3Box Labs   Clay testnet JS Ceramic Read-only https://gateway-clay.ceramic.network 3Box Labs   Clay testnet JS Ceramic Read/Write https://ceramic-clay.3boxlabs.com 3Box Labs     <p>At the moment, all mainnet applications that wish to perform write transactions must run their own mainnet node. The community is working with commercial infrastructure providers to offer managed Ceramic nodes as a service. We will update this page when those become available.</p>","title":"Available Ceramic nodes"},{"location":"run/nodes/community-nodes/","text":"<p>This page contains a list of free, hosted Ceramic nodes made available by the community for the purposes of easily developing applications using the JS HTTP Client or the CLI.</p>  <p>Warning: These nodes will be periodically wiped and streams may disappear, so please don't rely on them for long-term persistence and availability of data. If you need longer-term persistence, consider hosting your own node. Also note that streams created on the Clay Testnet will not be accessible on Mainnet. Only use Mainnet nodes for production deployments.</p>","title":"Community Nodes"},{"location":"run/nodes/community-nodes/#gateways","text":"<p>Gateways are nodes that provide read-only access to the Ceramic network. 3Box Labs provides free gateway nodes for use by the Ceramic community. Here is a list of their HTTP endpoints:</p>","title":"Gateways"},{"location":"run/nodes/community-nodes/#mainnet","text":"<pre><code>https://gateway.ceramic.network\n</code></pre>","title":"Mainnet"},{"location":"run/nodes/community-nodes/#clay-testnet","text":"<pre><code>https://gateway-clay.ceramic.network\n</code></pre>","title":"Clay testnet"},{"location":"run/nodes/community-nodes/#writeread-nodes","text":"<p>Nodes provide full read and write access to the Ceramic network. 3Box Labs provides free write/read nodes for Ceramic developers. These nodes will run the latest release candidate of the Ceramic protocol. Here is a list of their HTTP endpoints:</p>","title":"Write/Read Nodes"},{"location":"run/nodes/community-nodes/#clay-testnet_1","text":"<pre><code>https://ceramic-clay.3boxlabs.com\n</code></pre>","title":"Clay testnet"},{"location":"run/nodes/node-providers/","text":"<p>This page will list third-party node hosting services that offer commercial-grade Ceramic nodes for developers - this is in process for fall 2021. If you're interested in a list of free nodes, see Community Nodes.</p>","title":"Node Providers"},{"location":"run/nodes/node-providers/#providers","text":"<p>If you're interested in being among the first to offer commercial-grade nodes for Ceramic developers and applications, please get in touch on Discord.</p>","title":"Providers"},{"location":"run/nodes/nodes/","text":"<p>This guide provide complete instructions and various tools for launching a highly-available, well-connected Ceramic node in the cloud.</p>","title":"Launching Ceramic in the cloud"},{"location":"run/nodes/nodes/#who-should-run-ceramic-in-the-cloud","text":"<p>At this time, any application that wishes to deploy to mainnet needs to run their own node. Additionally, developers building on testnet may wish to run their own node so they don't need to rely on community-hosted nodes which may be unstable and/or wipe data from time to time.</p>","title":"Who should run Ceramic in the cloud?"},{"location":"run/nodes/nodes/#things-to-know","text":"<p>Ceramic networks \u2013 There are currently three Ceramic networks: <code>mainnet</code>, <code>testnet-clay</code>, and <code>dev-unstable</code>. Learn more about each network here. By default, Ceramic will connect to the Clay testnet and a Ceramic Anchor Service running on Ethereum Ropsten. When you are ready to get on Ceramic mainnet, reach out on the Ceramic Discord \u2192. For now, mainnet is limited to early partners and we will need to test your connectivity before granting you access.</p> <p>Running IPFS \u2013 Ceramic relies on the IPFS interplanetary file system. By default, Ceramic includes an internal IPFS instance. You can run Ceramic and IPFS in this single process or in separate processes that communicate over HTTP. For production, it is recommended to run as separate processes for better scalability, resource utilization, control, debugging, and observability.</p> <p>DagJose codec \u2013 When using an IPFS node running separately from Ceramic, this IPFS node needs to support the <code>dagJose</code> codec, which is not included in IPFS by default. You should use the @ceramicnetwork/ipfs-daemon, package which includes <code>js-ipfs</code> configured with dagJose support. Config options for the IPFS daemon can be viewed in the ipfs-daemon README and in the ipfs-daemon source code.</p> <p>Restarts and maintaining data persistence and connectivity \u2013 Ceramic and IPFS will not automatically restart if they crash. You should configure your own restart mechanism and you must ensure data persistence between restarts. If the IPFS multiaddress changes for any reason (your node goes down or restarts without pulling in an existing config file), your node will regenerate this file upon restarting with a new address and all other nodes on the network will lose connection to you.</p>","title":"Things to know"},{"location":"run/nodes/nodes/#quick-start","text":"","title":"Quick start"},{"location":"run/nodes/nodes/#run-ceramic-on-aws-ecs-with-terraform","text":"<p>The 3Box Labs team has written a Terraform module that configures Ceramic and IPFS in AWS ECS. This module is currently the fastest way to run Ceramic in the cloud. It runs Ceramic and IPFS separately in containers using Docker images. This module currently requires some common AWS resources to be pre-configured as well as Cloudflare. You can see an example of the module in use.</p>  <p>We highly encourage others to create Terraform modules for other infrastructure providers and using different platforms.</p>","title":"Run Ceramic on AWS ECS with Terraform \u2192"},{"location":"run/nodes/nodes/#required-steps","text":"<p>Below are the steps required for running a Ceramic node in the cloud. This guide will teach you how to:</p> <ol> <li>Install and run the Ceramic daemon</li> <li>Configure data persistence</li> <li>Stay connected to the network</li> <li>Get observability data from your node</li> </ol>","title":"Required steps"},{"location":"run/nodes/nodes/#running-the-daemon","text":"<p>The JS Ceramic node is run as a daemon using Docker or Node.js, It can be configured with a JSON file which is created on start and located at <code>$HOME/.ceramic/daemon.config.json</code>. Configuration options can be viewed in the reference documentation for the DaemonConfig class.</p>","title":"Running the daemon"},{"location":"run/nodes/nodes/#install-from-dockerhub","text":"<p>The JS Ceramic repo builds Docker images that run the Ceramic daemon and IPFS from the source code of the master branch. These images are tagged with <code>latest</code> and the git commit hash of the source code that the image was built from. You can view the image builds of js-ceramic on DockerHub and compatible builds of ipfs-daemon on DockerHub.</p> <pre><code>docker pull ceramicnetwork/ipfs-daemon:latest\n\ndocker run -d -p 4011:4011 -p 5011:5011 -e CERAMIC_NETWORK=mainnet --name ipfs-daemon ceramicnetwork/ipfs-daemon:latest\n\n# Get the IP address\ndocker inspect -f \\\n  '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' \\\n  ipfs-daemon\n\ndocker pull ceramicnetwork/js-ceramic:latest\n</code></pre> <p>Next launch the daemons:</p> <pre><code>docker run -d \\\n-p 7007:7007 \\\n-v /path_for_daemon_config:/root/.ceramic/daemon.config.json \\\n-v /path_for_ceramic_logs:/root/.ceramic/logs \\\n-v /path_for_ceramic_statestore:/root/.ceramic/statestore \\\n--name js-ceramic \\\nceramicnetwork/js-ceramic:latest\n</code></pre> <p>Then, configure your setup using a JSON file. See example daemon.config.json below.</p>","title":"Install from DockerHub"},{"location":"run/nodes/nodes/#install-from-npm","text":"<p>The JS Ceramic CLI and ipfs-daemon are available as npm modules. They are currently compatible with Node.js version 14. After a global installation, the daemons can be run from the command line:</p> <pre><code>npm install -g @ceramicnetwork/ipfs-daemon\nexport CERAMIC_NETWORK=mainnet # Set the Ceramic network for the IPFS node\nipfs-daemon\n\n# In a new shell, configure Ceramic to use IPFS\n\nnpm install -g @ceramicnetwork/cli\n</code></pre> <p>Next launch the daemons:</p> <pre><code>ceramic daemon\n</code></pre> <p>Then, configure your setup using a JSON file. See example daemon.config.json below.</p>","title":"Install from npm"},{"location":"run/nodes/nodes/#example-daemonconfigjson","text":"<pre><code>{\n  \"anchor\": {\n    \"ethereum-rpc-url\": \"https://eg_infura_endpoint\" // Replace with an Ethereum RPC endpoint to avoid rate limiting\n  },\n  \"http-api\": {\n    \"cors-allowed-origins\": [\".*\"]\n  },\n  \"ipfs\": {\n    \"mode\": \"remote\", // Use \"remote\" for IPFS out-of-process or \"bundled\" for in-process\n    \"host\": \"http://ipfs_ip_address:5011\"\n  },\n  \"logger\": {\n    \"log-level\": 2, // 0 is most verbose\n    \"log-to-files\": true\n  },\n  \"network\": {\n    \"name\": \"mainnet\" // Connect to mainnet, testnet-clay, or dev-unstable\n  },\n  \"node\": {},\n  \"state-store\": {\n    \"mode\": \"fs\",\n    \"local-directory\": \"/path_for_ceramic_statestore\" // Defaults to $HOME/.ceramic/statestore\n  }\n}\n</code></pre>","title":"Example daemon.config.json"},{"location":"run/nodes/nodes/#configure-data-persistence","text":"<p>When running a Ceramic node in production, it is critical to persist the IPFS multiaddress for network connectivity, the IPFS repo, and the Ceramic state store for data persistence since there is no guarantee another node is also keeping your data available. Loss of this data can result in permanent loss of Ceramic streams and will cause your node to be in a corrupt state.</p>  <p>Data persistence is the most critical step to properly running a Ceramic node. The form of storage you choose should be configured for disaster recovery with data redundancy, some form of snapshotting, and/or backups.</p>  <p>The IPFS repo and the Ceramic state store are stored on your machine's filesystem by default. The IPFS repo defaults to a directory called <code>ipfs</code> located wherever you run the <code>ipfs-daemon</code> process (or where you run the<code>ceramic daemon</code> process if keeping Ceramic and IPFS bundled, which isn't recommended). The Ceramic state store defaults to <code>~/.ceramic/statestore</code>.</p> <p>The fastest way to ensure data persistence is by mounting a persistent volume to your instances and configuring the Ceramic and IPFS nodes to write to the mount location. The mounted volume should be configured such that the data persists if the instance shuts down.</p> <p>You can also use AWS S3 for data storage which is supported for both Ceramic and IPFS. Below are examples of the configuration for both storage options.</p>","title":"Configure data persistence"},{"location":"run/nodes/nodes/#persisting-ipfs-data","text":"<p>The IPFS repo holds configuration settings and all the raw IPFS data for the Ceramic streams used by your node. It is essential to keep the file names <code>config</code> generated by IPFS so that your node can stay connected to the Ceramic network. This file is located at the root of the IPFS repo directory.</p>  <p>The IPFS config file holds your node's private key which is used to generate your node's peerId and multiaddress. If this file is deleted it will be re-created on start with a different key, peerId and multiaddress. This will result in your node and the rest of the network not being able to connect to each other.</p>   <p>Environment variables should be written to your profile file, or otherwise injected into your environment on start so that they persist between reboots.</p>  Volume storageAWS S3   <pre><code># Environment variable to use a mounted volume for IPFS persistence\nexport IPFS_PATH=\"/mnt_volume_path_for_ipfs\"\n</code></pre>   <pre><code># Environment variables to use S3 for IPFS persistence\nexport IPFS_S3_REPO_ENABLED=\"true\"\nexport IPFS_PATH=\"directory_for_the_bucket\"\nexport AWS_BUCKET_NAME=\"bucket_name\"\nexport AWS_ACCESS_KEY_ID=\"aws_access_key_id\"\nexport AWS_SECRET_ACCESS_KEY=\"aws_secret_access_key\"\nexport IPFS_BACKEND_ROOT=\"s3\"\nexport IPFS_BACKEND_BLOCKS=\"s3\"\nexport IPFS_BACKEND_KEYS=\"s3\"\nexport IPFS_BACKEND_PINS=\"s3\"\nexport IPFS_BACKEND_DATASTORE=\"s3\"\n</code></pre> <pre><code>// IPFS AWS S3 policy for the access key\n{\n\"Version\": \"2012-10-17\",\n\"Statement\": [\n    {\n    \"Action\": [\n        \"s3:GetObject\",\n        \"s3:ListBucket\",\n        \"s3:PutObject\",\n        \"s3:DeleteObject\"\n    ],\n    \"Effect\": \"Allow\",\n    \"Resource\": [\"ipfs_bucket_arn\", \"ipfs_bucket_arn/*\"]\n    }\n]\n}\n</code></pre>","title":"Persisting IPFS data"},{"location":"run/nodes/nodes/#persisting-the-ceramic-state-store","text":"<p>The Ceramic state store holds commits for pinned streams and the acts as a cache for the Ceramic streams that your node creates or loads. To ensure that the data you create with your Ceramic node does not get lost you must pin streams you care about and you must ensure that the state store does not get deleted.</p> Volume storageAWS S3   <p>Using <code>daemon.config.json</code></p> <pre><code>    \"state-store\": {\n        \"mode\": \"fs\",\n        \"local-directory\": \"/mnt_volume_path_for_statestore\",\n    },\n</code></pre>   <p>Using <code>daemon.config.json</code></p> <pre><code>    \"state-store\": {\n        \"mode\": \"s3\",\n        \"s3-bucket\": \"bucket_name\"\n    },\n</code></pre> <p>Ceramic state store AWS S3 policy for the access key</p> <pre><code>{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n    {\n    \"Action\": [\n        \"s3:ListBucket\",\n        \"s3:GetObject\",\n        \"s3:PutObject\",\n        \"s3:DeleteObject\"\n    ],\n    \"Effect\": \"Allow\",\n    \"Resource\": [\"state_store_bucket_arn\", \"state_store_bucket_arn/*\"]\n    }\n]\n}\n</code></pre>","title":"Persisting the Ceramic State Store"},{"location":"run/nodes/nodes/#stay-connected-to-the-network","text":"","title":"Stay connected to the network"},{"location":"run/nodes/nodes/#staying-connected-to-ceramic","text":"<p>The Ceramic daemon serves an HTTP API that clients use to interact with your Ceramic node. The default API port is <code>7007</code>. Make sure this port is available to all clients you plan to use for your application.</p>  <p>Healthchecks can be run against the API endpoint <code>/api/v0/node/healthcheck</code>.</p>","title":"Staying connected to Ceramic"},{"location":"run/nodes/nodes/#staying-connected-to-ipfs","text":"<p>Ceramic nodes rely on IPFS for networking. IPFS nodes connect to each other using a Libp2p module called \"switch\" (aka \"swarm\"). This module operates over a websocket, on port <code>4011</code> by default. The websocket port must be accessible to the internet so your Ceramic node can be connected to the network.</p>  <p>We recommend using SSL for a secure websocket (port <code>4012</code> by default).</p>   <p>Healthchecks can be run against the <code>HEALTHCHECK_PORT</code> (port <code>8011</code> by default) when <code>HEALTHCHECK_ENABLED</code> is <code>true</code>.</p>  <p>Additionally when running IPFS separately from Ceramic, the IPFS API port must be accessible by the Ceramic node. The default API port is <code>5011</code>. The IPFS node address will then be passed to Ceramic with a CLI flag <code>--ipfs-api &lt;ipfs_api_url&gt;</code>.</p>","title":"Staying connected to IPFS"},{"location":"run/nodes/nodes/#join-the-peerlist","text":"<p>The <code>ipfs-daemon</code> package used by Ceramic has IPFS's node discovery mechanism, the Libp2p DHT, turned off by default. With node discovery turned off, we must manually create a connected network of peers by sharing known addresses and dialing them explicitly. The <code>ipfs-daemon</code> package handles this logic and requires that every node that wants to be in the network be in a \"peerlist\" which is maintained here.</p> <p>Once you have fully configured your Ceramic node with this guide and have a way to persist its configuration and state, submit a pull request to the Ceramic peerlist with the persistent multiaddress of your IPFS node, the IP address for your Ceramic node, and a brief description of the data persistence setup for the multiaddress, Ceramic State Store, and IPFS Repo. When a pull request is submitted, it triggers a connectivity test to ensure the node can successfully connect to the network. If this fails, the 3Box Labs team will reach out to you directly to triage the issue. Make sure there are no firewalls blocking your instance and that your port is properly exposed. Once your pull request is merged, you will be connected to the Ceramic network and the Ceramic Anchor Service.</p>  <p>Mainnet nodes will not run immediately after start up until your IP address is added to the allow list for the anchor service hosted by 3Box Labs and your PR to the peerlist is merged.</p>  <p>Once you are on the peerlist, you should monitor your IPFS node and alert our team on Discord in the case of any planned or unexpected downtime. Please make your best effort to come back online within 24 hours. If we can not connect to your IPFS node for over 24 hours, we will remove it from the peerlist and you can resubmit your multiaddress in a new PR once your node becomes stable again. If the connectivity test in your PR to the peerlist fails and it is due to a node other than your own, we will update the peerlist and re-run the tests for you.</p>","title":"Join the peerlist"},{"location":"run/nodes/nodes/#observability","text":"<p>Ceramic has a debug mode that you can enable using the <code>--debug</code> flag. This will allow you to see all logs printed to your console, including debug logs, API requests, events, and errors.</p> <p>For observability, it is best to have these logs written to files to debug any issues and to generate metrics. Logging to files can be enabled with the <code>--log-to-files</code> flag. The default location for logs is <code>~/.ceramic/logs</code> but this path can be configured with the <code>--log-directory</code> flag. Without debug mode enabled you will still get critical logs and metrics written to files.</p> <p>Request and event logs are written in logfmt. This makes them easy to import into Grafana dashboards using a log scraping agent like Promtail and a log aggregator like Loki, which can be used as a data source for Grafana. An example of such a setup can be found here.</p>","title":"Observability"},{"location":"run/nodes/nodes/#next-steps","text":"<p>Congratulations! You have now set up a highly-available, well-connected Ceramic node in the cloud which can receive HTTP requests from the local environment, the JS HTTP Client, or to simply serve as another node to replicate and pin streams. Please report any bugs as issues on the JS Ceramic GitHub.</p>","title":"Next steps"},{"location":"tools/overview/","text":"<p>Various tools such as libraries, CLIs and services are created on top of Ceramic to provide abstractions and specific solutions to some common use-cases.</p>","title":"Tools"},{"location":"tools/overview/#glaze","text":"<p>The Glaze umbrella includes projects providing low-level solutions on top of Ceramic. Each project focuses on a specific scope, using a restricted number of dependencies on top of Ceramic.</p> <p>Glaze overview</p>","title":"Glaze"},{"location":"tools/overview/#selfid","text":"<p>Self.ID is both a reference application and a SDK providing higher-level abstractions to create user-centric Web applications. It leverages Glaze projects and 3ID Connect to offer a simple way to help Web developers get started with the Ceramic ecosystem.</p> <p>Self.ID overview</p>","title":"Self.ID"},{"location":"tools/overview/#identitylink","text":"<p>IdentityLink is a service that issues verifiable claims which prove that a DID owns one or more Web2 social accounts.</p> <p>IdentityLink overview</p>","title":"IdentityLink"},{"location":"tools/glaze/datamodel/","text":"<p>The Glaze DataModel library provides human-readable name aliasing for data models, making it easier to refer to and use data models with the DID DataStore API, and other places within your Ceramic application.</p>","title":"Aliasing data models"},{"location":"tools/glaze/datamodel/#how-it-works","text":"<p>The Glaze DataModel library requires an instance of Ceramic and a preexisting <code>publishedModel</code> object, which can be created during development using either the Glaze CLI or the Glaze DevTools library.</p> <p>The primary purpose of the DataModel library is to create a new <code>PublishedModel</code> object which contains human-friendly aliases for your data models that can be used at runtime to simplify development. This <code>PublishedModel</code> is defined by the following type:</p> <pre><code>type PublishedModel = {\n  schemas: Record&lt;string, string&gt;\n  definitions: Record&lt;string, string&gt;\n  tiles: Record&lt;string, string&gt;\n}\n</code></pre> <p>In this object, the key of each record is your alias and the value is a reference to a stream, which for schemas is a commitURL and for definitions and other related tiles is a streamID.</p>","title":"How it works"},{"location":"tools/glaze/datamodel/#getting-started-with-glaze-datamodel","text":"<p>Visit the Glaze DataModel reference \u2192 documentation for full instructions on how to install, configure, and use the module in your application. For convenience, here's a look at what's possible with the Glaze DataModel:</p>","title":"Getting started with Glaze DataModel"},{"location":"tools/glaze/datamodel/#installation","text":"<pre><code>npm install @glazed/datamodel\n</code></pre>","title":"Installation"},{"location":"tools/glaze/datamodel/#usage","text":"<p>After you have a <code>PublishedModel</code> object from the Glaze CLI or the DevTools library, the main purpose of the Glaze DataModel library is to abstract away the underlying machine-readable names of your schemas and data model definitions into something human-readable that simplifies application development:</p> <pre><code>import { DataModel } from '@glazed/datamodel'\n\nconst publishedModel = {\n  schemas: {\n    MySchema: 'ceramic://mySchemaURL',\n  },\n  definitions: {\n    myDefinition: 'myDefinitionID',\n  },\n  tiles: {},\n}\n\nconst model = new DataModel({ ceramic, model: publishedModel })\n\nmodel.getSchemaURL('MySchema') // 'ceramic://mySchemaURL'\n</code></pre>","title":"Usage"},{"location":"tools/glaze/datamodel/#next-steps-storing-and-retrieving-data","text":"<p>Your human-readable data model aliases can now be used with the DID DataStore module provided by Glaze suite, which is also included in the Self.ID SDK, to store and retrieve data from these data models.</p>","title":"Next steps: Storing and retrieving data"},{"location":"tools/glaze/deploy-from-cli/","text":"<p>The Glaze CLI provide commands for common interactions with data models to help support your development workflow.</p>  <p>The Glaze CLI is useful for basic data model management. For managing multiple models or more complex models, we recommend using the Glaze DevTools library.</p>","title":"Deploying data models with the Glaze CLI"},{"location":"tools/glaze/deploy-from-cli/#getting-started-with-the-glaze-cli","text":"","title":"Getting started with the Glaze CLI"},{"location":"tools/glaze/deploy-from-cli/#installation","text":"<pre><code>npm install --global @glazed/cli\n</code></pre> <p>The CLI is then accessible as <code>glaze</code>.</p>","title":"Installation"},{"location":"tools/glaze/deploy-from-cli/#usage","text":"<p>Run <code>glaze help</code> to list the available commands. The commands for some common flows are described below.</p>","title":"Usage"},{"location":"tools/glaze/deploy-from-cli/#set-up-your-developer-account","text":"<p>In order to create streams that store the schemas and definitions for our data models, you'll need to use a Key DID account. If you don't already have one, you can use the <code>did:create</code> command. It will output a random hexademical <code>seed</code> that can be used as the <code>DID_KEY</code> environment variable or as the <code>--key</code> flag in the following commands.</p> <pre><code>glaze did:create\n</code></pre>","title":"Set up your developer account"},{"location":"tools/glaze/deploy-from-cli/#creating-data-models","text":"<p>Creating a local model can be done using the <code>model:create</code> command:</p> <pre><code>glaze model:create my-model\n</code></pre> <p>Schemas can be added to the model, either by using a stream already present on the given Ceramic node or by creating a new one:</p> Using an existing schemaCreating a new schema   <pre><code>glaze model:add my-model schema MySchema schemaStreamReference\n</code></pre>   <pre><code>glaze model:add my-model schema MySchema '{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"title\":\"MySchema\",\"type\":\"object\",\"properties\":{}}' --key=&lt;your key&gt;\n</code></pre>    <p>The <code>model:add</code> command can be used in a similar way to add Definitions (<code>model:add my-model definition ...</code>) and Tiles (<code>model:add my-model tile ...</code>).</p>","title":"Creating data models"},{"location":"tools/glaze/deploy-from-cli/#import-data-models","text":"<p>Existing models can be imported in a local model either using JSON files or locally installed packages (that can be imported by Node) using the <code>model:import</code> command:</p> Using a local fileUsing a package name   <pre><code>glaze model:import my-model ./model-to-import.json\n</code></pre>   <pre><code>glaze model:import my-model package-name-of-model\n</code></pre>","title":"Import data models"},{"location":"tools/glaze/deploy-from-cli/#export-data-models-as-json","text":"<p>A local model can also be exported to a JSON file using the <code>model:export</code> command:</p> <pre><code>glaze model:export my-model ./my-model.json\n</code></pre>","title":"Export data models as JSON"},{"location":"tools/glaze/deploy-from-cli/#deploy-to-ceramic","text":"<p>The <code>model:publish</code> command can be used to publish all the streams used by a given model:</p> Publishing a local modelPublishing a model filePublishing a model package   <pre><code>glaze model:publish my-model\n</code></pre>   <pre><code>glaze model:publish ./my-model.json\n</code></pre>   <pre><code>glaze model:publish package-name-of-model\n</code></pre>    <p>Optionally, a second argment can be provided to output the PublishedModel to a JSON file:</p> <pre><code>glaze model:publish my-model ./published-model.json\n</code></pre>","title":"Deploy to Ceramic"},{"location":"tools/glaze/deploy-from-cli/#next-steps-using-models-in-your-app","text":"","title":"Next steps: Using models in your app"},{"location":"tools/glaze/deploy-from-cli/#aliasing-your-data-models","text":"<p>Your output file can be used by the DataModel module contained in Glaze suite in order to give your model a friendly, human-readable name.</p>","title":"Aliasing your data models"},{"location":"tools/glaze/deploy-from-cli/#storing-and-retrieving-data","text":"<p>Your data models are now available to be used by the DID DataStore module provided by Glaze suite, which is also included in the Self.ID framework, to store and retrieve data from these data models.</p>","title":"Storing and retrieving data"},{"location":"tools/glaze/deploy-from-cli/#example","text":"<p>In this example, we will import and publish popular Ceramic data models found in the Data Models Registry, defined by the CIP-19 \"Basic Profile\", CIP-21 \"Crypto Accounts\" and CIP-23 \"Also Known As\" specifications.</p> <p>First, we need to install these data models from the Data Models Registry using npm:</p> <pre><code>npm install --dev @datamodels/identity-profile-basic @datamodels/identity-accounts-crypto @datamodels/identity-accounts-web\n</code></pre> <p>We can then import them when using the CLI in a folder where these npm packages can be resolved from, using the steps described above:</p> <pre><code>glaze model:create idx\nglaze model:import idx @datamodels/identity-profile-basic\nglaze model:import idx @datamodels/identity-accounts-crypto\nglaze model:import idx @datamodels/identity-accounts-web\nglaze model:publish idx\n</code></pre>","title":"Example"},{"location":"tools/glaze/development/","text":"<p>The Glaze DevTools module provides JavaScript APIs that allow you to programmatically create, edit, and deploy the data models used by your Ceramic application using a script. As opposed to manually deploying data models with the Glaze CLI, DevTools makes it easy to manage more models or more complex models.</p>","title":"Deploy data models from JavaScript"},{"location":"tools/glaze/development/#how-it-works","text":"<p>The DevTools module exports a <code>ModelManager</code> class, that can be used in scripts to programmatically manage a data model. The ModelManager object contains all data and metadata necessary to represent a Ceramic data model, and can be serialized to JSON.</p> <p>The ModelManager helps you to keep track of dependencies between streams that comprise your data models during development. For example, adding a data model definition to a model will also add the schema referenced by the definition, as both streams need to be present on your Ceramic node at runtime to work as expected.</p> <p>Additionally, data models promote reusability: a model can be created and edited on a local node and then deployed to the Ceramic testnet and mainnet with no change required in application code.</p>","title":"How it works"},{"location":"tools/glaze/development/#getting-started-with-devtools","text":"<p>Visit the Glaze DevTools reference \u2192 documentation for full instructions on how to install, configure, and use the module in your application.</p>","title":"Getting started with DevTools"},{"location":"tools/glaze/development/#installation","text":"<pre><code>npm install --dev @glazed/devtools\n</code></pre>","title":"Installation"},{"location":"tools/glaze/development/#setup","text":"<p>The <code>ModelManager</code> constructor requires a Ceramic instance, that must be authenticated when calling the create methods: <code>createSchema()</code>, <code>createDefinition()</code> and <code>createTile()</code>.</p> <pre><code>import { ModelManager } from '@glazed/devtools'\n\nconst manager = new ModelManager(ceramic)\n</code></pre>","title":"Setup"},{"location":"tools/glaze/development/#constructing-your-model-manager","text":"<p>A model manager consists of various data models used by your application. Each data model consists of one or more schemas and a definition. You'll need to add those schemas and definitions to your model manager.</p>","title":"Constructing your model manager"},{"location":"tools/glaze/development/#adding-schemas","text":"<p>If the stream containing the schema you wish to use is already available on your Ceramic node, you can add it like this:</p> <pre><code>await manager.usePublishedSchema('MySchema', schemaStreamReference)\n</code></pre> <p>If the schema you wish to use is not available on your Ceramic node or has not been created yet, you can create it like this:</p> <pre><code>await manager.createSchema('MySchema', {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  title: 'MySchema',\n  type: 'object',\n  properties: {\n    ...\n  },\n})\n</code></pre>","title":"Adding schemas"},{"location":"tools/glaze/development/#adding-definitions","text":"<p>Similar methods can be used to add data model definitions with <code>usePublishedDefinition()</code> and <code>createDefinition()</code> or Tiles with <code>usePublishedTile()</code> and <code>createTile()</code>.</p>","title":"Adding definitions"},{"location":"tools/glaze/development/#importexport-as-json","text":"<p>The ManagedModel used internally by a <code>ModelManager</code> can be exported and imported as JSON for easier portability and storage:</p> <pre><code>const encodedModel = manager.toJSON()\n\nconst clonedManager = ModelManager.fromJSON(ceramic, encodedModel)\n</code></pre>","title":"Import/export as JSON"},{"location":"tools/glaze/development/#deploy-to-ceramic","text":"<p>The model can be deployed to your Ceramic node by calling the <code>toPublished()</code> method:</p> <pre><code>const publishedModel = await manager.toPublished()\n</code></pre>","title":"Deploy to Ceramic"},{"location":"tools/glaze/development/#example","text":"<p>In this example, we will import and publish popular Ceramic data models found in the Data Models Registry, defined by the CIP-19 \"Basic Profile\", CIP-21 \"Crypto Accounts\" and CIP-23 \"Also Known As\" specifications.</p> <p>First, install these data models from the Data Models Registry using npm:</p> <pre><code>npm install --dev @datamodels/identity-profile-basic @datamodels/identity-accounts-crypto @datamodels/identity-accounts-web\n</code></pre> <p>Now we can then use them in a script:</p> <pre><code>import { ModelManager } from '@glazed/devtools'\nimport { model as basicProfileModel } from '@datamodels/identity-profile-basic'\nimport { model as cryptoAccountsModel } from '@datamodels/identity-accounts-crypto'\nimport { model as webAccountsModel } from '@datamodels/identity-accounts-web'\n\nconst manager = new ModelManager(ceramic)\nmanager.addJSONModel(basicProfileModel)\nmanager.addJSONModel(cryptoAccountsModel)\nmanager.addJSONModel(webAccountsModel)\n\nconst published = await manager.toPublished()\n</code></pre>","title":"Example"},{"location":"tools/glaze/did-datastore/","text":"<p>DID DataStore is a runtime library that allows any application to store and retrieve data from a Ceramic account's personal datastore, with support for public and private data. The DID DataStore API is based on data models; when multiple applications reuse the same data model, they reuse the same underlying data. As such, DID DataStore is core to how Ceramic delivers user-centric data composability across applications.</p>","title":"DID DataStore"},{"location":"tools/glaze/did-datastore/#how-it-works","text":"<p>The DID DataStore is an implementation of the Identity Index (IDX) protocol, allowing to associate records to a DID. To learn more about the IDX protocol, see its reference documentation.</p> <p></p>","title":"How it works"},{"location":"tools/glaze/did-datastore/#getting-started-with-did-datastore","text":"<p>Visit the DID DataStore reference \u2192 documentation for full instructions on how to install, configure, and use the module in your application. For convenience, here's a look at what's possible with DID DataStore:</p>","title":"Getting started with DID DataStore"},{"location":"tools/glaze/did-datastore/#installation","text":"<pre><code>npm install @glazed/did-datastore\n</code></pre>","title":"Installation"},{"location":"tools/glaze/did-datastore/#usage","text":"<p>The DID DataStore requires a Ceramic instance and either a DataModel instance or PublishedModel object provided by the Glaze DataModel library:</p> Using a DataModel instanceUsing a PublishedModel directly   <pre><code>import { DataModel } from '@glazed/datamodel'\nimport { DIDDataStore } from '@glazed/did-datastore'\n\nconst publishedModel = {\n  schemas: {\n    MySchema: 'ceramic://mySchemaURL',\n  },\n  definitions: {\n    myDefinition: 'myDefinitionID',\n  },\n  tiles: {},\n}\n\nconst model = new DataModel({ ceramic, model: publishedModel })\nconst dataStore = new DIDDataStore({ ceramic, model })\n</code></pre>   <pre><code>import { DIDDataStore } from '@glazed/did-datastore'\n\nconst publishedModel = {\n  schemas: {\n    MySchema: 'ceramic://mySchemaURL',\n  },\n  definitions: {\n    myDefinition: 'myDefinitionID',\n  },\n  tiles: {},\n}\n\nconst dataStore = new DIDDataStore({ ceramic, model: publishedModel })\n</code></pre>","title":"Usage"},{"location":"tools/glaze/did-datastore/#readwrite-data","text":"<p>It is then possible to read and write with data in the user's DataStore:</p> <pre><code>await dataStore.set('myDefinition', { record: 'content' })\n\nawait dataStore.get('myDefinition') // { record: 'content' }\n</code></pre>","title":"Read/Write Data"},{"location":"tools/glaze/example/","text":"","title":"Glaze example"},{"location":"tools/glaze/example/#1-prerequisites","text":"<p>In this example, we'll create a DataModel for a simple text note that can be associated to a DID, and an associated script to interact with this model.</p> <p>First, we will need to install the following runtime packages:</p> <pre><code>npm install @ceramicnetwork/http-client @glazed/datamodel @glazed/did-datastore dids key-did-provider-ed25519 key-did-resolver uint8arrays\n</code></pre> <p>The following steps will present two ways of going through the development flow: creating a custom script (recommended option for complex models) or using the Glaze CLI (simpler option for basic models):</p> Using a scriptUsing the CLI   <pre><code>npm install --dev @glazed/devtools\n</code></pre>   <pre><code>npm install --global @glazed/cli\n</code></pre>","title":"1. Prerequisites"},{"location":"tools/glaze/example/#2-local-setup","text":"ScriptCLI   <p>In order to create a DataModel, we need a Ceramic instance with an authenticated DID. DataModels only support DIDs using the <code>did:key</code> method, so we'll <code>key-did-provider-ed25519</code> in this example.</p> <p>Let's create a <code>create-model.mjs</code> file with the following contents:</p> <pre><code>import { writeFile } from 'node:fs/promises'\nimport { CeramicClient } from '@ceramicnetwork/http-client'\nimport { ModelManager } from '@glazed/devtools'\nimport { DID } from 'dids'\nimport { Ed25519Provider } from 'key-did-provider-ed25519'\nimport { getResolver } from 'key-did-resolver'\nimport { fromString } from 'uint8arrays'\n\n// The key must be provided as an environment variable\nconst key = fromString(process.env.DID_KEY, 'base16')\n// Create and authenticate the DID\nconst did = new DID({\n  provider: new Ed25519Provider(key),\n  resolver: getResolver(),\n})\nawait did.authenticate()\n\n// Connect to the local Ceramic node\nconst ceramic = new CeramicClient('http://localhost:7007')\nceramic.did = did\n\n// Create a manager for the model\nconst manager = new ModelManager(ceramic)\n</code></pre>   <p>Creating a local DataModel using the CLI simply requires to run the <code>model:create</code> command with a name to identify the model:</p> <pre><code>glaze model:create simple-note\n</code></pre> <p>Let's also create a DID if you don't already have one:</p> <pre><code>glaze did:create\n</code></pre> <p>You can then set the displayed key as the <code>DID_KEY</code> environment variable when running other commands, or make sure to provide it using the <code>--key</code> flag, as used in the following steps.</p>","title":"2. Local setup"},{"location":"tools/glaze/example/#3-datamodel-creation","text":"","title":"3. DataModel creation"},{"location":"tools/glaze/example/#simplenote-schema","text":"<p>We'll first create a JSON schema for an object containing a <code>text</code> property.</p> ScriptCLI   <pre><code>const noteSchemaID = await manager.createSchema('SimpleNote', {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  title: 'SimpleNote',\n  type: 'object',\n  properties: {\n    text: {\n      type: 'string',\n      title: 'text',\n      maxLength: 4000,\n    },\n  },\n})\n</code></pre>   <p>Here we will use the <code>model:add</code> command, that takes the following 4 arguments:</p> <ol> <li>The local model name</li> <li>The type to add, here a <code>schema</code></li> <li>The alias for this schema, here <code>SimpleNote</code></li> <li>The schema contents, as a JSON-encoded string</li> </ol> <pre><code>glaze model:add simple-note schema SimpleNote '{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"title\":\"SimpleNote\",\"type\":\"object\",\"properties\":{\"text\":{\"type\":\"string\",\"title\":\"text\",\"maxLength\":4000}}}' --key=&lt;your key&gt;\n</code></pre>    <p>Now that we have a schema, we can use it as reference in the following steps.</p>","title":"SimpleNote schema"},{"location":"tools/glaze/example/#mynote-definition","text":"<p>Definitions need to reference a specific version of a schema using a commit ID in URL form (starting with <code>ceramic://</code>).</p> ScriptCLI   <p>Using the manager, schema URLs should be accessed using the <code>getSchemaURL()</code> method:</p> <pre><code>// Create the definition using the created schema ID\nawait manager.createDefinition('myNote', {\n  name: 'My note',\n  description: 'A simple text note',\n  schema: manager.getSchemaURL(noteSchemaID),\n})\n</code></pre>   <p>Before we can create a definition, we need to inspect the model to retrieve the commit ID of our schema, identified by the <code>version</code>:</p> <pre><code>glaze model:inspect simple-note\n</code></pre> <p>We can then copy the <code>version</code> associated to the <code>SimpleNote</code> schema to the following command:</p> <pre><code>glaze model:add simple-note definition myNote '{\"name\":\"My note\",\"description\":\"A simple text note\",\"schema\":\"ceramic://&lt;SimpleNote schema version ID&gt;\"}' --key=&lt;your key&gt;\n</code></pre>","title":"myNote definition"},{"location":"tools/glaze/example/#examplenote-tile","text":"<p>Creating a tile is similar to a definition, except for the <code>schema</code> reference that needs to be provided as metadata rather than in the content:</p> ScriptCLI   <pre><code>// Create a tile using the created schema ID\nawait manager.createTile('exampleNote',\n  { text: 'A simple note' },\n  { schema: manager.getSchemaURL(noteSchemaID) },\n)\n</code></pre>   <pre><code>glaze model:add simple-note tile exampleNote '{\"text\":\"A simple note\"}' --schema='ceramic://&lt;SimpleNote schema version ID&gt;' --key=&lt;your key&gt;\n</code></pre>","title":"exampleNote tile"},{"location":"tools/glaze/example/#4-deployment-for-runtime","text":"<p>In this example, we are creating streams on the local Ceramic node, so we know they are already present and accessible at runtime. There are various cases however when we can't make assumptions about the presence of the necessary streams, for example on a testnet or CI node.</p> <p>The deployment process consists in publishing all the necessary streams potentially used by our DataModel at runtime to a given Ceramic node, in order to ensure their availability. The published model is then written to the <code>model.json</code> file, that will simply contain mappings for our aliases to stream references, for example:</p> <pre><code>{\n  \"definitions\": {\n    \"myNote\": \"kjzl6cwe1jw145a8rcoo8y9c1jtwa71cc33vvz7gqah1tg4dvoxkd62u8mzbz4d\"\n  },\n  \"schemas\": {\n    \"SimpleNote\": \"ceramic://k3y52l7qbv1frxtwv4ip9pdwe6vh3dh13rs0ynh4pwwqo7usnudlsvgm8w2gl4xz4\"\n  },\n  \"tiles\": {\n    \"exampleNote\": \"kjzl6cwe1jw149ymdkfpkmf0ighksbfxfgt6bm4ut45mapn87a4wm9nkf7xouzg\"\n  }\n}\n</code></pre> ScriptCLI   <p>We can add the following code at the end of our <code>create-model.mjs</code> script:</p> <pre><code>// Publish model to Ceramic node\nconst model = await manager.toPublished()\n\n// Write published model to JSON file\nawait writeFile('./model.json', JSON.stringify(model))\n</code></pre>   <p>We can use the <code>model:publish</code> command to deploy a model, optionally with a second argument to output the published model to a JSON file:</p> <pre><code>glaze model:publish simple-note ./model.json\n</code></pre>","title":"4. Deployment for runtime"},{"location":"tools/glaze/example/#5-runtime-usage","text":"","title":"5. Runtime usage"},{"location":"tools/glaze/example/#runtime-setup","text":"<p>Let's create a <code>run.mjs</code> file containing the following code:</p> <pre><code>import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { DataModel } from '@glazed/datamodel'\nimport { DIDDataStore } from '@glazed/did-datastore'\nimport { DID } from 'dids'\nimport { Ed25519Provider } from 'key-did-provider-ed25519'\nimport { getResolver } from 'key-did-resolver'\nimport { fromString } from 'uint8arrays'\n\n// Import the model aliases created during development time\nimport modelAliases from './model.json'\n\n// The key must be provided as an environment variable\nconst key = fromString(process.env.DID_KEY, 'base16')\n// Create and authenticate the DID\nconst did = new DID({\n  provider: new Ed25519Provider(key),\n  resolver: getResolver(),\n})\nawait did.authenticate()\n\n// Create the Ceramic instance and inject the DID\nconst ceramic = new CeramicClient('http://localhost:7007')\nceramic.did = did\n\n// Create the model and store\nconst model = new DataModel({ ceramic, model: modelAliases })\nconst store = new DIDDataStore({ ceramic, model })\n</code></pre> <p>This setup can then be used to perform any of the following use-cases.</p>","title":"Runtime setup"},{"location":"tools/glaze/example/#known-note-loading","text":"<p>We can now load the <code>exampleNote</code> tile using its alias:</p> <pre><code>const exampleNote = await model.loadTile('exampleNote')\n</code></pre>","title":"Known note loading"},{"location":"tools/glaze/example/#new-note-creation","text":"<p>Using the <code>DataModel</code> runtime, it is also possible to create new notes using the schema alias:</p> <pre><code>const newNote = await model.createTile('SimpleNote', { text: 'My new note' })\n</code></pre>","title":"New note creation"},{"location":"tools/glaze/example/#note-associated-to-a-did","text":"<p>Finally, using the DID DataStore, we can interact with the <code>myNote</code> record associated to a given DID:</p> <pre><code>await store.set('myNote', { text: 'This is my note' })\n\nawait store.get('myNote') // { text: 'This is my note' }\n</code></pre>","title":"Note associated to a DID"},{"location":"tools/glaze/glossary/","text":"<p>Common terms used in Glaze packages and tools.</p>","title":"Glaze Glossary"},{"location":"tools/glaze/glossary/#schema","text":"<p>A Ceramic TileDocument storing a JSON schema as contents. Schemas are the basis of most Glaze packages and tools functionalities.</p>","title":"Schema"},{"location":"tools/glaze/glossary/#definition","text":"<p>A TileDocument matching the Definition spec from CIP-11. Definitions are used in the Index of the DID DataStore.</p>","title":"Definition"},{"location":"tools/glaze/glossary/#tile","text":"<p>In the context of Glaze packages, a Tile refers to a TileDocument with an associated Schema.</p>","title":"Tile"},{"location":"tools/glaze/glossary/#model","text":"<p>A Glaze DataModel, containing a set of Schemas and potentially related Definitions and/or Tiles.</p>","title":"Model"},{"location":"tools/glaze/glossary/#index","text":"<p>A TileDocument matching the IdentityIndex spec from CIP-11, used by the DID DataStore to associate Definition IDs to Record IDs.</p>","title":"Index"},{"location":"tools/glaze/glossary/#record","text":"<p>Data associated to a DID for a given Definition in the DID DataStore. All records are validated using the Schema declared in the record's Definition.</p>","title":"Record"},{"location":"tools/glaze/overview/","text":"","title":"Glaze"},{"location":"tools/glaze/tile-loader/","text":"<p>The Glaze Tile Loader library improves application performance by providing batching and caching for tile document streams on the Ceramic network, reducing wait times for retrieving Ceramic data inside your application.</p>","title":"Caching Ceramic data with Tile Loader"},{"location":"tools/glaze/tile-loader/#how-it-works","text":"<p>Tile loader provides a thin abstraction on top of the <code>TileDocument</code> stream client to add the following performance improvements:</p> <ul> <li>Batching \u2013 groups concurrent loading of multiple streams in a single call</li> <li>Caching \u2013 stores already loaded streams client-side to avoid making repeated requests to the network</li> </ul> <p>The <code>TileLoader</code> class provided by the library extends the <code>DataLoader</code> class from the dataloader library to leverage its capabilities, and provides extra methods to support additional use cases for Ceramic.</p>","title":"How it works"},{"location":"tools/glaze/tile-loader/#getting-started-with-tile-loader","text":"<p>Visit the Glaze Tile Loader reference \u2192 documentation for full instructions on how to install, configure, and use the module in your application. For convenience, here's a look at what's possible with tile loader:</p>","title":"Getting started with Tile Loader"},{"location":"tools/glaze/tile-loader/#batching","text":"<p>Batching combines multiple concurrent queries to a Ceramic node into a single query.</p> <p>Without tile loader, a Ceramic client will retrieve two tile document streams from the network by performing two separate network requests:</p> <pre><code>import { TileDocument } from '@ceramicnetwork/stream-tile'\n\nconst [stream1, stream2] = await Promise.all([\n  TileDocument.load(ceramic, 'streamID1'),\n  TileDocument.load(ceramic, 'streamID2'),\n])\n</code></pre> <p>Wen using the <code>loader</code> instance, the two streams will now be loaded with a single network request:</p> <pre><code>import { TileLoader } from '@glazed/tile-loader'\n\nconst loader = new TileLoader({ ceramic })\nconst [stream1, stream2] = await Promise.all([\n  loader.load('streamID1'),\n  loader.load('streamID2'),\n])\n</code></pre>","title":"Batching"},{"location":"tools/glaze/tile-loader/#caching","text":"<p>Caching allows your application to keep track of streams client-side that have been previously retrieved from the network.</p>  <p> Caching is disabled by default and may not be suited for your use-cases, make sure you carefully consider the trade-offs before enabling it.</p> <p>Streams loaded from cache may be out of sync with the current state found on the network, so applications should be designed accordingly!</p>  <p>Without tile loader, the Ceramic client will perform two network requests to get the state of the stream at two different times:</p> <pre><code>import { TileDocument } from '@ceramicnetwork/stream-tile'\n\n// Load the stream at some point in your app\nconst stream = await TileDocument.load(ceramic, 'streamID')\n// Maybe the same stream needs to be loaded at a different time or in another part of your app\nconst streamAgain = await TileDocument.load(ceramic, 'streamID')\n</code></pre> <p>When using the <code>loader</code> instance, the second call will be resolved directly from the loader's internal cache rather than making a second network request:</p> <pre><code>import { TileLoader } from '@glazed/tile-loader'\n\nconst loader = new TileLoader({ ceramic, cache: true })\n\n// Load the stream at some point in your app\nconst stream = await loader.load('streamID')\n// Maybe the same stream needs to be loaded at a different time or in another part of your app\nconst streamAgain = await loader.load('streamID')\n</code></pre>","title":"Caching"},{"location":"tools/glaze/tile-loader/#customizing-your-cache","text":"<p>When setting the <code>cache</code> option to <code>true</code> in the loader constructor, the cache will live as long as the loader instance. This means that any stream will only ever get loaded from the network once, and persist in memory until the loader instance is deleted.</p> <p>It is possible to provide a custom cache implementation in the loader constructor to customize this behavior, for example in order to limit memory usage by restricting the number of streams kept in the cache, or discarding loaded streams after a given period of time.</p> <p>A custom cache must implement a subset of the Map interface, defined by the TileCache interface.</p> <pre><code>import { TileLoader } from '@glazed/tile-loader'\n\n// The cache must implement a subset of the Map interface\nconst cache = new Map()\nconst loader = new TileLoader({ ceramic, cache })\n\n// The loader will cache the request as soon as the load() method is called, so the stored value is a Promise of a TileDocument\nloader.load('streamID')\ncache.get('streamID') // Promise&lt;TileDocument&gt;\n</code></pre>","title":"Customizing your cache"},{"location":"tools/glaze/tile-loader/#additional-apis","text":"<p>In addition to the <code>DataLoader APIs</code>, the <code>TileLoader</code> class provides the following methods specific to Ceramic's use-cases.</p>","title":"Additional APIs"},{"location":"tools/glaze/tile-loader/#create-tile-documents","text":"<p>The <code>create()</code> method wraps a <code>TileDocument.create()</code> call to add the created stream to the internal cache of the loader. This has no effect if the cache is disabled.</p> <pre><code>import { TileLoader } from '@glazed/tile-loader'\n\nconst loader = new TileLoader({ ceramic, cache: true })\nconst stream = await loader.create({ hello: world })\n// The following call will returne the stream from the cache\nawait loader.load(stream.id)\n</code></pre>","title":"Create tile documents"},{"location":"tools/glaze/tile-loader/#retrieve-deterministic-tiles","text":"<p>In Ceramic, streams can be loaded using their metadata rather than a stream ID if they are created as determinitic streams.</p> <p>Using the <code>deterministic()</code> method of a loader instance allows to load such streams while benefiting from the batching and caching functionalities of the loader.</p> <pre><code>import { TileLoader } from '@glazed/tile-loader'\n\nconst loader = new TileLoader({ ceramic })\n// The following call will load the latest version of the stream based on its metadata, if such stream exists\nconst stream = await loader.deterministic({\n  controllers: ['did:key:...'],\n  family: 'test',\n})\n</code></pre>","title":"Retrieve deterministic tiles"},{"location":"tools/identitylink/overview/","text":"<p>IdentityLink is a service that issues verifiable claims which prove that a DID owns one or more Web2 social accounts. Once issued these claims can be stored anywhere, however it is recommended to store them in a user's Identity Index (IDX) under the Also Known As definition.</p>","title":"IdentityLink"},{"location":"tools/identitylink/overview/#compatibility","text":"","title":"Compatibility"},{"location":"tools/identitylink/overview/#did-methods","text":"<p>IdentityLink works with all DID methods.</p>","title":"DID Methods"},{"location":"tools/identitylink/overview/#web2-platforms","text":"<p>IdentityLink currently supports:</p> <ul> <li>Twitter</li> <li>Github</li> <li>Discord</li> <li>Discourse</li> <li>Telegram</li> <li>Instagram (coming soon)</li> </ul>","title":"Web2 Platforms"},{"location":"tools/identitylink/overview/#how-it-works","text":"","title":"How it works"},{"location":"tools/identitylink/overview/#public-dns","text":"<p>For platforms that allow users to post content to public DNS endpoints (i.e. Twitter, Github):</p>","title":"Public DNS"},{"location":"tools/identitylink/overview/#private-servers","text":"<p>For platforms that restrict messages to private servers (i.e. Telegram, Discord):</p>","title":"Private servers"},{"location":"tools/identitylink/overview/#usage","text":"","title":"Usage"},{"location":"tools/identitylink/overview/#use-the-identitylink-service-hosted-by-3box-labs","text":"<p>Add more about how to add it to your project.</p>","title":"Use the IdentityLink service hosted by 3Box Labs"},{"location":"tools/identitylink/overview/#run-your-own-identitylink-service","text":"<p>Point to the relevant instructions on how to run it yourself.</p>","title":"Run your own IdentityLink service"},{"location":"tools/identitylink/overview/#learn-more","text":"<p>Visit the IdentityLink repository on Github for full documentation.</p>","title":"Learn more"},{"location":"tools/self-id/configuration/","text":"<p>The Self.ID SDK requires minimum configuration. In this guide you will learn how to:</p> <ul> <li>Connect the SDK to a Ceramic node</li> <li>Configure your data models</li> </ul>","title":"Self.ID SDK configuration"},{"location":"tools/self-id/configuration/#connect-to-a-ceramic-node","text":"<p>In all Self.ID modules, you'll need to specify which Ceramic node to use. This endpoint can be the URL of any known Ceramic node, <code>http://localhost:7007</code>, or one of the following preconfigured options:</p>    Preconfigurations Network Permissions Implementation Host     <code>local</code> Local Write/Read JS Ceramic Local   <code>testnet-clay</code> Clay testnet Read/Write JS Ceramic 3Box Labs   <code>testnet-clay-gateway</code> Clay testnet Read-only JS Ceramic 3Box Labs   <code>mainnet-gateway</code> Mainnet Read-only JS Ceramic 3Box Labs     <p>When using localhost, ensure your local Ceramic node is running</p>   <p>The mainnet configuration for Self.ID is read-only. To perform writes on mainnet, you will need to join Ceramic's Mainnet Early Launch Program.</p>","title":"Connect to a Ceramic node"},{"location":"tools/self-id/configuration/#configure-your-data-models","text":"<p>Self.ID APIs are built on top of data models. By default, the SDK supports interacting with the following data models without further configuration:</p>    Data model Alias Description     <code>identity-profile-basic</code> (CIP-19) <code>basicProfile</code> Stores a user's profile   <code>identity-accounts-web</code> (CIP-23) <code>alsoKnownAs</code> Stores verifiable credentials that link a user's Web2 accounts to their Ceramic account.   <code>identity-accounts-crypto</code> (CIP-21) <code>cryptoAccounts</code> Stores a list of CAIP-10 Links that link a user's Web3 accounts to their Ceramic account.    <pre><code>import { Core } from '@self.id/core'\n\nconst core = new Core({ ceramic: 'testnet-clay' })\n\nconst profile = await core.get('basicProfile', id)\n</code></pre>","title":"Configure your data models"},{"location":"tools/self-id/configuration/#using-additional-data-models","text":"<p>It is possible to provide alternative models for use in the Self.ID <code>Core</code> module, or any Self.ID module that extends it, including <code>Web</code>, <code>React</code>, and <code>Framework</code>. </p> <pre><code>import { Core } from '@self.id/core'\n\nconst model = {\n  definitions: {\n    profile: 'kjzl6cwe1jw145cjbeko9kil8g9bxszjhyde21ob8epxuxkaon1izyqsu8wgcic',\n  },\n  schemas: {\n    Profile:\n      'ceramic://k3y52l7qbv1frxt706gqfzmq6cbqdkptzk8uudaryhlkf6ly9vx21hqu4r6k1jqio',\n  },\n  tiles: {},\n}\n\nconst core = new Core({ ceramic: 'testnet-clay', model })\n\nconst profile = await core.get('profile', id)\n</code></pre>  <p>You can learn more about creating and using DataModels in the dedicated page.</p>","title":"Using additional data models"},{"location":"tools/self-id/framework/","text":"<p><code>@self.id/framework</code> is the highest-level abstraction provided by the Self.ID SDK, designed to easily power React applications with React components, hooks, and utility functions for user authentication, data storage, and retrieval.</p> <p>Native support for React \u2013 React components, hooks and related utility functions to help manage user authentication, storage, and retrieval on Ceramic.</p> <p>Authentication hook \u2013 React hook to easily initiate a Ceramic sign-in flow where users are authenticated client-side with their Ethereum or other EVM-compatible wallet.</p> <p>User data management hook \u2013 Data storage and retrieval APIs are primarily based on the concept of a viewer, aka the current user of the app, which can be the currently-authenticated user or the last known authenticated user (for example when using a cookie for persistence). APIs are read-only if the viewer is not authenticated, but support reads and writes if they're authenticated.</p>","title":"Self.ID Framework"},{"location":"tools/self-id/framework/#getting-started-with-framework","text":"<p>Visit the Self.ID Framework reference \u2192 documentation for full instructions on how to install, configure, and use the module in your application. For convenience, here's a look at what's possible with the Self.ID Framework:</p>","title":"Getting started with Framework"},{"location":"tools/self-id/framework/#installation","text":"<p>Install <code>@self.id/framework</code> from npm:</p> <pre><code>npm install @self.id/framework\n</code></pre>","title":"Installation"},{"location":"tools/self-id/framework/#setup-and-configuration","text":"<p>The <code>Provider</code> component must be added at the root of the application tree in order to use the React hooks described below. It can be used to provide a custom configuration for the Self.ID clients, authentication, state and UI options.</p> <pre><code>import { Provider } from '@self.id/framework'\n\nfunction App({ children }) {\n  return &lt;Provider client={{ ceramic: 'testnet-clay' }}&gt;{children}&lt;/Provider&gt;\n}\n</code></pre>","title":"Setup and configuration"},{"location":"tools/self-id/framework/#user-authentication","text":"<p>The <code>useConnection</code> hook provides a way for applications to access the current authentication state, initiate the authentication flow, and reset the authentication state.</p> <pre><code>import { useConnection } from '@self.id/framework'\n\nfunction ConnectButton() {\n  const [connection, connect, disconnect] = useConnection()\n\n  return connection.status === 'connected' ? (\n    &lt;button\n      onClick={() =&gt; {\n        disconnect()\n      }}&gt;\n      Disconnect ({connection.selfID.id})\n    &lt;/button&gt;\n  ) : 'ethereum' in window ? (\n    &lt;button\n      disabled={connection.status === 'connecting'}\n      onClick={() =&gt; {\n        connect()\n      }}&gt;\n      Connect\n    &lt;/button&gt;\n  ) : (\n    &lt;p&gt;\n      An injected Ethereum provider such as{' '}\n      &lt;a href=\"https://metamask.io/\"&gt;MetaMask&lt;/a&gt; is needed to authenticate.\n    &lt;/p&gt;\n  )\n}\n</code></pre> <p>The user authentication flow consists of the following steps:</p> <ol> <li>A modal prompts the user to select their Web3 wallet</li> <li>Selecting a wallet initiates the connection to access the Ethereum provider</li> <li>An Ethereum auth provider is created using the Ethereum provider</li> <li>The auth flow with 3ID Connect starts, using the Ethereum authentication provider</li> <li>A <code>SelfID</code> instance is created and stored in application state</li> </ol> <p>Once this flow is completed, the viewer's cookie is set to the authenticated user and storing data with the user becomes possible.</p>","title":"User authentication"},{"location":"tools/self-id/framework/#data-management","text":"<p>The <code>useViewerRecord</code> hook loads the viewer's data for a given data model (definition), with the following variants:</p> <ul> <li>If no viewer is set, no data can be loaded</li> <li>If the viewer is not authenticated, the data gets loaded but cannot be modified</li> <li>If the viewer is authenticated, the data gets loaded and can be modified</li> </ul> <pre><code>import { useViewerRecord } from '@self.id/framework'\n\nfunction ShowViewerName() {\n  const record = useViewerRecord('basicProfile')\n\n  const text = record.isLoading\n    ? 'Loading...'\n    : record.content\n    ? `Hello ${record.content.name || 'stranger'}`\n    : 'No profile to load'\n  return &lt;p&gt;{text}&lt;/p&gt;\n}\n</code></pre> <p>The <code>usePublicRecord</code> hook is similar to the <code>useViewerRecord</code> hook described above, but is used to read public data from an explicitly provided account rather than the viewer. This hook is read-only and can be used, for example, to retrieve the public data for other users of your application to display in a UI.</p> <pre><code>import { usePublicRecord } from '@self.id/framework'\n\nfunction ShowProfileName({ did }) {\n  const record = usePublicRecord('basicProfile', did)\n\n  const text = record.isLoading\n    ? 'Loading...'\n    : record.content\n    ? `Hello ${record.content.name || 'stranger'}`\n    : 'No profile to load'\n  return &lt;p&gt;{text}&lt;/p&gt;\n}\n</code></pre>","title":"Data management"},{"location":"tools/self-id/framework/#advanced","text":"","title":"Advanced"},{"location":"tools/self-id/framework/#server-side-rendering","text":"<p>Server-side rendering can be used to improve the user experience for the first load of an app or page. The Self.ID Framework exports a <code>RequestClient</code> class that can be used to fetch data on a server in order to have it immediately available to the <code>usePublicRecord</code> and <code>useViewerRecord</code> hooks.</p> <p>This example shows how server-side rendering can be used in a Next.js page, using the <code>ShowViewerName</code> component from the <code>useViewerRecord</code> hook example:</p> <pre><code>import { Provider, RequestClient } from '@self.id/framework'\n\nexport const getServerSideProps = async (ctx) =&gt; {\n  const client = new RequestClient({\n    ceramic: 'testnet-clay',\n    // Inject the cookie from the request headers to parse the viewerID\n    cookie: ctx.req.headers.cookie,\n  })\n  if (client.viewerID != null) {\n    // If the viewerID is set, fetch its profile\n    await client.prefetch('basicProfile', client.viewerID)\n  }\n  return { props: { state: client.getState() } }\n}\n\n// Use the state prop injected by the server\nexport default function Home({ state }) {\n  return (\n    &lt;Provider state={state}&gt;\n      &lt;ShowViewerName /&gt;\n    &lt;/Provider&gt;\n  )\n}\n</code></pre>","title":"Server-side rendering"},{"location":"tools/self-id/overview/","text":"","title":"Self.ID"},{"location":"tools/self-id/read/","text":"<p>The <code>@self.id/core</code> module provides read-only user data APIs for Node and browser-based applications.</p>  <p>If you need user data storage, use Self.ID Framework for React or Self.ID Web for web.</p>","title":"Self.ID Core"},{"location":"tools/self-id/read/#getting-started-with-selfid-core","text":"<p>Visit the Self.ID Core reference \u2192 documentation for full instructions on how to install, configure, and use the module in your application. For convenience, here's a look at what's possible with Self.ID Core:</p>","title":"Getting started with Self.ID Core"},{"location":"tools/self-id/read/#installation","text":"<p>Install <code>@self.id/core</code> from npm:</p> <pre><code>npm install @self.id/core\n</code></pre>","title":"Installation"},{"location":"tools/self-id/read/#setup-and-configuration","text":"<p>Before using the Self.ID Core APIs, make sure you have configured your setup including your node and data models.</p>","title":"Setup and configuration"},{"location":"tools/self-id/read/#connect-to-a-ceramic-ndoe","text":"<p>The Self.ID <code>Core</code> instance generates a Ceramic client that needs to connect to a Ceramic node:</p> <pre><code>import { Core } from '@self.id/core'\n\n// connect to a known URL\nconst core = new Core({ ceramic: 'http://localhost:7007' })\n// or use one of the preconfigured option\nconst core = new Core({ ceramic: 'testnet-clay' })\n</code></pre> <p>This Ceramic endpoint can be the URL of any known node, <code>http://localhost:7007</code>, or one of Self.ID's preconfigured node options.</p>","title":"Connect to a Ceramic ndoe"},{"location":"tools/self-id/read/#configure-data-models","text":"<p>Self.ID core come pre-configured with a few popular data models that you can use to retrieve data from the network. You can read about those data models, and learn how to add additional data models, in the data models configuration page.</p>","title":"Configure data models"},{"location":"tools/self-id/read/#retrieving-user-data","text":"","title":"Retrieving user data"},{"location":"tools/self-id/read/#using-the-core-instance","text":"<p>The Self.ID <code>Core</code> instance can be used directly to read user data from Ceramic, using the <code>get()</code> method with a data model (definition) alias as the first argument and the user's Ceramic account as the second argument:</p> <pre><code>import { Core } from '@self.id/core'\n\nconst core = new Core(...)\n\nconst profile = await core.get('basicProfile', 'did:3:...')\n</code></pre>","title":"Using the core instance"},{"location":"tools/self-id/read/#using-the-publicid-class","text":"<p>For use-cases when it is helpful to keep track of a specific account and possibly retrieve its data multiple times, the <code>PublicID</code> class can be used to wrap a Ceramic account:</p> <pre><code>import { Core, PublicID } from '@self.id/core'\n\nconst core = new Core(...)\nconst aliceID = 'did:3:123...'\n\n// rather than using the Core instance directly as followed...\nconst [profile, accounts] = await Promise.all([\n  core.get('basicProfile', aliceID),\n  core.get('cryptoAccounts', aliceID),\n])\n\n// ... a PublicID instance can be used:\nconst alice = new PublicID({ core, id: aliceID })\nconst [profile, accounts] = await Promise.all([\n  alice.get('basicProfile'),\n  alice.get('cryptoAccounts'),\n])\n</code></pre>","title":"Using the PublicID class"},{"location":"tools/self-id/sample-applications/","text":"<p>This page contains sample applications built with the Self.ID SDK that you can use and dig through their code.</p>","title":"Self.ID Sample Apps"},{"location":"tools/self-id/sample-applications/#profile-applications","text":"<p>These reference applications use the Self.ID SDK to allow users to create a Web3 profile attached to their Ceramic account and Ethereum wallet.</p> <p>Create a Web3 profile on Ceramic mainnet \u2192</p> <p>Create a Web3 profile on Ceramic testnet \u2192</p>","title":"Profile applications"},{"location":"tools/self-id/utilities/","text":"","title":"Application utilities"},{"location":"tools/self-id/utilities/#image-utilities","text":"<p>The <code>@self.id/image-utils</code> module provides various utility functions for managing images on Web3 and is mostly meant to be used in a Web browser environment:</p> <ul> <li>Multi-sizing \u2013 Automatically convert an image into multiple sizes</li> <li>IPFS upload \u2013 Upload all image sizes to IPFS as a linked data structure</li> <li>Smart selection \u2013 Retrieve the most suitable image size based on your use case. For example, you might want to load profile image thumnails for a social UI or leaderboard, and load a larger resolution image for a single user profile page.</li> </ul>","title":"Image utilities \u2192"},{"location":"tools/self-id/write/","text":"<p>The <code>@self.id/web</code> module provides user authentication, data storage, and retrieval for browser-based web applications.</p>  <p>If you're building with React, we recommend using Self.ID Framework instead.</p>","title":"Self.ID Web"},{"location":"tools/self-id/write/#getting-started-with-selfid-web","text":"<p>Visit the Self.ID Web reference \u2192 documentation for full instructions on how to install, configure, and use the module in your application. For convenience, here's a look at what's possible with Self.ID Web:</p>","title":"Getting started with Self.ID Web"},{"location":"tools/self-id/write/#installation","text":"<p>Install <code>@self.id/web</code> from npm:</p> <pre><code>npm install @self.id/web\n</code></pre>","title":"Installation"},{"location":"tools/self-id/write/#user-authentication","text":"<p>The Self.ID web module exports the <code>SelfID</code> and <code>WebClient</code> classes. Either can be used for user authentication via an Ethereum or EVM-comppatible wallet:</p>","title":"User authentication"},{"location":"tools/self-id/write/#using-the-selfid-class","text":"<p>The process of creating all instances needed by your web application (<code>WebClient</code>, <code>DID</code> and <code>SelfID</code>) can be reduced to using the <code>SelfID.authenticate()</code> static authentication method:</p> <pre><code>import { EthereumAuthProvider, SelfID } from '@self.id/web'\n\n// The following assumes there is an injected `window.ethereum` provider\nconst addresses = await window.ethereum.request({\n  method: 'eth_requestAccounts',\n})\n\n// The following configuration assumes your local node is connected to the Clay testnet\nconst self = await SelfID.authenticate({\n  authProvider: new EthereumAuthProvider(window.ethereum, addresses[0]),\n  ceramic: 'local',\n  connectNetwork: 'testnet-clay',\n})\n</code></pre>","title":"Using the SelfID class"},{"location":"tools/self-id/write/#using-the-webclient-class","text":"<p>The <code>WebClient</code> class extends <code>Core</code> from the <code>@self.id/core</code> package with the additional <code>connectNetwork</code> parameter to specify the Ceramic network that should be used by 3ID Connect:</p> <pre><code>import { EthereumAuthProvider, SelfID, WebClient } from '@self.id/web'\n\n// The following assumes there is an injected `window.ethereum` provider\nconst addresses = await window.ethereum.request({\n  method: 'eth_requestAccounts',\n})\nconst authProvider = new EthereumAuthProvider(window.ethereum, addresses[0])\n\n// The following configuration assumes your local node is connected to the Clay testnet\nconst client = new WebClient({\n  ceramic: 'local',\n  connectNetwork: 'testnet-clay',\n})\n\n// If authentication is successful, a DID instance is attached to the Ceramic instance\nawait client.authenticate(authProvider)\n\n// A SelfID instance can only be created with an authenticated Ceramic instance\nconst self = new SelfID({ client })\n</code></pre>","title":"Using the WebClient class"},{"location":"tools/self-id/write/#data-management","text":"<p>After authenticating the user with either of the above methods, your application can perform data storage and retrieval interactions with the user based on a data model (definition):</p> <pre><code>await self.set('basicProfile', { name: 'Alice' })\n</code></pre>","title":"Data management"}]})